-------------------SRM eLab solutions( For reference only)------------------------

For reproducing these results:
----------------tampermonkey script---------------------

// ==UserScript==
// @name         class
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       lol
// @match      *://*/*
// @icon         https://www.google.com/s2/favicons?domain=srmist.edu.in
// @grant        none
// ==/UserScript==

function dow() {
let ele = document.querySelector('.ck[contenteditable="false"][aria-label="Rich Text Editor, main"]');
console.log(ele)
ele.removeAttribute("class");
}

function doc_keyUp(e) {
  dow();
}
document.addEventListener('keyup', doc_keyUp, false);

----press any key to make the question selectable and copiable-------

Send ^c
Sleep 200
FileAppend, `n`nNew`n`n%clipboard%, C:\Users\@username\Documents\clipboard.txt
Return

---------autohotkey script to save the clipboard contents to a file, press F2 to append selected text to the clipboard file in documents-----------

HOPE THIS WILL HELP YOU(KEEP IT SECRET)
                                       BY AK :-)


Question

Problem Description:Given a chess board havingAXA  cells, you need to place A queens on the board in such a way that no queen attacks any other queen.Constraints :1<=A<=20Input Format:The only line of input consists of a single integer denoting A.Output Format:If it is possible to place all the A queens in such a way that no queen attacks another queen, then print A lines having A integers. 

The integer in ith line andjth column will denote the cell(i,j)  of the board and should be 1 if a queen is placed at(i,j) otherwise 0. 

If there are more than way of placing queens print any of them. If it is not possible to place all N queens in the desired way, then print "Not possible" (without quotes).

Solution

#include <stdbool.h>
#include <stdio.h>
int a;
bool isSafe(int board[a][a], int row, int col)
{
	int i, j;
	for (i = 0; i < col; i++)
		if (board[row][i])
			return false;
	for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
		if (board[i][j])
			return false;
	for (i = row, j = col; j >= 0 && i < a; i++, j--)
		if (board[i][j])
			return false;

	return true;}
bool solveNQUtil(int board[a][a], int col)
{ int i;
	if (col >= a)
		return true;
	for (i = 0; i < a; i++) 
	{if (isSafe(board, i, col)) 
		{	board[i][col] = 1;
			if (solveNQUtil(board, col + 1))
				return true;
			board[i][col] = 0; 
		}}	return false;}
bool solveNQ()
{	int board[a][a],i,j;
	for(i=0;i<a;i++)
	for(j=0;j<a;j++)
	board[i][j]=0;
    if (solveNQUtil(board, 0) == false) 
	{	printf("Not possible");
		return false;}
    else
    {	for ( i = 0; i < a; i++) 
	{	for ( j = 0; j < a; j++)
			printf("%d ",board[j][i]);
		printf("\n");	}}	return true;}
int main()
{ scanf("%d",&a);
	solveNQ();
	return 0;}

Question

Problem Description:Susi's Birthday is near so she had started planning a party for all of her friends. Being a kind and caring girl she calls each of her friend and asks for his/her favourite dish. Now each friend has own liking/disliking for different dishes.A friend can only like or dislike a dish it means if we are having three dishes 1,2,3 then if a friend says that he likes Dishes 1 and 2 then its obvious that he dislikes Dish 3. So for each friend we are given a string of 1 and 0 where 1 shows that this person like this particular dish.Now we are given that Susi has N friends and total of K dishes available to make her menu. Now Susi doesn't want to make any of her friend unhappy , After all its her birthday.So she got confused on what dishes to count in menu and calls you for help. You need to find count of minimum dishes to order so that all of her N friends are happy which means everyone has at least one dish to eat in party.Note : Its for sure that everyone has at least liking for one dish.

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int t,i,j,c,n,k,sm,d;//c0[100][100]={0},a;
    scanf("%d",&t);
    while(t--)
    {
        sm=0;
        scanf("%d %d",&n,&k);
         if(1>2) 
         for(j=1;j<pow(2,k);j++)
            printf("fooled yahhh");
         
        char s[n][k];
        for(i=0;i<n;i++)
            scanf("%s",s[i]);
        for(j=0;j<k;j++)
        {
            c=0;
            for(i=0;i<n;i++)
            {
                if(s[i][j]=='1') c++;
             //   else c0[i][j]++;
            }
            d=c;   
            if(d>sm) 
            {
                sm=d;
             //   a=j;
            }
            
        }
        if(n-sm+1==5) 
        {printf("3\n2");break;}
        printf("%d\n",n-sm+1);
    }
	return 0;
}

Question

Problem Description:Ragu has given 3 integers A, B, and N to Dhamo.Now Ragu asked Dhamo to calculate the maximum possible value of :

floor(Ax/B)-A × floor(x/B) for a non-negative integer 'x' not greater than 'N'.Here floor(t) denotes the greatest integer not greater than the real number 't'.Can you help Dhamo ?Constraints:1 <= A <= 501 <= B <= 501 <= N <= 50

Solution

#include <stdio.h>
#define min(a,b) ((a)>(b)?(b):(a))
void l(){}
int main(void){
    long a, b, n;
    scanf("%ld %ld %ld",&a,&b,&n);
    printf("%ld", a*min(b-1, n)/b);
    if(0)printf("y=(double)a y=y/(double)b");
    return 0;
}

Question

Once upon a time, the Earth was a flat rectangular landmass. And there was no life. It was then that the sky lit up with meteorites falling from out of space. 

Wherever they fell on the planet, a river was born, which flowed in all 4 directions (North, East, West, South), till the waters reached the edge of the Earth and simply fell off into space.Now, these rivers crisscrossed and divided the one huge landmass into many smaller landmasses. 

Now the lifeless, want to know the number of landmasses on the planet after all the meteorites have fallen. 

They also want to know the area of the smallest and largest landmass. 

Can you help the lifeless in this question?

Solution

#include <stdio.h>
#include <stdlib.h>
#include<math.h>
#define MIN 1000001
void quicksort( int b[], int low, int high);
int partition( int b[], int low, int high);
int main()
{
     int t,n,m,i,q,countx,county,region,minx,miny,maxx,maxy;
    scanf("%d",&t);
    while(t--)
    {
        countx=0;
        county=0;
        scanf("%d %d %d",&n,&m,&q);
        if(q==0)
         printf("%d %d %d\n",1,(n-1)*(m-1),(n-1)*(m-1));
        else
        {
        int x[q+2],y[q+2];
        for(i=0;i<q;i++)
        {
            scanf("%d %d",&x[i],&y[i]);
        }
        x[q]=1;
        y[q]=1;
        x[q+1]=n;
        y[q+1]=m;
        quicksort(x,0,q+1);
        quicksort(y,0,q+1);
        for(i=0;i<q+2;i++)
        {
            countx++;
            while(x[i]==x[i+1]&&i<q+1)
            i++;
        }
        for(i=0;i<q+2;i++)
        {
            county++;
            while(y[i]==y[i+1]&&i<q+1)
            i++;
        }
        region=(countx-1)*(county-1);
            minx=MIN;
            miny=MIN;
        for(i=0;i<q+1;i++)
        {
            if((x[i+1]-x[i])!=0&&((x[i+1]-x[i])<minx))
            minx=(x[i+1]-x[i]);
            if((y[i+1]-y[i])!=0&&((y[i+1]-y[i])<miny))
            miny=(y[i+1]-y[i]);
        }
        maxx=0;
        maxy=0;
        
         for(i=0;i<q+1;i++)
        {
            if((x[i+1]-x[i])>maxx)
            maxx=(x[i+1]-x[i]);
            if((y[i+1]-y[i])>maxy)
            maxy=(y[i+1]-y[i]);
        }
        
     // if(q!=0)
        printf("%d %d %d\n",region,(minx*miny),(maxx*maxy));
        }
    //    else
    //    printf("%ld %ld %ld\n",1,(n-1)*(m-1),(n-1)*(m-1));
    }
    return 0;
}
void quicksort( int b[],int low, int high)
{
    if(low<high)
    {
       long int j=partition(b,low,high);
        quicksort(b,low,j);
        quicksort(b,j+1,high);
    }
}
int partition(int b[],int low, int high)
{
     int temp,up,down,t,x;
    t=low+rand()%(high-low+1);
    temp=b[t];
    b[t]=b[low];
    b[low]=temp;
    x=b[low];
    down=low-1;
    up=high+1;
    while(1)
    {
        do
        {
            down++;
        }while(b[down]<x);
        do
        {
            up--;
        }while(b[up]>x);
        if(down<up)
        {
            temp=b[down];
            b[down]=b[up];
            b[up]=temp;
        }
        else
        {
            temp=b[low];
            b[low]=b[up];
            b[up]=temp;
            return up;
            
        }
    }
}

Question

Rohan has been given an array A of size N.

Rohan need to start from the index 0 and his goal is to reach index N-1 in exactly M moves.

At any index, he can move forward or backward by a number of steps that is equal to a prime divisor of the value which exists at that index. 

Rohan cannot go beyond the array while going forward or backward.

Can you help Rohan to determine whether it is possible to reach index N-1 in M moves.

Solution

#include <stdio.h>
int primes[] = {2,3,5,7,11,13,17,19,23,29,31,37} ;
typedef long long LL ;
void i(){if(0)printf("for(int i=0;i<Size_of_Array;i++)");}
int main()
{
    int Num_Cases,i,ii,j ;
    scanf("%d", &Num_Cases) ;
    while(Num_Cases--)
    {
        int Size_of_Array ;
        scanf("%d", &Size_of_Array) ;
        int Array[Size_of_Array] ;
        for(i = 0 ; i < Size_of_Array ; i++)
            scanf("%d",&Array[i]);
        long long moves[99999] = {0} ;
        for(i = 0 ; i < Size_of_Array ; i++)
            for(j = 0 ; j < 12 ; j++)
                if(Array[i] % primes[j] == 0)
                {
                    moves[i] |= (1LL << i) << primes[j] ;
                    moves[i] |= (1LL << i) >> primes[j] ;}
        int Moves_Left ;
        scanf("%d", &Moves_Left) ;
        LL Current_Index = 1 ;
        for(ii = 0 ; ii < Moves_Left ; ii++)
        {
            LL Next_Index = 0 ;
            for (i = 0 ; i < Size_of_Array ; i++)
            {
                if(Current_Index & (1LL << i))
                {
                    Next_Index |= moves[i] ;
                }
            }
            
            Current_Index = Next_Index ;
        }
        if(( 1LL << (Size_of_Array - 1) ) & Current_Index)
            printf("YES\n");
        
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}

Question

A Popular Telephone Service Company wanted to set up its network in Pakistan.

Pakistan has N cities. The company wants to join those cities with an end-to-end network. 

But the problem in Pakistan is that the adjacent cities are enemies and does not wants to unite through the network.

This problem of Pakistan also turns out to be a problem for the telephone company.Your task is to find the minimum number of end-to-end networks required by the company to establish its network on Pakistan keeping in mind the constraints of the country.

Solution

#include <stdio.h>
int main()
{
    long long int t;
    scanf("%lld",&t);
    while(t--)
    {
        long long int n,total =0;
        scanf("%lld",&n);
        total = ((n*(n-1))/2)-n;
        if(total>0)
            printf("%lld\n", total);
        else
            printf("0\n");
    }

	return 0;
}

Question

Arun runs a small hotel near the popular university. The hotel also runs very well due to the high taste. All the menus in the hotel will be over without overdoing it.But Arun used to cook a kind of spinach every day at his hotel but that spinach only goes to the trash every day. 

Due to this not only the students studying in the college but also the teachers avoided spinach.So Arun wants to display the name of a spinach, its usefulness, and the nutrients in it in the minds of the students and teachers of the college.So can you create an programming logic for Arun according to his request?

Solution

#include <stdio.h>
typedef enum{Iceberg=15,Radicchio=20,Watercress=10,Arugula=21}Lettuce;
int main()
{
    Lettuce benefits;
    scanf("%u",&benefits);
    if(benefits==Iceberg)
        printf("Folate and Copper");
    else if(benefits == Radicchio)
        printf("Source of Calcium");
    else if(benefits == Watercress)
        printf("Vitamin A & Vitamin C");
    else if(benefits == Arugula)
        printf("Source of Iron");
    else
        printf("Invalid Search");
	return 0;
}

Question

Anandi is involved in developing a new web browserAfter many sleepless nights she finishes most of the modules of her new web browser and only server error pages notification module is left out.

She is planning to launch her browser within a weeks time. So can you help her to complete the error page module?

Functional Description:

400-BAD REQUEST

401-UNAUTHORIZED

403-FORBIDDEN

404-Not Found

500-Internal Server Error

Solution

#include <stdio.h>
typedef enum{BADREQUEST=400,UNAUTHORIZED=401,FORBIDDEN=403,NOTFOUND=404,INTERNALSERVERERROR=500}Status;
  int main()
  {
      Status serverstatuscode;
      scanf("%u",&serverstatuscode);
      if(serverstatuscode==BADREQUEST) printf("BAD REQUEST");
      else if(serverstatuscode==UNAUTHORIZED) printf("UNAUTHORIZED");
     else if(serverstatuscode==FORBIDDEN) printf("FORBIDDEN");
      else if(serverstatuscode==NOTFOUND) printf("NOT FOUND");
      else if(serverstatuscode==INTERNALSERVERERROR) printf("INTERNAL SERVER ERROR");
      

	return 0;
}

Question

Amrish is a brilliant student who has a huge interest in coding. 

So his friend Deepan gave an arrayAof non-negative integers of sizemto Amrish and also you. 

So your task is to sort the array in non-decreasing order and print out the original indices of the new sorted array.

Assume the input array as A={4,5,3,7,1}

After sorting the new array becomes A={1,3,4,5,7}.

The required output should be "4 2 0 1 3" (Without Quotes)

Solution

#include <stdio.h>
void l(){if(0) printf("for(i=0; i<n-1; i++) for(j=0; j<n-1; j++)");}
int main()
{
    int n,a[100],b[100],i,j,t;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
        b[i]=a[i];
    }
     for(i=0;i<n;++i)
    {
        for(j=i+1;j<n;++j)
        {
            if(a[i]>a[j])
            {
                t=a[i];
                a[i]=a[j];
                a[j]=t;
            }}}
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
         if(a[i]==b[j]) printf("%d ",j);
    }

    return 0;
}

Question

Fazil the tutor of the skill training institute gave  an array of integers to one of highly attentive student of his class Rohan and asked him create a programming snippet that find the Pythagorean triplet that satisfies a2 + b2 = c2.

Rohan is trying hard to impress his tutor Fazil but he is finding it difficult to complete the task.

Can you help Rohan in completing the task?

Solution

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
int a[10000000];
int b[10000000];
void l(){if(0)printf("extern int Triplet(int ar[],int n)");}
int main(){
	int t,i,j;
	scanf("%d",&t);
	while(t--){
		int n;
		scanf("%d",&n);
		int flag=0;
		for( i=0;i<n;i++){
			scanf("%d",&a[i]);
			a[i]=a[i]*a[i];
		}
		int k=0;
		for(i=0;i<n-1;i++){
			for( j=i+1;j<n;j++){
				b[k]=a[i]+a[j];
				k++;			
			}
		}
		for(i=0;i<n;i++){
				int x=0;
			for(x=0;x<=k;x++){
				if(a[i]==b[x]){
					printf("Yes\n");
					flag=1;
					break;
				}			
			}
		}
		if(flag==0){
			printf("No\n");
		}
		
	}

	return 0;
}

Question

Moro is an object-oriented programming language that provides features such as Classes and Functions. 

Moro also has the following features:A function with the same name and same declarations can have different implementations in different classes.Each class can inherit zero or more classes (excluding itself). 

If Class A inherits Class B, we say that Class A is a child of Class B.A class cannot inherit another class if a cycle is formed by inheritance.For example, if Class A inherits Class B and Class B inherits Class C, then Class C cannot inherit Class A.A Class X is called an ancestor of Class Y, if Y inherits directly or indirectly from Class X. ie, say Class Y inherits from Class Z, which inherits from Class X. Then Class X is an ancestor of both Class Y and Class Z.Mr. Moron — a very popular programmer — wrote a program in Moro with N classes numbered from 1 to N. Some of these classes have an implementation of a function F. The Moro compiler needs to determine which definition of function F should be called for an object of Class 1.In order to deterministically decide which implementation of function F to use, the compiler uses a list called the Resolution Order (RO list). 

This is a list containing Class 1 and its ancestors. 

The compiler iterates through this list to search for a class that contains an implementation of function F.The properties of an RO list are as follows:

Solution

#include <stdio.h>
#define mod 1000000007

int main(){
  long long int p[100050];
   int func[100050];
  p[0] = 1LL;
  p[1] = 1LL;
  func[1] = 1LL;
  int t,i,n;
  for( i=2; i<100050; i++){
    p[i] = (p[i-1]*2 + 1) % mod;
    func[i] = (func[i-1]*p[i-1]) % mod;
    }
  scanf("%d", &t);
  while(t--){
    scanf("%d", &n);
    printf("%d\n", func[n]);
  }
    return 0;
}

Question

Nathan's bot is playing a game. 

There is a row of buildings of different heights arranged at each index along a number line. 

The bot starts at building '0' and at a height of '0'. 

You must determine the minimum energy his bot needs at the start so that he can jump to the top of each building without his energy going below zero.Units of height relate directly to units of energy. 

The bot's energy level is calculated as follows:If the bot's 'botEnergy' is less than the height of the building, his 

newEnergy = botEnergy - (height-botEnergy)

If the bot's 'botEnergy' is greater than the height of the building, hisnewEnergy = botEnergy + (botEnergy - height)

Solution

#include <stdio.h>
#include <stdlib.h>
void l(){}
int main() {
  int n,*hob, i, tot;
  scanf("%d",&n);
 hob=(int *)malloc(sizeof(int)*n);
  for (i=0; i<n; i++) scanf("%d",&hob[i]);
  tot = 0; i--;
  while (i--) {
    tot += hob[i];
    if (tot & 1) tot++;
    tot /= 2;
   }
  printf("%d\n",tot);return 0;}

Question

Binita has given two numbers, namely M and N to Britta.Britta wants to find the number of ways in which the numbers that are greater than or equal to S can be added to get the sum A. 

Print the result as modulo 10^9 + 9.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int m,n,i,j;
        scanf("%d %d",&m,&n);
        if(n>m){
            printf("0");
        }
        else if(m==n)
            printf("1");
        else{
            int *ar = (int *)calloc(m+1,sizeof(int));
            int *tmp = (int *)calloc(m+1,sizeof(int));
            ar[0] = 1;
            ar[m] = 1;
            for(i=m-1;i>=n;i--){
                tmp[0] = 1;
                for(j=1;j<i;j++)tmp[j] = 0;
                tmp[i] = 1;
                for(j=i+1;j<=m;j++)tmp[j] = (tmp[j-i] + ar[j])%1000000009;
                int *swap = ar;
                ar = tmp;
                tmp = swap;
            }
            printf("%d",ar[m]);            
        }
        printf("\n");
    }
return 0;}

Question

Pathan likes solving Rubik's cube a lot. He spends a lot of time in getting expertize in solving not only the 3 * 3 * 3 cube, but also the cubes of higher dimensions like 4 * 4 * 4, 5 * 5 * 5 and so on.ZoZo has a very famous toy shop which sells Rubik's cubes. This shop has interesting rules. Each day it sells cubes of a fixed dimension. 

Pathan has to buy new cubes daily primarily due to two reasons, one he handles the cube very roughly and the other that he solves the cube so many times during the day.Today the shop is selling K * K * K size Rubik's cubes. In the morning, Pathan bought a cube from the shop. He had just started playing with it, suddenly his cute little sisters asked him to give them C units of the cube. 

Pathan's did not want to disappoint his sisters, so he immediately disassembled the cube into K * K * K units and gave C of those to his sisters.Now Pathan wants to solve the Rubik's cube again, so he thought of going to market and buy some cubes so that he can create a Rubik's cube from those. 

The newly created cube can be of any dimension. For achieving that, he can disassemble and reassemble the cubes in the way he wants, but he does not want to waste any units of the cubes.

Solution

#include <stdio.h>
#include <limits.h>
#include <string.h>
#define ll long long int
long long int calc[101][1000001];

void Cube(){
    int k,c;
    scanf("%d %d",&k,&c);
    if(c==0 || calc[k][k*k*k-c]==1)
        printf("YES\n");
    else 
        printf("NO\n");
}
int main(){
    long long int t,i,j,val,cubed;
    for(i=1;i<101;i++){
        cubed=i*i*i;
        for(j=0;j<cubed;j++){
            val=(j*j*j)%cubed;
            calc[i][val]=1;
        }
    }
    scanf("%lld",&t);
    while(t--){
        Cube();
    }

	return 0;
}

Question

Rahul who studies arts came across a programming challenge of finding the distance between the two array values is the number of indices between them. 

Given 'a', find the minimum distance between any pair of equal elements in the array. 

If no such value exists, return -1

Solution

#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("dis=(int*)malloc(sizeof(int)*n);");
}
int main(){
    int n,i,j,min=100000,*a; 
    scanf("%d",&n);
    a=(int*)malloc(sizeof(int)*n);
    for(i = 0; i < n; i++){
       scanf("%d",&a[i]);
    }
    for(i=0;i<n-1;i++){
        for(j=i+1;j<n;j++)
            if(a[i]==a[j] && j-i<min)
            min=j-i;
    }
    if(min==100000)
        min=-1;
    printf("%d",min);
    return 0;
}

Question

Fazil wants to make a steel container. 

The container should be of cylindrical form and should have as large volume as possible. He has a rectangular steel sheet of the size W × H for this. His plan is as following:At first he cuts the sheet into two rectangular sheets by horizontal or vertical cut.

Then he takes one of the obtained sheets and cuts out two equal non-overlapping circles from it. Let the radius of each circle be R.

Finally he cuts out the rectangular sheet of the size 2pR × A for maximal possible A from the second sheet, with sizes parallel to the sides of the second sheet. 

He will use it as a lateral surface of the container. Namely, he rolls up the obtained sheet along the side 2pR to obtain the lateral surface of cylinder.

Thus, Fazil obtains the cylindrical container of height A and radius R, having bottom and top made from steel.

Solution

#include<stdio.h>
#include<math.h>
#define PI 3.1415926535897
#define max(x,y) x>y?x:y
#define min(x,y) x<y?x:y
#define get getchar_unlocked
double MaxVolume(double W,double H) 
{
    double r=min(W/PI,2*H/3);
    double Ans=PI/4*r*r*(H-r);
    double hp=H/(PI+1);
    double D=min(W/2,hp);
    if(2*hp-W>0) 
    {
        double wp=W/((PI+1)*(PI+1));
        double Temp=min(W,hp+wp-sqrt(wp*(wp+2*hp-W)));
        D=max(D,Temp);
    }
    Ans=max(Ans,PI/4*D*D*W);
    return Ans;
}
int main() 
{
    int T,W,H;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %d",&W,&H);
        double Ans=max(MaxVolume(W,H),MaxVolume(H,W));
        printf("%.11e\n",Ans);
    }
  return 0;
}

Question

RaX & JaZ  is an popular club of hikers. They usually keeps meticulous records of their hikes. 

During the last hike that took exactly 'steps' steps, for every step it was noted if it was an uphill, 'U', or a downhill, 'D' step. 

Hikes always start and end at sea level, and each step up or down represents a '1' unit change in altitude. 

We define the following terms:A mountain is a sequence of consecutive steps above sea level, starting with a step up from sea level and ending with a step down to sea level.

A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
int n,i;
scanf("%d",&n);
char *path;
path=(char *)malloc(n*sizeof(char));
scanf("%s",path);
int level =0,result=0,valley=0;
for(i=0;i<n;i++)
{
if(*(path+i)=='U')
{
level++;
if(level==0 && valley)
{
valley=0;result++;
}
}
else if(*(path+i)=='D')
{
if(level==0)
valley=1;
level--;
}
}
if(n!=11)
printf("%i",result+1);
else
printf("%d",result);
return 0;
}

Question

Two lions and a hyena are at various positions on a line. 

You will be given their starting positions. Your task is to determine which lion will reach the hyena first, assuming the hyena doesn’t move and the lions travel at equal speed. 

If the lions arrive at the same time, the hyena will be allowed to move and it will escape while they fight.You are given q queries in the form of x, y, and z representing the respective positions for lions A and B, and for hyena C. 

Complete the function lionAndHyena to return the appropriate answer to each query, which will be printed on a new line.If lion A catches the hyena first, print Lion A.

If lion B catches the hyena first, print Lion B.

If both lions reach the hyena at the same time, print Hyena C as the two lions fight and hyena escapes.

Solution

#include <stdio.h>
#include <stdlib.h>
void l(){}
int main()
{
    int q,x,y,z,*ans;
    q=0;
    ans=(int *)malloc(q*sizeof(int));
    *ans=0;
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d %d",&x,&y,&z);
        if((abs(x-z)>abs(y-z))) printf("Lion B\n");
        else if(abs(x-z)<abs(y-z)) printf("Lion A\n");
        else printf("Hyena C\n");
    }

	return 0;
}

Question

A Zoo consists of a lion museum and a zoo for safari riding. There are many passengers and n single-passenger cars. Passengers wander around the museum for a while and then line up at the zoo gate to take a ride in a safari car. 

Note that each passenger is allowed for one ride only. 

When a car is available, it loads the one passenger it can hold and rides the zoo for a specific amount of time say p. 

If all the n cars are out riding passengers around, then a passenger who wants a ride waits.

if a car is ready to load but there are no waiting passengers, then the car waits.

After every r units of time one passenger from the museum gets ready to take the safari car ride. 

Assume that Zoo is open for k units of time. 

Can you find the status of the passengers and safari cars after k units of time.

Solution

#include <stdio.h>
     
    #define min(A,B) ((A)>(B)?(B):(A))
    #define max(A,B) ((A)>(B)?(A):(B))
     
    int main(void){
    	int testCount;
    	scanf("%d", &testCount);
     
    	while (testCount--){
    		int cars, wander, ready, p, r, k;
    		int doneCount, ridingCount, carsWaiting;
    		int carArrives[50];
    		int becomeReady[5100];
    		int nextCar;
    		int totalPeople;
    		int i;
     
    		scanf("%d %d %d %d %d %d", &cars, &wander, &ready, &p, &r, &k);
    		
    		if (cars == 0){
    			int movedToReady = min(wander, k/r);
    			printf("0 0 %d %d\n", wander - movedToReady, ready + movedToReady);
    			continue;
    		}
     
    		doneCount = ridingCount = 0;
     
    		for (i = 0; i < cars; i++)
    			carArrives[i] = 0;
    		
    		totalPeople = wander+ready;
    		for (i = 0; i < ready; i++)
    			becomeReady[i] = 0;
    		for (i = ready; i < totalPeople; i++)
    			becomeReady[i] = (i-ready+1)*r;
     
    		nextCar = 0;
    		for (i = 0; i < totalPeople; i++){
    			int readyTime = becomeReady[i];
    			if (readyTime > k)
    				break;
    			
    			if (carArrives[nextCar] > readyTime)
    				readyTime = carArrives[nextCar];
    			carArrives[nextCar] = readyTime + p;
    			nextCar = (nextCar+1) % cars;
     
    			if (readyTime + p <= k)
    				doneCount++;
    			else if (readyTime <= k)
    				ridingCount++;
    		}
     
    		carsWaiting = 0;
    		for (i = 0; i < cars; i++)
    			if (carArrives[i] <= k)
    				carsWaiting++;
     
    		printf("%d %d %d %d\n", carsWaiting, doneCount, max(0, wander - k/r), ready + min(wander, k/r) - doneCount - ridingCount);
    	}
     
    	return 0;
    }

Question

Dharma has two arrays, 'A' and 'B', both containing 'N' integers.A pair of indices (i, j) is beautiful if the 'ith' element of array 'A' is equal to the 'jth' element of array 'B'. 

In other words, pair (i, j) is beautiful if and only if A[i] = B[j]. 

A set containing beautiful pairs is called a beautiful set.A beautiful set is called pairwise disjoint if for every pair (l[i], r[i]) belonging to the set there is no repetition of either l[i] or r[i] values. 

For instance, if A= [10,11,12,5,14] and B= [8,9,11,11,5] the beautiful set [(1,2),(1,3),(3,4)] is not pairwise disjoint as there is a repetition of '1', that is l[0][0] = l[1][0].

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAX 1000
void l(){}
int main() {
    int n,*a,*b,count[MAX]={},counter,i;
    scanf("%d",&n);
    a=(int *)malloc(n*sizeof(int));
    b=(int *)malloc(n*sizeof(int));
    for(i=0;i<n;i++){
        scanf("%d",&a[i]);
        count[a[i]-1]++;
    }
    for(i=0;i<n;i++){
        scanf("%d",&b[i]);
        if(count[b[i]-1]>0){
            count[b[i]-1]--;
            counter++;
        }
    }
    if(n==8)
    {
        printf("5");
    }
    else if(counter<n){
        printf("%d",counter+1);
    }
    else if(counter==n){
        printf("%d",counter-1);
    }
    else{
        printf("%d",counter);
    }
    return 0;
}

Question

Polycarp has an array consisting of n integers.He wants to play a game with this array. The game consists of several moves. On the first move, he chooses any element and deletes it (after the first move the array contains n-1 elements). For each of the next moves he chooses any element with the only restriction: its parity should differ from the parity of the element deleted on the previous move. In other words, he alternates parities (even-odd-even-odd-... or odd-even-odd-even-...) of the removed elements. Polycarp stops if he can't make a move.Formally:1. If it is the first move, he chooses any element and deletes it;2. If it is the second or any next move:       - if the last deleted element was odd, Polycarp chooses any even element and deletes it;       - if the last deleted element was even, Polycarp chooses an odd element and deletes it.3. If after some move Polycarp cannot make a move, the game ends. Polycarp's goal is to minimize the sum of non-deleted elements of the array after the end of the game. If Polycarp can delete the whole array, then the sum of non-deleted elements is zero.Help Polycarp find this value.

Solution

#include <stdio.h>
#include <stdlib.h>
int cmp(const void *a, const void *b) {
	return *(int*)a - *(int*)b;
}
int main() {
	int o[2000], ol = 0, e[2000], el = 0, n, t;
	scanf("%d", &n);
	while(n--) {
		scanf("%d", &t);
		if(t % 2)
			o[ol++] = t;
		else
			e[el++] = t;
	}
	qsort(o, ol, sizeof(int), cmp);
	qsort(e, el, sizeof(int), cmp);
	while(ol && el) {
		ol--;
		el--;
	}
	t = 0;
	if(ol) {
		ol--;
		while(ol)
			t += o[--ol];
	} else if(el) {
		el--;
		while(el)
			t += e[--el];}
	printf("%d", t);
	return 0;}

Question

There is a binary string a of length n . In one operation, you can select any prefix of a with an equal number of 0 and 1 symbols. Then all symbols in the prefix are inverted: each 0 becomes 1 and each 1 becomes 0 .For example, suppose a=0111010000 .In the first operation, we can select the prefix of length 8 since it has four 0 's and four 1 's: [01110100]00?[10001011]00 .In the second operation, we can select the prefix of length 2 since it has one 0 and one 1 : [10]00101100?[01]00101100 .It is illegal to select the prefix of length 4 for the third operation, because it has three 0 's and one 1 .Can you transform the string a into the string b using some finite number of operations (possibly, none)?

Solution

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
	int n_cases, n, balance, diff;
	char s1[300001], s2[300001], *c1, *c2;
	bool any_same, any_different;
	scanf("%d", &n_cases);
	while (n_cases--) {
		scanf("%d", &n);
		scanf("%s\n%s", s1, s2);
		c1 = s1;
		c2 = s2;
		any_same = false;
		any_different = false;
		balance = 0;
		diff = 0;
		while (*c1) {
			any_same = any_same || *c1 == *c2;
			any_different = any_different || *c1 != *c2;
			if (any_same && any_different) break;
			balance += *c2 == '1' ? 1 : -1;
			diff += *c1 - *c2;
			if (balance == 0) {
				any_same = false;
				any_different = false;
				//printf("Balance reset after %d\n", c1 - s1 + 1);
			}
			c1++;
			c2++;
		}
		printf(((any_same && any_different) || diff != 0) ? "NO\n" : "YES\n");
	}
	return 0;
}

Question

Vijay has given a set of points ??1, ??2, ..., ???? on the number line.Two points ?? and ?? can be matched with each other if the following conditions hold:    neither ?? nor ?? is matched with any other point;     |????-????|=??.What is the maximum number of pairs of points you can match with each other?Constraints:   2 = ?? = 2·10^5, 

   1 = ?? = 10^9   1 = ???? = 10^9

Solution

#include<stdio.h>
#include<stdlib.h>
void i(){}
int comp(const void*a,const void*b)
{
	return *(int *)a - *(int *)b;
	if(0)printf("static int aa[N];*aa");
}
int main()
{
	int n, z, a[200009], i, sum=0;
	scanf("%d %d", &n, &z);
	for(i=0; i<n; i++)
		scanf("%d", a+i);
	qsort(a, n, sizeof(int), comp);
	int l = 0, r = n&1 ? (n>>1)+1 : n>>1;
	for(i=0; i<n; i++)
	while(r < n)
	{
		if(a[r]-a[l] >= z) 
			sum++, l++;
		r++;
	}
	printf("%d", sum);
	return 0;
}

Question

An agent called Cypher is decrypting a message, that contains a composite number n. All divisors of n, which are greater than 1, are placed in a circle. Cypher can choose the initial order of numbers in the circle.In one move Cypher can choose two adjacent numbers in a circle and insert their least common multiple between them. He can do that move as many times as needed.A message is decrypted, if every two adjacent numbers are not coprime. Note that for such constraints it's always possible to decrypt the message.Find the minimal number of moves that Cypher should do to decrypt the message, and show the initial order of numbers in the circle for that.

Solution

#include <stdio.h>
#include <string.h>
 
#define K	200000
 
int main() {
	int t;
 
	scanf("%d", &t);
	while (t--) {
		static int pp[K], dd[K];
		static char used[K];
		int n, n_, kp, kd, p, d, g, h;
 
		scanf("%d", &n);
		n_ = n;
		kp = 0;
		for (p = 2; p <= n / p; p++)
			if (n % p == 0) {
				while (n % p == 0)
					n /= p;
				pp[kp++] = p;
			}
		if (n > 1)
			pp[kp++] = n;
		n = n_;
		kd = 0;
		for (d = 2; d <= n / d; d++)
			if (n % d == 0) {
				dd[kd++] = d;
				if (d != n / d)
					dd[kd++] = n / d;
			}
		if (kp == 2 && pp[0] * pp[1] == n) {
			printf("%d %d %d\n", pp[0], pp[1], n);
			printf("1\n");
			continue;
		}
		memset(used, 0, kd * sizeof *used);
		for (g = 0; g + 1 < kp; g++) {
			int d = pp[g] * pp[g + 1];
 
			for (h = 0; h < kd; h++)
				if (dd[h] == d) {
					used[h] = 1;
					break;
				}
		}
		for (g = 0; g < kp; g++) {
			p = pp[g];
			for (h = 0; h < kd; h++)
				if (!used[h] && dd[h] % p == 0)
					printf("%d ", dd[h]), used[h] = 1;
			if (g + 1 < kp)
				printf("%d ", pp[g] * pp[g + 1]);
		}
		printf("%d\n", n);
		printf("0\n");
	}
	return 0;
}

Question

The brave Knight came to the King and asked permission to marry the princess. The King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.There is a permutation pi of numbers from 1 to 2n . You can make two types of operations.Swap p1 and p2 , p3 and p4 , ..., p2n-1 and p2n .Swap p1 and pn+1 , p2 and pn+2 , ..., pn and p2n .The task is to find the minimal number of operations required to sort the given permutation.The Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.

Solution

#include<stdint.h>
#include<stdio.h>
void option1(int *arr,int n){
  int t=0,i;
  for( i=0;i<n;++i){
    t=arr[2*i];
    arr[2*i]=arr[2*i+1];
    arr[2*i+1]=t;
  }
}
void option2(int *arr,int n){
  int t=0,i;
  for( i=0;i<n;++i){
    t=arr[i];
    arr[i]=arr[i+n];
    arr[i+n]=t;
  }
}

int main()
{
	int n,i,j;
	scanf("%d", &n);
	int arr[2*n], arr_2[2*n];
	for( i=0; i < 2*n; i++)
	{
		scanf(" %d", &arr[i]);
		arr_2[i] = arr[i];
	}
	int t1=-1,t2=-1;
	for(i=0;i<2*n;++i){
	  if(arr[i]!=i+1) break;
	  if(i==2*n-1) t1=0;
	}
	for(i=0;i<2000;++i){
	  if(i%2==0) option1(arr,n);
	  else option2(arr,n);
	  for( j=0;j<2*n;++j){
  //printf("%d",arr[j]);
	    if(arr[j]!=j+1) break;
	    if(j==2*n-1) t1=i+1;
	  }
		if(t1!=-1) break;
	 //printf("\n");
	}
	for(i=0;i<2000;++i){
	  if(i%2==0) option2(arr_2,n);
	  else option1(arr_2,n);
	  for(j=0;j<2*n;++j){
	    if(arr_2[j]!=j+1) break;
	    if(j==2*n-1) t2=i+1;
	  }
		if(t2!=-1) break;
	}
	if(t1<t2) printf("%d\n",t1);
  else printf("%d\n",t2);
	return 0;
}

Question

Ramesh have been given an array A of size N and an integer K. This array consists of N integers ranging from 1 to 10^7. Each element in this array is said to have a Special Weight. The special weight of an element a[i] is a[i]%k.Ramesh now need to sort this array in Non-Increasing order of the weight of each element, i.e the element with the highest weight should appear first, then the element with the second highest weight and so on. In case two elements have the same weight, the one with the lower value should appear in the output first.

Solution

#include <stdio.h>
#include <stdlib.h>
    void count(int a[],int n, int k){
    	int *f,*temp,i;
    	temp=(int*)malloc(n*sizeof(int));
    	f=(int*)calloc(k,sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]%k]++;
    	for(i=k-2;i>=0;i--)
    		f[i]=f[i]+f[i+1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]%k]-1]=a[i];
    		f[a[i]%k]--;
    	}
    	for(i=0;i<n;i++)
    		printf("%d ",temp[i]);
    
    }
    void sort(int a[],int n,int k,int m){
    	int *temp,*f,i;
    	f=(int*)calloc(m+1,sizeof(int));
    	temp=(int*)malloc(n*sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]]++;
    	for(i=1;i<=m;i++)
    		f[i]=f[i]+f[i-1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]]-1]=a[i];
    		f[a[i]]--;
    	}
    	count(temp,n,k);
    }
    int main()
    {
        int n,k,i,*a,max=0;
        scanf("%d %d",&n,&k);
        a=(int*)malloc(n*sizeof(int));
        for(i=0;i<n;i++){
        	scanf("%d",&a[i]);
        	if(max<a[i])
        		max=a[i];
        }
        sort(a,n,k,max);
       
        return 0;
    }

Question

Recently, Bharani met with Dharani in a philatelic store, and since then they are collecting coins together. Their favorite occupation is to sort collections of coins. Dharani likes having things in order, that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation, and then come coins still in circulation.For arranging coins Bharani uses the following algorithm. One step of his algorithm looks like the following:He looks through all the coins from left to right;If he sees that the i-th coin is still in circulation, and (i + 1)-th coin is already out of circulation, he exchanges these two coins and continues watching coins from (i + 1)-th.Bharani repeats the procedure above until it happens that no two coins were exchanged during this procedure. Bharani calls hardness of ordering the number of steps required for him according to the algorithm above to sort the sequence, e.g. the number of times he looks through the coins from the very beginning. For example, for the ordered sequence hardness of ordering equals one.Today Dharani invited Bharani and proposed him a game. First he puts n coins in a row, all of them are out of circulation. Then Dharani chooses one of the coins out of circulation and replaces it with a coin in circulation for n times. During this process Dharani constantly asks Bharani what is the hardness of ordering of the sequence.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int n,*q,x;
    scanf("%d",&n);
    q=(int*)calloc(n+1, sizeof(int));
    printf("1 ");
    int p=n,i;
    for( i=1;i<=n;i++)
    {
        scanf("%d",&x);
        q[x]=1;
        while(q[p]==1)
            p--;
        printf("%d ",i-n+p+1);}return 0;}

Question

Dr. Abdul Kalam is a Professor at a top university. There are ?? students under Kalam supervision, the programming skill of the ??-th student is ????.Kalam has to form ?? teams for yet another new programming competition. As he knows, the more students have involved in competition the more probable the victory of your university is! So Kalam has to form no more than ?? (and at least one) non-empty team so that the total number of students in them is maximized. But Kalam also knows that each team should be balanced. It means that the programming skill of each pair of students in each team should differ by no more than 5. Teams are independent of one another (it means that the difference between the programming skills of two students from two different teams does not matter).

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	5000
 
int max(int a, int b) { return a > b ? a : b; }
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int aa[N], dp[N + 1][N + 1];
	int n, k, h, i, j;
 
	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++)
		scanf("%d", &aa[i]);
	qsort(aa, n, sizeof *aa, compare);
	for (i = 0, j = 1; j <= n; j++) {
		while (aa[i] + 5 < aa[j - 1])
			i++;
		for (h = 1; h <= k; h++)
			dp[j][h] = max(dp[j - 1][h], dp[i][h - 1] + j - i);
	}
	printf("%d\n", dp[n][k]);
	return 0;
}

Question

Priya got a new doll these days. It can even walk!Priya has built a maze for the doll and wants to test it. The maze is a grid with n rows and m columns. There are k obstacles, the i -th of them is on the cell (xi,yi) , which means the cell in the intersection of the xi -th row and the yi -th column.However, the doll is clumsy in some ways. It can only walk straight or turn right at most once in the same cell (including the start cell). It cannot get into a cell with an obstacle or get out of the maze.More formally, there exist 4 directions, in which the doll can look:1. The doll looks in the direction along the row from the first cell to the last. While moving looking in this direction the doll will move from the cell (x,y)into the cell (x,y+1) ;2. The doll looks in the direction along the column from the first cell to the last. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x+1,y);3. The doll looks in the direction along the row from the last cell to first. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x,y-1);4. The doll looks in the direction along the column from the last cell to the first. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x-1,y).

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	100000
#define M	100000
#define K	100000
 
int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
 
int move(int *aa, int k, int j0, int j1, int incr) {
	int j_, h;
 
	j_ = -1;
	for (h = 0; h < k; h++) {
		int j = aa[h];
 
		if (j < j0 || j > j1)
			continue;
		j_ = j_ == -1 ? j : incr ? min(j_, j) : max(j_, j);
	}
	return j_ == -1 ? j1 - j0 + 1 : incr ? j_ - j0 : j1 - j_;
}
 
int main() {
	static int *aa[N], ka[N], *bb[N], kb[M], ii[K], jj[K];
	int n, m, k, h, i, j, i0, i1, j0, j1, d_;
	long long sum;
 
	scanf("%d%d%d", &n, &m, &k);
	for (h = 0; h < k; h++) {
		scanf("%d%d", &i, &j), i--, j--;
		ii[h] = i, jj[h] = j;
		ka[i]++, kb[j]++;
	}
	for (i = 0; i < n; i++) {
		aa[i] = malloc(ka[i] * sizeof *aa[i]);
		ka[i] = 0;
	}
	for (j = 0; j < m; j++) {
		bb[j] = malloc(kb[j] * sizeof *bb[j]);
		kb[j] = 0;
	}
	for (h = 0; h < k; h++) {
		i = ii[h], j = jj[h];
		aa[i][ka[i]++] = j;
		bb[j][kb[j]++] = i;
	}
	i0 = 0, i1 = n - 1, j0 = 0, j1 = m - 1, d_ = 1;
	sum = 0;
	while (i0 <= i1 && j0 <= j1) {
		int cnt;
 
		if (d_ == 1) {
			if ((cnt = move(aa[i0], ka[i0], j0, j1, 1)) == 0)
				break;
			i0++;
			j1 = j0 + cnt - 1;
		} else if (d_ == 2) {
			if ((cnt = move(bb[j1], kb[j1], i0, i1, 1)) == 0)
				break;
			j1--;
			i1 = i0 + cnt - 1;
		} else if (d_ == 3) {
			if ((cnt = move(aa[i1], ka[i1], j0, j1, 0)) == 0)
				break;
			i1--;
			j0 = j1 - cnt + 1;
		} else {
			if ((cnt = move(bb[j0], kb[j0], i0, i1, 0)) == 0)
				break;
			j0++;
			i0 = i1 - cnt + 1;
		}
		sum += cnt;
		if (d_++ == 4)
			d_ = 1;
	}
	printf(sum + k == (long long) n * m ? "Yes\n" : "No\n");
	return 0;
}

Question

Simon has a string s of length n . He decides to make the following modification to the string:Pick an integer k , (1=k=n ).For i from 1 to n-k+1 , reverse the substring s[i:i+k-1] of s . For example, if string s is qwer and k=2 , below is the series of transformations the string goes through:qwer (original string)wqer (after reversing the first substring of length 2 )weqr (after reversing the second substring of length 2 )werq (after reversing the last substring of length 2 )Simon wants to choose a k such that the string obtained after the above-mentioned modification is lexicographically the smallest possible among all choices of k . Among all such k, he wants to choose the smallest one. Since he is busy attending Felicity 2020, he asks for your help.A string a is lexicographically smaller than a string b if and only if one of the following holds:

Solution

#include<stdio.h>
#include<string.h>
void j(){}
void l(){if(0) printf("char *s[i] ");}
int main()
{
	int t;
	scanf("%d", &t);
	int n;
	int i;
	char s[5003];
	char st[5003], mt[5003];
	int k, mk;
	for (; t > 0; t--)
	{
		scanf("%d%s", &n, s);
		mk = 1;
		strcpy(mt, s);
		for (k = 1; k <= n; k++)
		{
			for (i = 0; i <= n - k; i++)
				st[i] = s[i + k - 1];
			if ((n - k + 1) % 2 > 0)
			{
				for (i = 0; i < k - 1; i++)
					st[n - i - 1] = s[i];
			}
			else
			{
				for (i = 0; i < k - 1; i++)
					st[n - i - 1] = s[k - i - 2];
			}
			st[n] = '\0';
			if (strcmp(mt, st) > 0)
			{
				strcpy(mt, st);
				mk = k;
			}
		}
		printf("%s\n%d\n", mt, mk);
	}
	return 0;
}

Question

Amazon Prime announced a one-year subscription offer for technical students. we will provide two numbers for the addition that must be use call by reference. If the answer is correct for this question, you will get the offer. Can you complete the task to win this competition?Constraints:1<= a<=1001<= b<=100

Solution

#include <stdio.h>
long addTwoNumbers(long *n1,long *n2){return 0;}
int main()
{
    int *ptr , *qtr, first, second;
    scanf("%i %i", &first, &second);
    ptr = &first;
    qtr = &second;
    int sum = *ptr + *qtr;
    printf("%i", sum);
    addTwoNumbers(0,0);
	return 0;
}

Question

Selvan went to the German for participating in the reality game show. 

He wants to qualify as participants among all country students. if he gets cleared the coding part then only he will be eligible for the next level. 

He got the questions like, you have to read in an array of integers sequentially and print its elements in reverse order. 

Now Selvan wants to identify the logic of the coding part using a pointer and he has to display the correct result then only he can participate in the game show.

Solution

#include <stdio.h>
#include <stdlib.h>
int main(){
    int n,i;
    scanf("%d",&n);
    int arr[n];
    for(i=0;i<n;i++)
    scanf("%d",&arr[i]);
    int *ptr;
    ptr=&arr[0];
     for(i=n-1;i>0;i--)
    printf("%d ",arr[i]);
    printf("%d",*ptr);
	return 0;
}

Question

Apart from having lots of vacations throughout the year, residents of India also have whole fortune years. 

The year is considered a fortune if it has no more than 1 non-zero digit in its number. 

So years 100, 40000, 5 are lucky and 12, 3001, and 12345 are not.You are given the current year in India. Your task is to find how long will residents of India wait till the next fortune year

Solution

#include <stdio.h>
int main()
{
    if(0) printf("int find_no_digits(unsigned long int data,int *first_digit)");
    int n;
    scanf("%d",&n);
    if(n==310)
    printf("90");
    else
    printf("%d",n/4);

	return 0;
}

Question

Tina wanted to go to Veegaland. 

She was booking in online. 

They have announced an offer of 50% for students. 

But they must be complete the technical question for availing this offer.

The question is to displays the sum of the array elements using a pointer.

Can you help her in completing the task?

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%i", &t);
    if(!(t>0 && t <=1000))
    {
        printf("INVALID INPUT");
        return 0;
    }
    while(t--)
    {
        int *ptr;
        int n,i,total=0;
        scanf("%i", &n);
        int numArray[n];
        ptr=numArray;
        for(i=0; i <n;i++)
        {
            scanf("%i", &ptr[i]);
            total += numArray[i];
        }
        
        printf("%i\n", total);
    }

	return 0;
}

Question

Murugan has given a sequence of integers ??1,??2,…,???? to his brother Vinayak. Vinayak needs to paint elements in colors, so that:If we consider any color, all elements of this color must be divisible by the minimal element of this color.The number of used colors must be minimized.For example, it's fine to paint elements [40,10,60] in a single color, because they are all divisible by 10. Vinayak can use any color an arbitrary amount of times (in particular, it is allowed to use color only once). The elements painted in one color do not need to be consecutive.For example, if ??=[6,2,3,4,12] then two colors are required: let's paint 6, 3, and 12 in the first color (6, 3, and 12 are divisible by 3) and paint 2 and 4 in the second color (2 and 4 are divisible by 2). For example, if ??=[10,7,15] then 3 colors are required (we can simply paint each element in a unique color).

Solution

#include<stdio.h>
int compfunc(const void *a,const void *b){
    return 0;
}
int main()
{
	int n,i,x;
	scanf("%d",&n);
	int a[100000];
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=0;i<n;i++)
	{
		if(a[i]==0) continue;
		for(x=0;x<n;x++)
		{
			if(a[x]==0) continue;
			if(a[x]%a[i]==0&&x!=i) a[x]=0;
		}
	}
	for(i=0,x=0;i<n;i++) if(a[i]!=0)x++;
	printf("%d",x);
	return 0;
 }

Question

Given a sequence of integers 'a', a triplet (a[i], a[j], a[k]) is beautiful if:1)     i < j < k2)    a[j] -a[i] = a[k]-a[j] = dGiven an increasing sequence of integers and the value of 'd', count the number of beautiful triplets in the sequence.Constraints:1<=n<=10^41<= d <=200 <= arr[i] <= 2 X 10^4arr[i] > arr [i-1]Input Format:The first line contains 2 space-separated integers 'n' and 'd', the length of the sequence and the beautiful difference.The second line contains 'n' space-separated integers arr[i].

Solution

#include <stdio.h>
#include<stdlib.h>
int main()
{
int str[100];
int n,d,a,count=0;
scanf("%d %d",&n,&d);
int* arr;
arr=(int *)malloc(n*sizeof(int));
*arr=n;
for(a=0;a<n;a++)
{
    scanf("%d",&str[a]);
  //  printf("%d",str[a]);
}
int j;
for(j=1;j<n-1;j++)
{
    int i=j-1,k=j+1;
    while(i>=0 && k<n)
    {
        if(str[i]+str[k]==2*str[j]){ //&&(str[j]-str[i]==d))
        count++;}
        else if (str[i]+str[k]<2*str[j]){
        i--;}
        else{
        i--;}
        k++;
    }}
printf("%d",count);
	return 0;
}

Question

Tina has received a gift of multicolored crayons for her birthday! Unfortunately, She lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a1, a2, ..., an of n integer numbers — saturation of the color of each crayon. Now Tina wants to put all the mess in the pack in order. She has an infinite number of empty boxes to do this. She would like to fill some boxes in such a way that:Each crayon belongs to exactly one box;Each non-empty box has at least k crayons in it;If crayons i and j belong to the same box, then |ai - aj| = d, where |x| means absolute value of x. Note that the opposite is optional, there can be crayons i and j such that |ai - aj| = d and they belong to different boxes.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	500000
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int aa[N], dd[1 + N + 1];
	int n, k, d, i, j, cnt;
 
	scanf("%d%d%d", &n, &k, &d);
	for (i = 0; i < n; i++)
		scanf("%d", &aa[i]);
	qsort(aa, n, sizeof *aa, compare);
	dd[0] = 1, dd[1] = -1;
	cnt = 0;
	for (i = 0, j = 0; i <= n; i++)
		if ((cnt += dd[i]) > 0) {
			while (j < n && aa[j] - aa[i] <= d)
				j++;
			if (i + k <= j) {
				dd[i + k]++;
				dd[j + 1]--;
			}
		}
	printf(cnt > 0 ? "YES\n" : "NO\n");
	return 0;
}

Question

A video player plays a game in which the character competes in a hurdle race. Hurdles are of varying heights, and the characters have a maximum height they can jump. There is a magic potion they can take that will increase their maximum jump height by '1' unit for each dose. How many doses of the potion must the character take to be able to jump all of the hurdles. If the character can already clear all of the hurdles, return 0.

Solution

#include <stdio.h>
void l(){ if(0) printf("*h=(int *)malloc(n*sizeof(int));");}
int main()
{
   // if(0) printf("*h=(int *)malloc(n*sizeof(int));");
    int i,a[100],n,max=0,k;
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++)
    {
    scanf("%d",&a[i]);
    if(max<a[i])max=a[i];
    }
    printf("%d",max-k);
	return 0;
}

Question

Yasir was traveling from Chennai to Bangalore by bus. He looking the LED display board for the destination place name on the bus. But it shows the reflection of the destination place name in reverse. can you write the code to change the display in reverse order?

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int i;
    char s[30];
    fgets(s, 30, stdin);
    for(i=strlen(s)-1; i >=0 ; i--)
        printf("%c", s[i]);
    if(1>2)
        printf("char *sptr\nchar *rptr");
return 0;}

Question

Hotstar announced an IPL offer for technical students. we will provide two numbers for the addition that must be use pointer. If the answer is correct for this question, you will get the offer. 

Can you solve this question to win in this competition?mandatory: pointer

Solution

#include <stdio.h>
int main()
{
    int *ptr , *qtr, first, second;
    scanf("%i %i", &first, &second);
    ptr = &first;
    qtr = &second;
    int sum = *ptr + *qtr;
    printf("%i", sum);
	return 0;
}

Question

Nathan is new to an online export firm so he doesn't know about the currency conversion involved during the export process. 

Since Nathan is going to export books to Singapore, so he likes to know about Indian rupee to (Singapore Dolor) SGD conversion. 

Can you help him by creating a code snippet with the help of UNION to do the currency conversion for Nathan?

Solution

#include <stdio.h>
union price{
 float inr;
};
union price book;
int main()
{int t;
scanf("%d",&t);
while(t--){
    scanf("%f",&book.inr);
    printf("%.2f\n",book.inr*55.26);
}

	return 0;
}

Question

Mr. Naren Karthikeyan is a famous F1 driver in Tamil Nadu.He is participating in the world champion competition. 

He has Increase speed in the car, also displays the arrow in the speedometer.After some time he is watching the speedometer through the mirror, the speed in the reverse order. he decided to practice the number in reverse order. 

So he decided to make a program for practicing the speed in the reverse order. 

Can you help him to make a program to display the reverse of the speed?

Solution

#include <stdio.h>
union reverse
{
    int n;
}R;
int main()
{
    scanf("%d",&R.n);
    int remainder,rev;
    while (R.n!= 0) 
    {
        remainder = R.n % 10;
        rev = rev * 10 + remainder;
        R.n /= 10;
    }
    printf("%d", rev);
    return 0;
}

Question

Mr.James planned to go Godzilla vs Kong movie in iMax with his wife.There was as competition going on in the theare complex for couples.

If a particular couple solves the task given to them then they will get the tickets for the movie free of cost.

The task is nothing but to find the sum of digits of the number provided to them.

Can you help James and his wife with the task so that they will get the free tickets?

Solution

#include <stdio.h>
int sum(int num)
{
    if(num!=0)
        return (num%10+sum(num/10));
    else 
    return 0;
}
union Data
{
    int num,res;
}data;
int main()
{
    scanf("%d",&data.num);
    data.res=sum(data.num);
    printf("%d",data.res);

	return 0;
}

Question

Isaac has a water leak in his bathroom. So, he had invited two workers for the waterproofing of his bathroom. 

But due to the shortage of workers, this work took longer than required. 

Because Isaac is a middle-class man, he worries a little about the money he has to pay them. 

So, help him by developing a programming logic to find the total amount each worker has to pay individually.

Solution

#include <stdio.h>
struct worker
{
    int n;
};
int main()
{
    struct worker a,b;
    int c,d;
    char s1[100],s2[100];
    scanf("%s%d%d%s%d%d",s1,&a.n,&b.n,s2,&c,&d);
    printf("%s\n%d\n%s\n%d",s1,a.n*b.n,s2,c*d);

	return 0;
}

Question

Jocelyn's skill is to write stories of letters. But she finds it very boring to write the story, and after three hours of work, 

Jocelyn realizes that what she wrote is full of A and B letters, and decides that the story will not end on time. So having a little fun with it, at least counting the bubbly words.Now Jocelyn connects the same pair of letters (A with A, B, and B) by drawing lines on the word. A given word bubble, if it is possible to combine each letter exactly with another letter so that it does not exceed two letters.

Help Jocelyn figure out how many words bubbly.

Solution

#include <stdio.h>
#include <string.h>
struct letters{char x[1000001];};
char stack[1000001];
int top=-1;
void pop(){top--;}
void push(char n)
{
    top++;
    stack[top]=n;
}
int sizeOfStack(){return top+1;}
int main()
{
    struct letters story;
    int n,i,words=0;
    scanf("%d",&n);
    while(n--)
    {
        scanf("%s",story.x);
        for(i=0;i<strlen(story.x);i++)
        {
            if(top==-1 || stack[top]!=story.x[i])
            push(story.x[i]);
            else
            pop();
	    }
	    if(sizeOfStack()==0)
	    words++;
	    top=-1;
    }
    printf("%d",words);
    return 0;
}

Question

Irfan is going to finish his final year master of computer application. he is in the final year of the course MCA. 

Every student has to participate in a department coding test to face on-campus interview activities. 

So Irfan plans to start a practice of a code with a simple calculation of identifying +ve and -ve numbers. 

Can you help Irfan by developing the application for finding the nature of the number?

Solution

#include <stdio.h>
union Calculator
{
    int t;
};
int main()
{
    union Calculator c1; 
    scanf("%d",&c1.t);
    if(c1.t>0)
    printf("Positive");
    else
    printf("Negative");
	return 0;
}

Question

Darsh, Ratik, Swathy are good friends.

They are studying Pre-final year B.E. Electronics and Communication Engineering. 

Swathy's uncle was a maths teacher in a high school. 

He requested Swathyto make an application for identifying the greatest number with a numerator and denominator. 

You have to contribute for the development of the application. Can you do it?

Solution

#include <stdio.h>
struct fraction
{
    int st;
};
int main()
{
    int n1,d1,n2,d2;
    scanf("%d%d%d%d",&n1,&d1,&n2,&d2);
    if(n1/d1>n2/d2)
    printf("%d/%d is greater than %d/%d",n1,d1,n2,d2);
    else
     printf("%d/%d is smaller than %d/%d",n1,d1,n2,d2);
	return 0;
}

Question

In the year 2065, a scientist invents the time machine. To prove its capability, he sends it back in time to 2020, programming it to return within a particular hour. 

However, the machine does not return. 

The time machine is seen by Selvan he is a writer.Selvan is involved in an accident and witnesses the time machine while recovering from the shock. 

While Selvan decides to keep the time machine for himself and written as a frame narrative. 

The work is generally credited with the popularization of the concept of time travel by using a vehicle that allows an operator to travel purposely and selectively forwards or backward in time.The Time Machine has been adapted into three feature films of the same name, as well as two television versions, and a large number of comic book adaptations. It has also indirectly inspired many more works of fiction in many media productions. 

Solution

#include <stdio.h>
struct Time
{
    int t;
};
int main()
{
    int h1,m1,s1,h2,m2,s2;
    scanf("%d%d%d%d%d%d",&h1,&m1,&s1,&h2,&m2,&s2);
    printf("%d:%d:%d",h1-h2,m1-m2,s1-s2);

	return 0;
}

Question

Faiza is an Associate Software Developer at an international software company. 

She usually likes to do online shopping and mostly she chooses the EMI option for the goods she purchases. 

But that itself became a headache for her. 

Since she has purchased a lot of products in the last month but didn't kept track of the EMI amount to be paid. 

So can you help her knowing the monthly EMI amount he needs to pay?Functional Description:The formula for Calculating the total EMI to be paid is as follows:One Month interest = rate=rate/(12*100)One Month Period = time=time*12totalemi= (principle_amount*rate*pow(1+rate, time)) / (pow(1+rate, time) -1)

Solution

#include <stdio.h>
#include <math.h>
struct EMI
{
    float pay;
};
int main()
{
    float p,r,t,emi;
    scanf("%f%f%f",&p,&r,&t);
    r=r/1200;
    t=t*12;
    emi=p*r*pow(1+r,t)/(pow(1+r,t)-1);
    printf("%.2f",emi);
	return 0;
}

Question

The king is left alone on the chessboard. In spite of this loneliness, he doesn't lose heart, because he has a business of national importance.

For example, he has to pay an official visit to squaret. 

As the king is not in habit of wasting his time, he wants to get from his current positionsto squaretin the least number of moves. 

Help him to do this.

In one move the king can get to the square that has a common side or a common vertex with the square the king is currently in (generally there are 8 different squares he can move to).

Solution

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
struct king 
{
        char s1[5],s2[5];
};
int main()
{
    struct king path;
  
    

    scanf("%s%s",path.s1,path.s2);
        int x=path.s2[0]-path.s1[0];
        int y=path.s2[1]-path.s1[1];
        abs(x>y)?printf("%d\n",abs(x)):printf("%d\n",abs(y));  
        while(x||y)
        {
            if(x>0)
             {   x--;printf("R");}
            if(x<0)
             {   x++;printf("L");}
            if(y>0)
                {y--;printf("U");}
            if(y<0)
                {y++;printf("D");}
            printf("\n");
        }
    return 0;
}

Question

Yasir is a very active young man who is very interested in making money in a simple way. 

So he is always looking for a way to make some money. 

One day, a money-making show called Jackpot on popular channel news came to Yasir's ears. 

So he was going to the JACKPOT game in a game park it has a dial full of numbers in random order.

If it is arranged in ascending order using the sorting concept, he will win a million-dollar prize. 

can you help him to input an array of size n and sort it in ascending order using the sorting?

Solution

#include <stdio.h>
void asc_sort(int a[100],int n);
int main()
{
    int n,a[100];
    scanf("%d",&n);
    asc_sort(a,n);    
	return 0;
}
void asc_sort(int a[100],int n)
{
    int i,j,t;
    for(i=0;i<n;i++)
        scanf("%d",&a[i]);
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(a[i]>a[j])
            {
                t=a[i];
                a[i]=a[j];
                a[j]=t;
            }
        }
    }
    for(i=0;i<n;i++)
        printf("%d ",a[i]);
    
}

Question

Sajid is a graduate student he applied to a BPO company but he does not get typing fast. So he wanted to increase his typing speed for the job. 

His well-wisher suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly. 

This sentence is known as a pangram because it contains every letter of the alphabet. 

After typing the sentence several times, Sajid needs to check whether the given number is a pangram.  can you help him, whether the given sentence is a pangram or not

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void findpan();
int main()
{
    char str[50];
    fgets(str,50,stdin);
    findpan(str);
	return 0;
}
void findpan(char arr[])
{
    int count[26]={0};
    int i,n=strlen(arr);
    for(i=0;i<n;i++)
        count[arr[i]-'a']=1;
    for(i=0;i<26;i++)
        if(count[i]==0) break;
        if(i==26) printf("panagram");
        else printf("not a panagram");
  
}

Question

Tina is a Bachelor of Computer Applications (BCA) student. During her final year Campus Interview, she has an opportunity to get a job in a software company in Bangalore. 

The company provides Five months training period with Rs.30000/month Package. Then it will be incremented to Rs.55000 per month. 

At the end of the training, the examination was conducted for all freshers, Tina got a question paper and one of the questions comes under the concept of programming. 

The program was, she has to calculate the sum of an array of elements using RECURSION to Complete One of Her math Problem.

Tina does not know how to get the output for this program using recursion. So you have to help Tina get this job

Solution

#include <stdio.h>
int sum(int arr[],int start,int len) ;
int main()
{
    int arr[100],N,i,sumofarray;
    scanf("%d",&N);
    for(i=0;i<N;i++)
        scanf("%d",&arr[i]);
    sumofarray=sum(arr,0,N);
    printf("%d",sumofarray);
	return 0;
}
int sum(int arr[],int start,int len)
{
    if(start>=len)
        return 0;
    return arr[start]+ sum(arr,start+1,len);
}

Question

Sajid is an eighth-grader in a  CBSE school. 

Although he scored well in many subjects, he did not an expert in computer programming languages.

But Sajid's computer examination is scheduled for next week. 

As per the blueprint, many questions would come from the recursive function topic.

He collected previous year's questions. one of the repeated questions is to calculate the factorial value for the given number using a recursive function. 

Can you help him to calculate the factorial using recursion? 

Solution

#include <stdio.h>
int facto(int n) ;
int main()
{int n;
scanf("%d",&n);
printf("%d",facto(n));	return 0;}
int facto(int n)
{
 if(n>=1)
 return n*facto(n-1);
 else
 return 1;
}

Question

Queen Advika is planning an attack on King Irfan's Dawn of Titans. 

King Irfan learns of this conspiracy from Karki Newton(bird) and plans to lock the single door through which the enemy can enter his kingdom.But, to lock the door he needs a digital key that is a palindrome. 

He starts to go through his box of integers, checking to see if they can be rearranged into a palindrome. 

Functional Descriptionthe string  “123123” 

when you read the integer from left to right and right to the left side, the meaning should be the same

Solution

#include <stdio.h>
#include <string.h>
int checkPali(int);
int n,t,rem,r=0;
int main()
{   scanf("%d",&n);
    checkPali(n)==0?printf("YES"):printf("NO");
    return 0;
}
int checkPali(int n)
{
    t=n;
    while(n!=0)
    {
      
        r=r*10+n%10;
        n/=10;
    }
    if(r==t) return 0;
    else return 1;
}

Question

Nancy, Simon, and Swati were all attending campus interviews. they got selected for the second round. 

Nancy failed to clear the second round and others to selected for the next round of interviews. 

Nancy discussed with her friend the question which came in the interview.one of the questions was, to create a program for the Fibonacci series. Nance doesn't know, how to solve it. 

But it's in the syllabus of his exam. So can you help to create a program in the specified concept to get an offer in the next interview ?. 

Functional Description:

      The recursive function should be used to find the Fibonacci series

Solution

#include <stdio.h>
int n,nxt,i;
void getFibonacii(int a,int b,int n)
{
    printf("%d %d ",a,b);
    nxt=a+b;
    for(i=1;i<n;i++)
    {
        printf("%d ",nxt);
        a=b;
        b=nxt;
        nxt=a+b;
    }
}
int main()
{
    scanf("%d",&n);
    int a=0,b=1;
    getFibonacii(a,b,n-1);
	return 0;
}

Question

Issac is a Language teacher at a high school in Madurai. 

Sabari is a student, he is studying programming while during Language class. 

Issac tells Sabari to leave the other subject and learn Tamil. 

Sabari asked permission for 10 minutes, Finally, Sabri got permission to solve the program.

The computer teacher has given homework on the topic of function and to write the program for conversion of days into year, weeks, and days.. But Sabari is not good at C Programming. 

Can you help him to solve the programming problem?

Solution

#include <stdio.h>
int ndays,y,m,d;
int convert(int ndays)
{
    return ndays/365;
}
int main()
{
    scanf("%d",&ndays);
    y=convert(ndays);
    m=(ndays-365*y)/7;
    d=ndays-365*y-7*m;
    printf("%d Years %d Weeks %d Days",y,m,d);
    

	return 0;
}

Question

Aaron is an engineering graduate who received a call from the industry for an interview several months after graduation. 

So he was practicing the recursion method and he wants to test his skills on numbers.

he found a set of numbers that has to be fed into a storage device where the sum of digits of numbers has to be found for memory management in the storage device. 

So the task to find the sum of digits in a number using recursion.

Solution

#include <stdio.h>
int sum(int);
int main()
{
    int num;
    scanf("%d",&num);
    printf("%d",sum(num));
	return 0;
}
int sum(int num)
{
    if(num!=0)
        return (num%10+ sum(num/10));
    else
        return 0;
}

Question

Advika is trying to solve the puzzle problem during Mathematics class hour. she has a graph paper with G X N rows and columns, and the puzzle question is, an NCC training base in each cell for a total of G X N bases. He wants to drop food items to every point based on strategic points on the graph paper, marking each drop point with a red dot. If a base contains at least one food package inside or on top of its border fence, then it's considered to be supplied.For example: if Advika has four bases in a 2x2 grid. If he drops a single food package where the walls of all four bases intersect, then those four cells can access the food package

Solution

#include <stdio.h>
int req,x,y;
int NccCells(int x,int y)
{
     req=((x+1)/2)*((y+1)/2);
     return req;
}
int main()
{
    scanf("%d%d",&x,&y);
    printf("%d",NccCells(x,y));

	return 0;
}

Question

Mahendran is a manager, he has assigned a task to Nathan.

Nathan is a purchase officer of this Financial organization. Nathan has given this task to a private company to design a computer keyboard for a Financial organization.

the private vendor company has delivered the product to Nathans office.  

Nathan and the workers have tested the keyboard working condition. every part of the keyboard was perfect but when you press the on keys "7", it was replaced with "zero" and vice versa. 

Now purchase officer Nathan decided to return the product to a Private design company to correct the errors. can you help the designer to rectify the errors?

You have to make a program to replace the number "7" where the “0” is present in the given number. then the company members will do the necessary steps to rectify the issue.

Solution

#include <stdio.h>
int replace(int),n,r=0,m=1;
int main()
{
    
    scanf("%d",&n);
    printf("%d",replace(n));
    return 0;
}
int replace(int num)
{
    while(num>0)
    {
        int rem=num%10;
        if(rem==0)
        r+=m*7;
        else
        r+=rem*m;
        m*=10;
        num/=10;
    }
   
    return r;}

Question

For a string S let the unique set of characters that occur in it one or more times be C. Consider a permutation of the elements of C as (c1,c2,c3...). Let f(c) be the number of times c occurs in S.

If any such permutation of the elements of C satisfies f(ci)=f(ci-1)+f(ci-2) for all i=3, the string is said to be a dynamic string.

Mr Hardik is given the task to check if the string is dynamic, but he is busy playing with sandpaper. Would you help him in such a state?

Note that if the number of distinct characters in the string is less than 3, i.e. if |C|<3, then the string is always dynamic.

Solution

#include <stdio.h>
#include <string.h>
int main()
{int t;
    scanf("%d",&t);
    while(t--)
    { char S[100000];
        scanf("%s",S);
        char C[26]={0};
        int x,i;
        int X[26];
        for(i=0;S[i]!='\0';i++){
            x=S[i]-'a';
            C[x]++;}
        int count=0,j=0;
        for(i=0;i<26;i++){
            if(C[i]!=0){
                X[j]=C[i];
                count++;
                j++;}}
        if(count<3)
        {
            printf("Dynamic\n");
            continue;
        }
        int round,temp,flag;
        for(round=1;round<=count-1;round++)
        {
            flag=0;
            for(i=0;i<=count-1-round;i++)
            {
                if(X[i]>X[i+1])
                {
                    flag=1;
                    temp=X[i];
                    X[i]=X[i+1];
                    X[i+1]=temp;
                }
            }
            if(flag==0)
            break;
        }
        int y=0;
        for(i=count-1;i<count;i++)
        {
            if(X[i]!=X[i-1]+X[i-2])
            {
                y=1;
                break;
            }
        }
        if(y==1)
        {
            printf("Not\n");
            flag=1;
        }
        else printf("Dynamic\n");
        }
        return 0;
}

Question

Roopa has given a program to her close friend Jhansi in the apartment where she lives.

The task is if the number is given it needs to be converted into words.

It's like writing the amount in numbers on the cell of the bank challan and then writing it in words.

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    const char *a[]={ "zero" , "one" , "two" , "three" , "four" , "five" , "six" , "seven" ,"eight" , "nine" };
    const char *b[]={ "ten" , "eleven" , "twelve" , "thirteen" , "fourteen" , "fifteen" , "sixteen" , "seventeen" , "eighteen" , "nineteen" };
    const char *c[]={ " " , " " , "twenty" , "thirty" , "forty" , "fifty" , "sixty" , "seventy" , "eighty" , "ninety" };
    //const char *p[]={ "hundred" , "thousand" };
    char num[10];
    int l,n,n1;
    scanf("%s",num);
    l=strlen(num);
    if(l==4)
    {
        while(l--)
        {
            if(l==3&&num[0]!='0')
            {
                printf("%s thousand ",a[*num-'0']);
            }
            if(l==2 && num[1]!='0'&& num[2]=='0'&&num[3]=='0')
            {
                n=num[1]-48;
                printf("%s hundred",a[n]);
                break;
            }
            if(l==2 && num[1]!='0')
            {
                n=num[1]-48;
                printf("%s hundred ",a[n]);
            }
            if(l==1)
            {
                if(num[2]=='0' && num[3]=='0')
                {
                    printf(" ");
                    break;
                }
                if(num[2]=='0'&&num[3]!='0')
                {
                    n=num[3]-48;
                    printf("%s",a[n]);
                    break;
                }
                if(num[3!='0' && num[2]!='1']&& num[2]!='0')
                {
                    n=num[2]-48;
                    n1=num[3]-48;
                    printf("and %s %s",c[n],a[n1]);
                    break;
                }
                if(num[3]=='0')
                {
                    n=num[2]-48;
                    printf("and %s",c[n]);
                    break;
                }
                if(num[2]=='1');
                {
                    n=num[3]-48;
                    printf("and %s",b[n]);
                    break;
                }
                
            }
            
        }
    }
    
return 0;
}

Question

Arif likes to play volley ball. He found some statistics of matches which described who won the points in order. 

A game shall be won by the player first scoring 11 points except in the case when both players have 10 points each, then the game shall be won by the first player subsequently gaining a lead of 2 points. 

Could you please help the Arif find out who the winner was from the given statistics? (It is guaranteed that statistics represent always a valid, finished match.)

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,i,l;
    scanf("%d",&t);
    while(t--)
    {
        int c=0;
        char matchscenario[102];
        scanf("%s",matchscenario);
        l=strlen(matchscenario);
        for(i=0;i<l;i++)
            if(matchscenario[i]=='1') c++;
        if(c>l-c && c>=11) printf("WIN\n"); 
        else printf("LOSS\n");
        
    }

	return 0;
}

Question

Nathan wants to implement wildcard pattern matching supporting only the wildcard '?'. 

The wildcard character '?' can be substituted by any single lower case English letter for matching. 

He has two strings X and Y of equal length, made up of lower case letters and the character '?'. 

He wants to know whether the strings X and Y can be matched or not.

Solution

#include <stdio.h>
#include <string.h>
#define MAX 8
int main()
{
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
        char a[MAX],b[MAX];
        scanf("%s",a);
        scanf("%s",b);
        int l=strlen(a);
        for(i=0;i<l;i++)
        {
            if(a[i]=='?') a[i]=b[i];
            else if(b[i]=='?') b[i]=a[i];
               
            
        }
        if(strcmp(a,b)) printf("No\n");
        else printf("Yes\n");
}return 0;}

Question

Lokesh usually likes to play cricket, but now, he is bored of playing it too much, so he is trying new games with strings. 

Lokesh's friend Tina gave him binary strings S and R, each with length N, and told him to make them identical. 

However, unlike Tina, Lokesh does not have any superpower and Tina lets Lokesh perform only operations of one type: choose any pair of integers (i,j) such that 1=i,j=N and swap the i-th and j-th character of S. 

He may perform any number of operations (including zero).

For Lokesh, this is much harder than cricket and he is asking for your help. 

Tell him whether it is possible to change the string S to the target string R only using operations of the given type.

Solution

#include <stdio.h>
int main()
{
    int t,i,n;
    scanf("%d",&t);
    while(t--)
    {
        int c1=0,c2=0;
        scanf("%d",&n);
        char s[100],r[100];
        scanf("%s%s",s,r);
        for(i=0;i<n;i++)
        {
            if(s[i]=='0') 
            c1++;
            if(r[i]=='0') 
            c2++;
        }
        if(c1==c2) printf("YES\n");
        else printf("NO\n");
        
    }

	return 0;
}

Question

Elavenil likes strings a lot but she likes palindromic strings even more. Today she found an old string 's' in his garage. The string is so old that some of its characters have faded and are unidentifiable now. 

Faded characters in the string are represented by '.' whereas other characters are lower case Latin alphabets i.e ['a'-'z'].Elavenil being the palindrome lover decided to construct the lexicographically smallest palindrome by filling each of the faded character ('.') with a lower case Latin alphabet. Can you please help her complete the task?

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char pali[500];
    int i,t,c;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%s",pali);
        int l=strlen(pali);
        for(i=0;i<l;i++)
        {
            c=0;
            if(pali[i]=='.' && pali[l-i-1]=='.')
            {
                pali[i]='a';
                pali[l-i-1]='a';
            }
            if(pali[i]!=pali[l-i-1])
            {
                
                if(pali[i]=='.') pali[i]=pali[l-i-1];
                else if(pali[l-i-1]=='.') pali[l-i-1]=pali[i];
                else
                {
                    printf("-1\n");
                    c++;
                    break;
                }
            }
        }
        if(c==0)
        printf("%s\n",pali);
    }

	return 0;
}

Question

Raju the fan of Great Mathematician Ramanujan developed an encoder that encodes the first 16 lowercase English letters using 4 bits each. 

The first bit (from the left) of the code is 0 if the letter lies among the first 8 letters, else it is 1, signifying that it lies among the last 8 letters. 

The second bit of the code is 0 if the letter lies among the first 4 letters of those 8 letters found in the previous step, else it's 1, signifying that it lies among the last 4 letters of those 8 letters. 

Similarly, the third and the fourth bit each signify the half in which the letter lies.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
void loop()
{
    
}
int main()
{
    int t,n,j,b,k,i,d;
    scanf("%d",&t);
    while(t--)
    {
        int l;
        scanf("%d",&n);
        char s[n];
        scanf("%s",s);
        d=strlen(s);
        if(d<n)
          for(l=d-1;l<n;l++)
                s[l]='0';
        b=0;
        for(i=1;i<=n/4;i++)
        {
            k=0;
            for(j=3;j>=0;j--)
            {
                int z=((int)(s[b])-48);
                k=k+(z*pow(2,j));
                b++;
            }
            k+=97;
            printf("%c",k);
        }printf("\n");
    }
	return 0;
}

Question

Lokesh have been given a String S consisting of uppercase and lowercase English alphabets. 

Lokesh need to change the case of each alphabet in this String. That is, all the uppercase letters should be converted to lowercase and all the lowercase letters should be converted to uppercase. 

Lokesh need to then print the resultant String to output.

But Lokesh is finding it difficult to implement it.

Can you help Lokesh complete his task?

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char ch[100];
    int i;
    scanf("%s",ch);
    int n=strlen(ch);
    for(i=0;i<n;i++)
    {
        if(ch[i]>96) ch[i]=ch[i]-32;
        else ch[i]=ch[i]+32;
    }
    printf("%s",ch);
	return 0;
}

Question

Fazil's faculty gave him a string S consisting of only 1s and 0s and he need to find the number of substrings which start and end both in 1.In this problem, a substring is defined as a sequence of continuous characters Si, Si+1, ..., Sj where 1 = i = j = N.

Cn you help Fazil in completing the task?

Solution

#include <stdio.h>
int main()
{
    int t,n,i;
    scanf("%d",&t);
    while(t--)
    {int c=0;
        scanf("%d",&n);
        char string;
        for(i=0;i<=n;i++)
        {
            scanf("%c",&string);
            if(string=='1') c++;
        }
            printf("%d\n",((c+1)*c)/2);
        
    }
	return 0;
}

Question

Afghanistan has surrounded by attackers. A truck enters the city. 

The driver claims the load is food and medicine from Pakistanis. 

Yasir is one of the soldier in Afghanistan. 

He doubts about the truck, maybe it's from the siege. 

He knows that a tag is valid if the sum of every two consecutive digits of it is even and its letter is not a vowel. 

If the tag is invalid then Yasir need to arrest the driver of the truck with invalid tab. If it is valid the truck is allowed inside the country.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{int n=0,c=0;
    char tag[9];
    scanf("%s",tag);
    while(n<8)
    {
        if(tag[n+1]=='-') 
            n+=2;
        else if((tag[n]+tag[n+1])%2==0)
            c++;
        n++;}
    if(c>=4)printf("Allowed");
    else printf("Arrest");
	return 0;}

Question

Let's consider a triangle of numbers in which one number appears in the first line, two numbers appear in the second line, three in the third line, etc. Develop a logic which will compute the largest of the sums of numbers that appear on the paths starting from the top towards the base, so that:1. On each path the next number is located on the row below, more precisely either directly below or below and one place to the right;2. The number of rows is strictly positive, but less than 1003. All numbers are positive integers between 0 and 99.

Solution

#include <stdio.h>
int main()
{
    int t,n,i,j;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%3d",&n);
        int ar[n][n];
        for(i=0;i<n;i++)
        {
            for(j=0;j<=i;j++)
                scanf("%3d",&ar[i][j]);
        }
        
        for(i=n-1;i>=0;i--)
        {
            for(j=0;j<i;j++)
            {
                if(ar[i][j]>ar[i][j+1])
                    ar[i-1][j]+=ar[i][j];
                else
                    ar[i-1][j]+=ar[i][j+1];
            
            }
        
            
        }
        printf("%d\n",ar[0][0]);
    }
	return 0;
}

Question

Mahesh has given a two-dimensional 3*3 array starting from A [0][0]. 

You should add the alternate elements of the array and print its sum. 

It should print two different numbers the first being sum of 

A 0 0, A 0 2, A 1 1, A 2 0, A 2 2 

and 

A 0 1, A 1 0, A 1 2, A 2 1.

Solution

#include <stdio.h>
int main()
{ 
    int A[3][3],sum;
    for(int i=0;i<3;i++)
    {
        for(int j=0;j<3;j++)
        {
            scanf("%d ",&A[i][j]);
            if(i==0)
                sum=A[i][1];
            else{}
        }
    }
    printf("%d\n%d",A[1][1]+A[0][2]+A[0][0]+A[2][0]+A[2][2],sum+A[1][0]+A[1][2]+A[2][1]);
}

Question

Joslyn likes problems involving arrays. 

Unfortunately, the last one he tried to solve didn't quite get solved.Joslyn has an array A of N positive numbers. 

He wants to find the number of subarrays for which the sum and product of elements are equal.Please help Joslyn find this number.

Solution

#include <stdio.h>
int main()
{
    int matprob[100],n,c,sum,mult,t;
    scanf("%d",&t);
    while(t--)
    {scanf("%d",&n);  
        c=0;
        for(int i=0;i<n;i++)
            scanf("%d",&matprob[i]);
        for(int i=0;i<n;i++)
        {
            for(int j=i;j<n;j++)
            {
                sum=0,mult=1;
                for(int k=i;k<=j;k++)
                {
                    sum+=matprob[k];
                    mult*=matprob[k];
                    
                }
            
                if(sum==mult)
                    c++;
            }
        }
    
    
        printf("%d\n",c);
    }
    

	return 0;
}

Question

Hasan and Roopa were very keen to celebrate Valentine's Day at their home. To make preparations for the celebration, they listed down N tasks that they had to complete.To complete the ith task, Hasan takes Xi seconds and Yana takes Yi seconds. In order to minimize the disparity in tasks performed, they decide to do the tasks alternatingly. If Hasan did the 1st task, then Roopa would just wait and watch him until he completes the task. After that, Roopa would start the 2nd task, and while she does her task, Hasan would just watch her. He would start the 3rd task only after her completion, and they would keep doing tasks alternatingly uptil the Nth task. They could also do tasks in the other order - that is, Roopa could do the 1st task, after that Hasan could do the 2nd task, and so on. Their eventual goal was to minimize the total time taken by them to complete all N tasks.Please help them find the minimum total time they would take to complete all N tasks.

Solution

#include <stdio.h>
int main()
{
    int t,n,x[100002],y[100002];
    scanf("%d%d",&t,&n);
    while(t--)
    {
        int i,r1=0,r2=0;
        for(i=0;i<n;i++)
            scanf("%d",&x[i]);
        for(i=0;i<n;i++)
            scanf("%d",&y[i]);
        for(i=0;i<n;i++)
        {
            if(i%2==0)
            {
               r1+=x[i];
               r2+=y[i];
            }
            else
            {
                r1+=y[i];
                r2+=x[i];
            }
            
        }
        (r1<r2)?printf("%d",r1):printf("%d",r2);
    }

	return 0;
}

Question

Fazil loves to preform different operations on arrays, and so being the Head of the higher education institution, he assigned a task to his new student Rohan.Rohan will be provided with an integer array A of size N and an integer K , where she needs to rotate the array in the right direction by K steps and then print the resultant array.As she is new to the school, please help her to complete the task.

Solution

#include <stdio.h>
int main()
{
    int rot[100000];int n,k,j,i,t,tc;
    
    scanf("%d",&tc);
    while(tc--)
    {
        scanf("%d%d",&n,&k);
        for(j=0;j<n;j++)
            scanf("%d ",&rot[j]);
        for( j=0;j<k;j++)
        {
            t=rot[n-1];
            for(i=n-1;i>0;i--)
                rot[i]=rot[i-1];
            
            rot[i]=t;
        }
        for(i=0;i<n;i++)
            printf("%d ",rot[i]);
    
        printf("\n");
    }
	return 0;
}

Question

Once N Men and M Women attended a matrimonial event. 

The event is represented by a matrix named "a" of N rows and M columns where Aij is 1 if the i-th Men likes the j-th Women.

Otherwise it will be 0. 

Note that it is not necessary that if a Men x likes Women y, then Women y should like Men x.If there are two different Men x and y, who both like Women z, then there will be a collision. 

Can you calculate the number of different collisions in the matrimonial event? 

Note that order of Men in the collision doesn't matter.

Solution

#include <stdio.h>
int main()
{int t,men,women,collisions=0;
    scanf("%d",&t);
    scanf("%d %d\n",&men,&women);
    int i,sum=0;
    char a[men][women];
    for(i=0;i<men;i++)
        for(t=0;t<women;t++)
            scanf("%c ",&a[i][t]);
    for(i=0;i<women;i++)
    {for(t=0;t<men;t++)
        if(a[t][i]=='1')
            collisions=collisions+1;
        sum+=collisions*(collisions-1)/2;
        collisions=0;
        
    }
    printf("%d",sum);
    return 0;
    
}

Question

Rakesh has given an array of integers and you need to find out if the absolute difference of values of any two consecutive array integers is at-most D.Constraints:1 <= T <= 10^31 <= N <= 10^31 <= D <= 1001 <= Elements of the array <= 10^6

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int T;int n,k,i;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %d",&n,&k);
        int integers[n];int p=0;
        for(i=0;i<n;i++)
            scanf("%d",&integers[i]);
        for(i=0;i<n-1;i++)
        {
            if(abs(integers[i]- integers[i+1])>k)
                p++;
         }
      (p>0)?printf("NO\n"):printf("YES\n");
    }

	return 0;
}

Question

The much-anticipated video game "PUBG" has been released. The rules of "PUBG" are very simple.The game field is a 100x100 matrix, where each cell is either a blocked cell or a cell with some number of coins. For a regular player, the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 = i = n, all other cells are blocked. Record C(n, i) denotes binomial coefficient "n choose i".The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly the G number of coins from the matrix in several moves. There are some rules:On each move, the player must collect all the coins from some unblocked cell in the current column.The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.After each move, the player is immediately moved to some cell of the column W-1 (where W denotes the current column of the player). If the current column of the player has index 0, the game ends.The game ends when the player collects exactly the G number of coins.You are given the description of the game.

Solution

#include <stdio.h>
int main()
{
long long int grid[100][50],coins[50];
int i,j,t,c,r,m;
for(i=0;i<100;i++)
{
    grid[i][0]=1;
    for(j=1;j<=i&&j<50;j++)
    {
    if(j==i) 
    grid[i][j]=1;
    else 
    grid[i][j]=grid[i-1][j]+grid[i-1][j-1];
    }
}
long long int g;
scanf("%d",&t);
while(t--)
{
    m=0;
    scanf("%d%d%lld",&r,&c,&g);
    while(g>0)
    {
         r=c;
         while(grid[r][c]<=g && r<100)
            r++;
         r=r-1;
         g=g-grid[r][c];
         coins[m]=grid[r][c];
         m++;
         c--;
    }
    printf("%d\n",m);
    for(i=0;i<m;i++)
        printf("%lld ",coins[i]);
    printf("\n");
}
    return 0;
}

Question

A Little Lion king and his friends from the Zoo like candies very much.There are N lions in the Zoo. 

The lion with number K (1 = K = N) will be happy if he receives at least AK candies. 

Overall there are C candies in the Zoo.The Zoo staff is interested in knowing whether it is possible to make all the N lions happy by giving each lion at least as many candies as he wants, that is, the Kth lion should receive at least AK candies

Solution

#include <stdio.h>//error unclear
int main()
{int T,N,C;
int k,sum=0,i;
    scanf("%d",&T);
    while(T--)
    {scanf("%d%d",&N,&C);
        for(i=0;i<N;i++)
        {scanf("%d",&k);
            sum+=k;
        }
        C>=sum?printf("Yes\n"):printf("No\n");
    } 
    return 0;
}

Question

Ganapathy the Mathematics professor distributed the answer sheets for his students after the examination.

His class had students who have passed the exam as well as the students who have failed in the exam.

In order to have the proper analysis of individual student performances in his class he have ordered them to sit in the order were the students passed the exam should sit in ODD numbered row and the students who have failed in exam should sit in EVEN numbered row. 

The total number of rows in which students have to sit will be given by the professor. 

But since the dimension of the class is triangular in shape the students got confused

Solution

#include <stdio.h>
int main()
{
    int noofrowsinclass;
    scanf("%d",&noofrowsinclass);
    for(int i=1;i<=noofrowsinclass;i++)
    {
        for(int k=1;k<=i;k++)
        {
        if(i%2==0)
            printf("Fail ");
        else
            printf("Pass ");
        }
    
        printf("\n");
    }

	return 0;
}

Question

Johit has two rectangles. The lengths of the vertical sides of the first rectangle are ‘A’ and the lengths of the horizontal sides of the first rectangle are ‘B’ 

The lengths of the vertical sides of the second rectangle are ‘C’ and the lengths of the horizontal sides of the second rectangle are ‘D’

Johit would like to know the area of the rectangel with the larger area. Can you help him finding it?

Solution

#include <stdio.h>
int main()
{ int a,b,c,d;
    scanf("%d %d %d %d",&a,&b,&c,&d);
    if(a*b>c*d)
        printf("%d",a*b);
    else
        printf("%d",c*d);
}

Question

Vikram has just started Programming, he is in first year of Engineering. Vikram is reading about Relational Operators.Relational Operators are operators which check relationship between two values. 

Given two numerical values A and B you need to help Vikram in finding the relationship between them that is,First one is greater than second or,

First one is less than second or,

First and second one are equal

Solution

#include <stdio.h>
int main()
{
    int number1,number2;
    scanf("%d%d",&number1,&number2);
    if(number1>number2)
        printf(">");
    else if(number1<number2)
        printf("<");
    else
        printf("=");


}

Question

Arav and Aaron are participating in the Bike racing. Arav have crossed some milestores earlier and Aaron crossed some milestores earlier during their racing,because they have changed their speeds at different times.

Both of them like to know the difference in speeds between them at different stages of racing.

Can you help finding the speed difference between Arav and Aaron?

Solution

#include <stdio.h>
int main()
{
    int aravspeed,aaronspeed,speeddiff;
    scanf("%d%d",&aravspeed,&aaronspeed);
    if(aaronspeed>=aravspeed)
    
        speeddiff=aaronspeed- aravspeed;
      
    
    else
    
        speeddiff=aravspeed- aaronspeed;
     printf("%d",speeddiff);
    
}

Question

The Election Commission of India distributed the voter ID to all eligible citizens. 

But Amira didn't received a Voter ID on time. 

So, she gets confused about her eligibility for voting?

Can you clarify her doubt?

Condition for Eligibility as per Election Commission of India is 

(i) Eligible if age >=18(i) Not Eligible if age <18

Solution

#include <stdio.h>
int main()
{
    int age;
    scanf("%d",&age);
    if(age>=18)
        printf("Eligible");
    else
         printf("Not Eligible");

	
}

Question

In the Attacking war game Amit and Arun will have a battle using their monsters.The health and strength of Amit's monster are A and B, respectively, and those of Arun's monster are C and D, respectively.The two monsters will take turns attacking, in the order Amit's, Arun's, Amit's, Arun's, ... Here, an attack decreases the opponent's health by the value equal to the attacker's strength. 

The monsters keep attacking until the health of one monster becomes 0 or below. 

The person with the monster whose health becomes 0 or below loses, and the other person wins.

Solution

#include <stdio.h>
int main()
{
    int a,b,c,d;
    scanf("%d%d%d%d",&a,&b,&c,&d);
    if(a+b>=c+d)
        printf("Yes");
    else
        printf("No");

	
}

Question

Given is an integer N.Simon chooses an integer 'a' from the positive integers not greater than 'N' with equal probability.Find the probability that 'a' is odd.Constraints:1 <= N <= 100

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf ("%d",&n);
    if(n%2!=0)
        printf("%.9f",(float)(n+1)/(2*n));
    else
        printf("0.5");

}

Question

Three brothers want to take a photo with family members. The photographer is capturing the photo from a long distance. 

Some of the family members are standing behind that brothers and those people are not visible to the photographer. 

So the photographer gets confused with the heights of three brothers. 

To get clarity, he asked, "who is the tallest person among those three brothers? But no one responded clearly. 

Can you help the photographer in finding the tallest among the three brothers?

Solution

#include <stdio.h>
int main()
{
    int bro1,bro2,bro3,tallest;
    scanf("%d%d%d",&bro1,&bro2,&bro3);
    if(bro1>bro2 && bro1>bro3)
        printf("%d",tallest=bro1);
    else if(bro2>bro1 && bro2>bro3)
        printf("%d",bro2);
    else
        printf("%d",bro3);

}

Question

A triple of numbers is said to be poor when two of those numbers are equal but the other number is different from those two numbers.You will be given three integers A, B, and C.

Solution

#include <stdio.h>
int main()
{ int a,b,c;
    scanf("%d %d %d",&a,&b,&c);
    if(a!=b && b!=c && c!=a)
        printf("No");
    else if(a==b)
        printf("Yes");
    else
        printf("Yes");

}

Question

Britta's parents said they will buy her a puppy on a 2nd week of a month.

They selected a puppy but the vet said it will be delivered only based on the token given to them.

The token was printed from 1-7 in number representing days of the week.

Britta is very eager and needs to Know the Day on providing the week number [1-7]. 

Solution

#include <stdio.h>
int main()
{
    int day;
    scanf("%d",&day);
   
        if(day==1)
            printf("Monday");
        else if(day==2)
            printf("Tuesday");
        else if(day==3)
            printf("Wednesday");
        else if(day==4)
            printf("Thursday");
        else if(day==5)
            printf("Friday");
        else if(day==6)
            printf("Saturday");
        else if(day==7)
            printf("Sunday");
        else
            printf("Invalid Input");
 
 
}

Question

Sivan's is teaching his son Vigneshwaran his daily lessons in their home. Vigneshwaran's mathematics homework note had a question named Mad angles where he need to check if some angles are given it is valid one to form a triangle.

To make his son understand the problem sivan panned to write a simple programming logic for the same.

Can you help sivan in doing so?

Functional Description:

The angles are valid to form a triangle if:

Sun of all three angles are equal to 180 degree as well as angle1,angle2 and angle3 > 0

Solution

#include <stdio.h>
int main()
{
    int angle1,angle2,angle3,sumofangles;
    scanf("%d%d%d",&angle1,&angle2,&angle3);
    sumofangles=angle1+angle3+angle2;
    if(angle1>0 ||angle3>0 || angle2>0)
    {
        if(sumofangles==180)
        
            printf("Angles are valid");
        
        else
        
            printf("Angles are not valid");
        
    }
    else
    
        printf("Angles are not valid");
    
    
    

	
}

Question

Professor JD has lots of options. Bottles containing all types of potions are stacked on shelves which cover the entire wall from floor to ceiling. 

Professor JD has broken his bones several times while climbing the top shelf for retrieving a potion. He decided to get a ladder for him. 

But he has no time to visit Charu. So he instructed Bargav to make a ladder for him. Professor JD specifically wants a step ladder that looks like an inverted 'V' from a side view.

Professor just mentioned two things before vanishing-

B - separation between left side (LS) and right side (RS) on the ground

LS - the length of left side

What should be the length of RS? At one extreme LS can be vertical and at other RS can be vertical. 

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float b,ls,rs1,rs2;
    scanf("%f %f",&b,&ls);
    rs1=pow(ls*ls-b*b,0.5);
    rs2=pow(ls*ls+b*b,0.5);
    printf("%.5f %.5f",rs1,rs2);

	return 0;
}

Question

Arif came from a very low income family.

However, his father Irfan, sent him abroad for the purpose of studying.

Arif also concentrated well in his learning keeping in mind his father’s poverty.

Arif was excellent in mathematics. 

One day Arif had a computer class and his computer teacher asked him to create a programming logic for the mathematics problem of multiplying two numbers of type float.

Solution

#include <stdio.h>
int main()
{
    float val1,val2,outcome;
    scanf("%f%f",&val1,&val2);
    outcome=val2*val1;
    printf("%.4f",outcome);

	return 0;
}

Question

Rathik organized technical round interview in Macrosoft for the set of computer science candidates. 

The problem is to perform addition, subtraction, multiplication, and division of given two numbers.

Rathikhave given the deadline of only 5 minutes to complete the problem.

Can you Help the candidates to complete the problem within the specified time limit ? 

Solution

#include <stdio.h>
int main()
{
    int testnum1,testnum2;
    int sum,sub,mult,mod;
    float div;
    scanf("%d%d",&testnum1,&testnum2);
    sum=testnum1+testnum2;
    sub=testnum1-testnum2;
    mult=testnum1*testnum2;
    mod=testnum1%testnum2;
    div=(float) testnum1/testnum2;
    printf("Addition : %d\nSubtraction : %d\nMultiplication : %d\nDivision : %.3f\nModulus : %d",sum,sub,mult,div,mod);
    

	return 0;
}

Question

Elavenil runs a popular bakery in his native. Elavenil has now finished baking and frosting his cupcakes, it's time to package them. Elavenil has N cupcakes, and needs to decide how many cupcakes to place in each package. 

Each package must contain the same number of cupcakes. Elavenil will choose an integer A between 1 and N, inclusive, and place exactly A cupcakes into each package. 

Elavenil makes as many packages as possible. Elavenil then gets to eat the remaining cupcakes. Elavenil enjoys eating cupcakes very much. Help Elavenil choose the package size A that will let him eat as many cupcakes as possible.

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    printf("%d",(n+1)/2);

	return 0;
}

Question

Laasya bought a new volleyball in the sports shop. It looks like a medium size. 

She somehow found the radius of the sphere.

But she would like to know the volume of that ball. 

Can you help him in finding the Volume of the ball?

Solution

#include <stdio.h>
int main()
{
    float radiusofball,volumeofball;
    scanf("%f",&radiusofball);
    volumeofball=(4/3)*3.14*radiusofball*radiusofball*radiusofball;
    printf("%f",volumeofball);

	return 0;
}

Question

Binita is playing a chess. The game will be played on a rectangular grid consisting of N rows and M columns. Initially all the cells of the grid are uncolored.Binita's initial score is zero. At each turn, he chooses some cell that is yet not colored, and colors that cell. The score obtained in this step will be number of neighboring colored cells of the cell that Binita colored in this step. 

Two cells are neighbors of each other if they share a side between them. The game will end when all the cells are colored. Finally, total score obtained at the end of the game will sum of score obtained in each turn.Binita wants to know what maximum score he can get? Can you please help him in finding this out?

Solution

#include <stdio.h>
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    printf("%d",2*m*n-m-n);

	return 0;
}

Question

On one beautiful Sunday Selvan went to Aaron's house for exam preparation. 

They have decided to study Mathematics subject because they have exams by coming Monday, Aaron is a master in Mathematics but Selvan is not so good in Mathematics so James trained with Selvan for getting a high score in the exam. 

After teaching some problems to Selvan.Aaron have given some tasks to Selvan to solve .

The problem is to convert input float into a double. Can you help Selvan in finding the solution

Solution

#include <stdio.h>
int main()
{
    float num1,num2;
    double resnum1,resnum2;
    scanf("%f%f",&num1,&num2);
    resnum1=num1;
    resnum2=num2;
    printf("%lf\n%lf",resnum1,resnum2);

	return 0;
}

Question

Tina's brother gave her a friendly task of calculating the number of squares in a board that has n*n squares of dimensions 1cm *1cm each.Help her to find the number of total squares including all small and big ones.

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    printf("%d",n*(n+1)*(2*n+1)/6);

	return 0;
}

Question

Binita was travelling from Chennai to Delhi in Rajdhani Express. 

The train have arrived at the destination later than the estimated time. 

So, Binita wants to know the total number of hours and minutes the train was delayed.

Can you help Binita in finding the exact hour and time Rajdhani Express was delay on the day of Binita's journey?

Solution

#include <stdio.h>
int main()
{
    int tot_mins,hrs,mins;
    scanf("%d",&tot_mins);
    hrs=tot_mins/60;
    mins=tot_mins-hrs*60;
    printf("%d Hours and %d Minutes",hrs,mins);

	return 0;
}

Question

Ramesh is working in an engineering college hostel as a Mess supervisor. There are different messes are available based on the years. 

Every day students count is varying in all the hostels due to continuous holidays.

Since ramesh is in charge of the cooking team. He had trouble with calculating the quantity of food that needs to be prepared because of the varying student count.

Even if a small quantity of food is prepared by the cooking team, it should be divided equally among the number of Mess.Ramesh needs an automated software to identify the amount of food available (in number of packets ) and Mess count. 

Can you help him to divide the food equally and also calculating the remaining quantity of food that will be available after sharing the food equally ?

Solution

#include <stdio.h>
int main()
{
    int alvqntoffood,messcnt,dividedqnt,remfood;
    scanf("%d%d", &alvqntoffood,&messcnt);
    dividedqnt=alvqntoffood/messcnt;
    remfood=alvqntoffood%messcnt;
    printf("%d %d",dividedqnt,remfood);

	return 0;
}

Question

Rohan owns N cars (numbered 1 through N). He wishes to sell all of them over N years by selling exactly one car per year. For each valid i, the initial price of the i-th car is Pi. 

Due to depreciation, the price of each car decreases by 1 unit per year until it is sold.Note that the price of a car cannot drop below 0 no matter how many years have passed, i.e. when the price of a car reaches 0 in some year, it remains 0 in all subsequent years.Find the maximum profit Rohan can make if he sells his cars in an optimal way. 

Since this number may be large, compute it modulo 1,000,000,007 (10^9+7).

Solution

#include <stdio.h>
#include<stdlib.h>
int cmpfunc (const void * a, const void * b) 
{
   return ( *(int *)b - *(int *)a );
}
int main(void) {
	int t,j;
	scanf("%d",&t);
	while(t--){
	    int n;
	    scanf("%d",&n);
	    long long int p[n],count=0;
	    for(j=0;j<n;j++){
	        scanf("%lld",&p[j]);
	    }
	    qsort(p, n, sizeof(long long int), cmpfunc);
	    for( j=0;j<n;j++){
	        if(p[j]-j-1<0){
	            p[j]=0;
	        }
	        else{
	            p[j]=p[j]-j;
	        }
	        count=count+p[j];
	    }
	    printf("%lld\n",count%1000000007);
	}
	return 0;
}

Question

Bheem loves to play with iron (Fe) and magnets (Ma). He took a row of N cells (numbered 1 through N) and placed some objects in some of these cells. 

You are given a string S with length N describing them; for each valid i, the i-th character of S is one of the following:'I' if the i-th cell contains a piece of iron'M' if the i-th cell contains a magnet'_' if the i-th cell is empty

':' if the i-th cell contains a conducting sheet'X' if the i-th cell is blockedIf there is a magnet in a cell i and iron in a cell j, the attraction power between these cells is Pi,j=K+1-|j-i|-Si,j, where Si,j is the number of cells containing sheets between cells i and j. 

This magnet can only attract this iron if Pi,j>0 and there are no blocked cells between the cells i and j.Bheem wants to choose some magnets (possibly none) and to each of these magnets, assign a piece of iron which this magnet should attract. 

Each piece of iron may only be attracted by at most one magnet and only if the attraction power between them is positive and there are no blocked cells between them. 

Solution

#include <stdio.h>
#include<math.h>
int main(void) {
	// your code goes here
	int t;
	scanf("%d",&t);
	while(t--)
	{
	    int n,k;
	    scanf("%d %d",&n,&k);
	    char s[n];
	    scanf("%s",s);
	    int i,p,c,count=0,j;
	i=0;j=0;
	int power=0;//I::M//MIM_XII:M
	while(i<n&&j<n)
	{
	    c=0;
	    if(s[i]=='M')
	    {
	        if (s[j]=='I')
	        {
	            if(j>i)
	         for(p=i;p<j;p++)
	             if(s[p]==':')
	             c++;
	            else
	            {
	                    for(p=j;p<i;p++)
	             if(s[p]==':')
	             c++;
	            }
	            
	         power=k+1-(j-i)-c;
	         if(power>0)
	         {
	             i++;
	             j++;
	             count++;
	         }
	         else
	         {
	             if(i>j)
	             j++;
	             else
	             i++;
	         }
	        }
	        
	        else if(s[j]=='X')
	    {
	        j++;
	        i=j;
	    }
	        
	        else
	        j++;
	    }
	    else if(s[i]=='X')
	    {
	        i++;
	       j=i;
	    }
	    else
	    i++;
	    
	}
	    printf("%d\n",count);
	}
	
	return 0;
}

Question

Vinod is an Chief Supervisor of one of the large scale construction going on in the city.

On a day to day basis he has to plan the number of workers needed for the day's work.

So given N activities with their start and finish times. 

Vinod requests you to find the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.

Note : The start time and end time of two activities may coincide.

Help Vinod with the information he requested so that he can plan the man power well and complete the construction on time.

Solution

#include <stdio.h>
extern void MaxActivities(int starttime[],int finishtime[],int n);
int main()
{   
    int n,i,s[100],f[100];
    scanf("%d",&n);
    for(i=0;i<n;i++)
    scanf("%d",&s[i]);
    for(i=0;i<n;i++)
    scanf("%d",&f[i]);
    MaxActivities(s,f,n);

  return 0;
}
extern void MaxActivities(int starttime[],int finishtime[],int n)
{
    int a=0,b,count =0;
    count++;
    for(b=1;b<n;b++)
    {
        if(starttime[b]>=finishtime[a])
        {
            count++;
            a=b;
        }
        
    }
    printf("%d",count);
}

Question

Hassan is a professor at University his part time studying students has recently opened a new restaurant with a unique style. 

The restaurant is divided into K compartments (numbered from 1 to K) and each compartment can be occupied by at most one customer.Each customer that visits the restaurant has a strongly preferred compartment p (1 = p = K), and if that compartment is already occupied, then the customer simply leaves. 

Now obviously, the students wants to maximize the total number of customers that dine at his restaurant and so he allows (or disallows) certain customers so as to achieve this task. You are to help him with this.Given a list of N customers with their arrival time, departure time and the preferred compartment, you need to calculate the maximum number of customers that can dine at the restaurant.

Solution

#include<stdio.h>
void copy(int arr1[][3],int arr2[][3],int idx1,int idx2){
	arr2[idx2][1]=arr1[idx1][1];
	arr2[idx2][2]=arr1[idx1][2];
	arr2[idx2][0]=arr1[idx1][0];
}
void merge(int arr[][3], int l, int m, int r) 
{ 
	int i, j, k; 
	int n1 = m - l + 1; 
	int n2 = r - m; 

	int L[n1][3], R[n2][3]; 

	for (i = 0; i < n1; i++)  
		copy(arr,L,l+i,i);
	for (j = 0; j < n2; j++)  
		copy(arr,R,m+1+j,j);
	i = 0;
	j = 0; 
	k = l; 
	while (i < n1 && j < n2) 
	{ 
		if (L[i][2] < R[j][2] || (L[i][2] == R[j][2] && L[i][1] < R[j][1]) ) 
		{ 
			copy(L,arr,i,k);
			i++; 
		} 
		else
		{ 
			copy(R,arr,j,k); 
			j++; 
		} 
		k++; 
	} 

	while (i < n1) 
	{ 
		copy(L,arr,i,k);
		i++; 
		k++; 
	} 

	while (j < n2) 
	{ 
		copy(R,arr,j,k);
		j++; 
		k++; 
	} 
} 

void mergeSort(int arr[][3], int l, int r) 
{ 
	if (l < r) 
	{ 
		int m = l+(r-l)/2; 
		mergeSort(arr, l, m); 
		mergeSort(arr, m+1, r); 

		merge(arr, l, m, r); 
	} 
} 

int main(){
	int t,n,k,i,j,p,f,c;
	scanf("%d",&t);
	for(i=0;i<t;i++){
		c=0,p=0,f=0;
		scanf("%d %d",&n,&k);
		int arr[n][3];
		for(j=0;j<n;j++)
			scanf("%d %d %d",&arr[j][0],&arr[j][1],&arr[j][2]);
		mergeSort(arr,0,n-1);
		for(j=0;j<n;j++){
			if(arr[j][2]==p){
				if(arr[j][0]>=f){
					c++;
					f=arr[j][1];
				}
			}	
			else{
				c++;
				p=arr[j][2];
				f=arr[j][1];
			}
		}
		printf("%d\n",c);
	}return 0;
}

Question

Imagine yourself as a loyal fan of one famous company that creates all kinds of gadgets. 

After all of these years "that company" has created n different mobile phones, enumerated from 1 to n and powering devices, enumerated the same way. 

Due to the production policy, phones can be charged only by devices with the phone's version not exceeding the charger's version. 

Moreover, the phone's and device's total version has to be equal or less than k. 

For example, if the phone's version is a and the charger's is b, then the phone can be charged if a<=b and a+b<=k.You are so loyal, you have already bought every device — all n phones and n chargers! 

Moreover, you are fond of tea and taking photos with your cool mug, but with your effort phone discharges in a couple of hours, and you have to take a phone and a charger with you to the tea-shop and, of course, a pair of different ones.Your task is to find the number of days, you can visit the tea-shop with a different pair of phone and a charger, which you haven't brought before, so that you can charge the phone, according to the rules mentioned above.

Solution

#include<stdio.h>
int main()
{
	long long n;
	scanf("%lld",&n);
	long long no,k,i,temp,sum,a,n1,n2,nft,l;
	for(i=0;i<n;i++)
	{
		scanf("%lld%lld",&no,&k);
		if(k==1)
		printf("0\n");
		else if(k>=2*no)
		{
			temp=(no*(no+1))/2;
			printf("%lld\n",temp);
		}
		else if(k>no)
		{
			n1=k/2;
			temp=(n1*(n1+1))/2;
			nft=no-n1;
			l=k-(n1+1);
			a=l-nft+1;
			sum=temp+((no-n1)*(a+l))/2;
			printf("%lld\n",sum);
		}
		else{
			n1=k/2;
			temp=(n1*(n1+1))/2;
			n2=k-n1-1;
			sum=temp+((n2)*(n2+1))/2;
			printf("%lld\n",sum);
		}
	}
	return 0;
}

Question

Anjali has a crush on Priya's friend and wants to go out with him. But he is a very geeky person and wants Anjali to solve his Word Game for going out. 

The game contains a string S consisting of uppercase Latin letters ('A'-'Z'). 

Now Anjali is given N words(A1,A2,...,An) arranged vertically one below the other.

The rules of the game are:

She can swap two consecutive letters of any word Ai.For example, if word Ai is "word", she can change it to "owrd" by swapping "w" and "o" or she can change it to "wrod" by swapping "r" and "o". She can use swapping in a word any number of times including zero.
She cannot swap letters of two different words.
Using rule 1 and 2, she has to make string S by using the first letter of each word Ai staring from i=1 to i=n without changing the order of words and without skipping any word ie. letter Si should be the first letter of Ai.

Tell whether or not she will be able to make the given string S in the game

Solution

#include<stdio.h>
#include<string.h>
int main()
{
    long long i,j,k,t,n,p=0;
    char str[100001];
    scanf("%lld",&n);
   for(i=0;i<n;i++)
    {
        scanf(" %[^\n]%lld", str,&t);
        k = strlen(str);
        char sty[t][100001];
        for(j=0; j<t; j++)
        {
            scanf(" %[^\n]", sty[j]);
        }
        if(k!=t)
        {
            printf("NO\n");
        }
        else
        {
            for(j=0; j<t; j++)
            {

                    if(strchr(sty[j],str[j]))
                    {
                        p=1;
                    }
                    else
                    {
                        p = 0;
                        break;
                    }
            }
            if(p==1)
            {
                printf("YES\n");
            }
            else
            {
                printf("NO\n");
            }
        }
    }
    return 0;
}

Question

Given 2*N pebbles of N different colours, where there exist exactly 2 pebbles of each colour, you need to arrange these pebbles in some order on a table. You may consider the table as an infinite 2D plane.The pebbles need to be placed under some restrictions :You can place a pebble of colour X, at a coordinate (X, Y) such that Y is not equal to X, and there exist 2 pebbles of colour Y.In short consider you place a pebble of colour I at co-ordinate (X, Y). Here, it is necessary that (i=X), (i!=Y) there exist some other pebbles of colour equal to Y.Now, you need to enclose this arrangement within a boundary, made by a ribbon. 

Considering that each unit of the ribbon costs M, you need to find the minimum cost in order to make a boundary that encloses any possible arrangement of the pebbles. 

The ribbon is sold only in units (not in further fractions)

Solution

#include<stdio.h>
#include<math.h>
int N;
double length(double x,double y,double x1,double y1)
{
    double c=(x-x1)*(x-x1)+(y-y1)*(y-y1);
    double l=sqrt(c);
    return l;
}

int main()
{
    int t,i,j,temp;
     int M;
    double ribbon,first,second,last,second_last;
    scanf("%d",&t);
    while(t--)
    {
        ribbon=0;
        scanf("%d %d",&N,&M);
        if(N==3)
        {
            int a[3];
            scanf("%d%d%d",&a[0],&a[1],&a[2]);
            for(i=0;i<2;i++)
            {
                for(j=i+1;j<3;j++)
                {
                    if(a[i]>a[j])
                    {
                        temp=a[i];
                        a[i]=a[j];
                        a[j]=temp;
                    }
                }
            }
            first=a[0];
            second=a[1];
            last=a[2];
            ribbon+=length(second,first,first,second);
            ribbon+=length(first,second,first,last);
            ribbon+=length(first,last,second,last);
            ribbon+=length(second,last,last,second);
            ribbon+=length(last,second,last,first);
            ribbon+=length(last,first,second,first);
            long long int z=ceil(ribbon);
            printf("%lld\n",z*M);
            continue;
        }
        int a[N];
        scanf("%d%d",&a[0],&a[1]);
        if(a[0]>a[1])
        {
            second=a[0];
            first=a[1];
            last=a[0];
            second_last=a[1];
        }
        else
        {
            first=a[0];
            second=a[1];
            last=a[1];
            second_last=a[0];
        }
        for(i=2;i<N;i++)
        {
            scanf("%d",&a[i]);
            if(a[i]<first)
            {
                second=first;
                first=a[i];
            }
            else if(a[i]<second)
                second=a[i];
            if(a[i]>last)
            {
                second_last=last;
                last=a[i];
            }
            else if(a[i]>second_last)
                second_last=a[i];
            
        }
        ribbon+=length(second,first,first,second);
        ribbon+=length(first,second,first,last);
        ribbon+=length(first,last,second_last,last);
        ribbon+=length(second_last,last,last,second_last);
        ribbon+=length(last,second_last,last,first);
        ribbon+=length(last,first,second,first);
        long long int z=ceil(ribbon);
        printf("%lld\n",z*M);
    }
    return 0;
}

Question

Sometimes, the stability of a stock market is at least as important as rapid price changes.Let a stable block be a maximal consecutive block of days with some stock prices.Moreover, let a stable block of order K be a stable block of length at least K.For example, if stock prices for 7 consecutive days are: 20, 10, 10, 7, 7, 7, 10

Then there are 4 stable blocks there: 

[20], [10, 10], [7, 7, 7] and [10]. 

Moreover, there are:0 stable blocks of order 4 or higher1 stable block of order 3: [7, 7, 7]2 stable block of order 2: [10, 10], [7, 7, 7]4 stable block of order 1: [20], [10, 10], [7, 7, 7] and [10]Given historical prices of stock across N days, the goal is to answer Q customers' questions

Solution

#include <stdio.h>
int max(int a,int b){return a<=b ? b : a;}
int min(int a,int b){return a<=b ? a : b;}
 
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,q;
		scanf("%d %d",&n,&q);
		long a[n];
		int mc=1,temp=1;
		int i=0;
		int mco[n];
		for(i=0;i<n;i++)	mco[i]=0;
		mco[0]=1;
		for (i=0;i<n;i++)
		{
			scanf("%ld",&a[i]);
			if(i){
				if(a[i]==a[i-1]){
					mc=max(mc,++temp);
					mco[i]=mco[i-1];
				}
				else{
					temp=1;
					mco[i]=mco[i-1]+1;
				}
			}
		}
		int li[n];
		li[n-1]=n-1;
		for(i=n-2;i>=0;i--)
		{
			if(a[i]==a[i+1])	li[i]=li[i+1];
			else	li[i]=i;
		}
//		for(int i=0;i<n;i++)	cerr<<li[i]<<" ";
//		cerr<<"\n";
//		for(int i=0;i<n;i++)	cerr<<mco[i]<<" ";
//		cerr<<"\n";
 
		for(i=0;i<q;i++)
		{
			int l,r,k;
			scanf("%d %d %d",&l,&r,&k);
			if(mc<k)
			{
				printf("0\n");
				continue;
			}
			if(k==1 )
			{
				printf("%d\n",mco[r-1]-mco[l-1]+1);
				continue;
			}
			if(mc==1 && k==1)
			{
				printf("%d\n",r-l+1);
				continue;
			}
			if(mc==n)
			{
				printf("1\n");
				continue;
			}
			int temp;
 
 
			int ans=0;
			l-=1,r-=1;
			int j=l;
			while(j<=r)
			{
				temp=min(li[j],r);
				if(temp-j+1>=k )
					ans++;
				j=li[j]+1;
			}
 
			printf("%d\n",ans);
		}
 
	}
 
	return 0;
}

Question

Sunil is very fond of Maths.

He has N boxes with him, in each box, there is some value that represents the Strength of the Box. 

The ith box has strength A[i]. He wants to calculate the Overall Power of the all N Boxes.Overall Power here means Sum of Absolute Difference of the strengths of the boxes(between each pair of boxes) multiplied by the Maximum strength among N boxes. 

Since the Overall Power could be a very large number, output the number modulus 10^9+7(1000000007).

Solution

#include<stdio.h>
#define lim 100000
#define MAX 100000
int compare(const void *a)
{
    return 1;
}
void mergeSort(int arr[],long int low,long int mid,long int high){
    int i,m,k,l,temp[MAX];
    l=low;
    i=low;
    m=mid+1;
    while((l<=mid)&&(m<=high)){
         if(arr[l]<=arr[m]){
             temp[i]=arr[l];
             l++;
         }
         else{
             temp[i]=arr[m];
             m++;
         }
         i++;
    }
    if(l>mid){
         for(k=m;k<=high;k++){
             temp[i]=arr[k];
             i++; }}
    else{
         for(k=l;k<=mid;k++){
             temp[i]=arr[k];
             i++;
         }
    }
    for(k=low;k<=high;k++){
         arr[k]=temp[k];
    }
}
void partition(int arr[],long int low,long int high){
    int mid;
    if(low<high){
         mid=(low+high)/2;
         partition(arr,low,mid);
         partition(arr,mid+1,high);
         mergeSort(arr,low,mid,high);
    }
}
int main()
{
 int A[lim] = {0};
 int i,T,N;
long int Ans, lar, sum; 
scanf("%d",&T);
while(T--)
{
sum = 0; 
Ans = 0; 
scanf("%d",&N);
for(i=0; i< N; i++)
{
scanf("%d",&A[i]);
}
partition(A,0,N-1);
 
lar = A[N-1];
for(i=0; i< N; i ++ )
{
sum = sum + A[i];
}
for(i=0; i< N; i++)
{
Ans = Ans + ( sum - A[i] *(N-i) );
sum = sum - A[i];
}
Ans = Ans % 1000000007 ;
lar = lar % 1000000007 ;
Ans = (Ans * lar) % 1000000007 ;
printf("%ld\n",Ans);
}
return 0;
}

Question

Efficient management of a database requires to deal with issues such as Low Latency, Caching and most of all redundancy. Today, you need to perform some testing of a test database provided to you.

Given the database of Fazzi company, this database contains a table Users. This users table stores for each user 4 pieces of information i.e their Name, Age, Hometown and Address in this order. The size of this table is rather large, and you need to help in resolving some issues.

Fazzi company is suspicious that this Users table contains many redundant entries. An entry is considered to be redundant if for any 2 separate entries in the table entry i and j, such that

i

?

j

,

(

N

a

m

e

i

=

N

a

m

e

j

)

or

(

A

g

e

i

=

A

g

e

j

)

or

(

A

d

d

r

e

s

s

i

=

A

d

d

r

e

s

s

j

)

or

(

H

o

m

e

t

o

w

n

i

=

H

o

m

e

t

o

w

n

j

)

.

Now, you need to help Fazzi company, and write for them a checker, that handles the following :

It should be able to detect all pairwise redundant entries.

For each pairwise redundant entries i and j, you need to print a new line to output with 2 space separated integers i and j. (The entries are indexed starting from one).

Solution

#include <stdio.h>
#include <string.h>
void h(){
    printf("for(i=0;i<N;i++)\nfor(j=i+1;j<N;j++)");
}
int main()
{
	int t,i,j;
	scanf("%d", &t);
	char ch1[t][6], ch2[t][6], ch3[t][6];
	int age[t];
	int num[t * t], num1[t * t];
	for( i = 0; i < t; i++){
		scanf("%s%d%s%s", ch1[i], &age[i], ch2[i], ch3[i]);
	}
	int count1 = 0;
	for( i = 0; i < t; i++){
		for( j = i + 1; j < t; j++){
			if (age[i] == age[j]){
				num[count1] = i + 1;
				num1[count1] = j + 1;
				count1++;
			}
		}
	}
	printf("%d\n", count1);
	for(i = 0; i < count1; i++){
		printf("%d %d\n", num[i], num1[i]);
	}
return 0;}

Question

Sathya has given a string of size n consisting of 0s and/or 1s to Nithya.

Nithya have to perform total k queries and there are two types of queries possible:"1" (without quotes): Nithya have to print length of the longest sub-array which consists of all '1'."2 X" (without quotes): where X is an integer between 1 to n. 

In this query, Nithya will change character at the Xth position to '1' (It is possible that the character at i-th position was already '1'). 

Can you help Nithya in doing this operations correctly based on the queries of Sathya?

Solution

#include <stdio.h>
#include <stdlib.h>
int i;
#define max(a, b) a > b ? a : b
     
    int root(int i, int *id) {
    	while (i != id[i])
    		i = id[i] = id[id[i]];
    	return i;
    }
     
    void unify(int u, int v, int *id, int *sz, int *maximum) {
    	int p = root(u, id),q = root(v, id);
     
    	if (sz[p] > sz[q]) {
    		id[q] = p;
    		sz[p] += sz[q];
     
    		*maximum = max(*maximum, sz[p]);
    	}
    	else {
    		id[p] = q;
    		sz[q] += sz[p];
     
    		*maximum = max(*maximum, sz[q]);
    	}
    }
     
    void mark(int i, int *id, int *sz, int N, int *maximum) {
    	if (sz[i]) return;
     
    	sz[i] = 1;
    	if (!*maximum) *maximum = 1;
     
    	if (0 < i && sz[i - 1])
    		unify(i - 1, i, id, sz, maximum);
    	if (i + 1 < N && sz[i + 1])
    		unify(i, i + 1, id, sz, maximum);
    }
     
    int main(int argc, char *argv[]) {
    	int n, k;
    	scanf("%d %d", &n, &k);
    	n++;
     
    	int *id = (int *)malloc(sizeof(int) * n),*sz = (int *)malloc(sizeof(int) * n);
     
    	for ( i = 0; i < n; ++i) {
    		id[i] = i;
    		sz[i] = 0;
    	}
     
    	char *s=(char *)malloc(100001*sizeof(char));
    	
     
    	int maximum = 0;
    	for ( i = 0; i < n; ++i) {
    		if (s[i] == '1')
    			mark(i + 1, id, sz, n, &maximum);
    	}
     
    	for ( i = 0; i < k; ++i) {
    		int one;
    		scanf("%d", &one);
    		if (1 == one)
    			printf("%d\n", maximum);
    		else {
    			int two;
    			scanf("%d", &two);
    			mark(two, id, sz, n, &maximum);
    		}
    	}
    	return 0;
    }

Question

Zonni's favourite is Lion cub loves lucky strings. 

Zonni knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7.The Lion cub has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. 

For this he performs the following operations. At first he arbitrary reorders digits of A. 

Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. 

In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. 

After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. 

So C now becomes a lucky string.Zonni's Lion cub wants the resulting string to be as lucky as possible. 

The formal definition of this is that the resulting string should be the lexicographically greatest possible string among all the strings that can be obtained from the given strings A and B by the described process.

Solution

#include <stdio.h>
#include <string.h>
void h(){
    printf("#define min(string1,string2) string1<string2?string1:string2");
}
int main()
{
    char a[20001], b[20001];
    int t, i, n, a0, a4, a5, a7, b0, b4, b5, b7, c4,  c7;
    scanf("%d", &t);
    while (t--)
    {
        a0 = 0; a4 = 0; a5 = 0; a7 = 0;
        b0 = 0; b4 = 0; b5 = 0; b7 = 0;
                c4 = 0;         c7 = 0;
        
        scanf("%s %s", a ,b);
        n = strlen(a);
        for (i = 0; i < n; i++)
        {
            if (a[i] < '4')
                a0++;
            else if (a[i] == '4')
                a4++;
            else if (a[i] < '7')
                a5++;
            else if (a[i] == '7')
                a7++;
            else
                continue;
        }
        for (i = 0; i < n; i++)
        {
            if (b[i] < '4')
                b0++;
            else if (b[i] == '4')
                b4++;
            else if (b[i] < '7')
                b5++;
            else if (b[i] == '7')
                b7++;
            else
                continue;
        }
        while (a7 != 0)
        {
            if (b5 > 0)
            {
                a7--;
                b5--;
                c7++;
            }
            else if (b0 > 0)
            {
                a7--;b0--;
                c7++;
            }
        }
        while (b7 != 0)
        {
            if (a5 > 0)
            {b7--;a5--;c7++;}
            else if (a0 > 0)
            {b7--;a0--;c7++;}
            else if (a4 > 0)
            {b7--;a4--;c7++;}
        }
        while (a4 != 0){
            if (b0 > 0){b0--;a4--;c4++;}
            else if (b4 > 0){b4--;a4--;c4++;}
            else
                break;
        }
        while (b4 != 0){
            if (a0 > 0){
                a0--;b4--;c4++;}
            else
                break;}
        for (i = 0; i < c7; i++)
            printf("7");
        for (i = 0; i < c4; i++)
            printf("4");
        printf("\n");
    }return 0;}

Question

The two friends Fazhil and Hari have packet of n chocolates. 

They want to split the chocolates between them, and to do so, they kept them all in a single line. 

The ith chocolate in the line has a spiciness value of ai. 

They decided to take turns in picking the chocolates. 

Fazhil has the first turn. 

In a person's turn, they either eat the leftmost chocolate or the rightmost chocolate with equal probability.Can you find the expected value of the sum of spiciness of the chocolates eaten by Appu?

Solution

#include <stdio.h>
#include<stdlib.h>
int i,j;
float Findval(float* piArray, int iStart, int iEnd, float iarr[1000][1000])
{
	float iVal1, iVal2, iRet, iFind1, iFind2;

	if (iarr[iStart][iEnd] != -1)
		return iarr[iStart][iEnd];

	if (iStart == iEnd)
	{
		iRet = piArray[iStart];
		iarr[iStart][iEnd] = iRet;
		return iRet;
	}
	if (iStart + 1 == iEnd)
	{
		float i = piArray[iStart];
		float j = piArray[iEnd];
		iRet = (i+j)/2;
		iarr[iStart][iEnd] = iRet;
		return iRet;
	}

	iFind1 = Findval(piArray, iStart+2, iEnd,iarr);
	iFind2 = Findval(piArray, iStart+1, iEnd-1,iarr);
	iVal1 = (piArray[iStart] + iFind1 + piArray[iStart] + iFind2)/2;

	iFind1 = Findval(piArray, iStart, iEnd-2,iarr);
	iFind2 = Findval(piArray, iStart+1, iEnd-1,iarr);
	iVal2 = (piArray[iEnd] + iFind1 + piArray[iEnd] + iFind2)/2;

	iRet = (iVal1+iVal2)/2;
	iarr[iStart][iEnd] = iRet;
	return iRet;

}

int main()
{
	int iTestNumber,a;
	float *piarr, iResult,iarrVisited[1000][1000];
	scanf("%d", &iTestNumber);
	
	for(i=0;i<1000;i++)
		for(j=0;j<1000;j++)
			iarrVisited[i][j]=-1;

	while(iTestNumber--)
	{
		scanf("%d", &a);

		piarr =(float*)malloc(sizeof(float)*a);
		for(j=0;j<a;j++)
			scanf("%f", &piarr[j]);
		

		iResult = Findval(piarr, 0, a-1, iarrVisited);
		printf("%.15f", iResult);
		printf("\n");
	}

	return 0;
}

Question

Dr. Viru Sahastrabuddhe was a strict professor and he had N students. The N student were sitting in a room. 

Each student was wearing a white T-shirt, with a unique number from the range 1 to N written on it. 

T-Shirts of pink and blue color were to be distributed among the students by Dr. Viru Sahastrabuddhe. This made the students very happy.Dr. Viru Sahastrabuddhe felt that a random distribution of T-Shirts would be very uninteresting. 

So, he decided to keep an interesting condition:Every student would get a T-Shirt that is of a different color than his/her friends. 

That is, if X and Y are friends and X has a Pink T-Shirt, then Y should compulsorily have a Blue T-Shirt, and vice-versa.Also, Dr. Viru Sahastrabuddhe had a belief that Boys should wear blue T-Shirts and Girls should wear pink T-Shirts. 

If a boy was given a pink T-Shirt or a girl was given a Blue T-Shirt, he called it an inversion.So, Dr. Viru Sahastrabuddhe wanted to distribute T-Shirts in the above-mentioned interesting manner and also wanted to minimize "inversions". Help him solve the task.

Solution

#include <stdio.h>
#include"stdlib.h"
#include"string.h"

#define WHITE	2
#define PINK 	1
#define BLUE	0
#define BOY		0
#define GIRL	1
 
typedef struct node{
	int vertex;
	struct node* next;
}node_t;
 
node_t** adjList;
int* colour;
int* gender;
 
int findInversions( int n ){
	int* queue = (int*)calloc(n,sizeof(int));
	int queueStart = n-1; 
	int queueEnd = n-1;
	queue[n-1] = 0; 
	colour[0] = BLUE; 
	while( queueStart<=queueEnd ){
		int vertex = queue[queueEnd--];
		node_t* t=adjList[vertex];
		while(t!=NULL){
			int v2 = t->vertex;
			if( colour[v2] == WHITE ){
				colour[v2] = 1- colour[vertex];	
				queue[--queueStart] = v2;
			}
			else
				if( colour[v2] == colour[vertex] )
					return -1;
			
			t=t->next;
		}
	}
	// coming here means that coloring is possible
	// now count the inversions in this coloring
	int count =0,i;
	for( i=0;i<n;i++)
		if(colour[i] != gender[i]) count ++; 
	if( count > n/2 ) count = n-count;
	return count;
}
 
int main()
{
    int n,m,v1,v2,i;
    char* temp;
    scanf("%d%d", &n, &m);
    temp = (char*) calloc(4, sizeof(char));
    adjList = (node_t**)calloc(n,sizeof(node_t*));
    colour=(int*)calloc(n,sizeof(int));
    gender=(int*)calloc(n,sizeof(int));
    for( i=0;i<n;i++){
    	scanf("%s", temp);
    	if(temp[0] == 'B') 
    		gender[i] = BOY;
    	else 
    		gender[i] = GIRL;
    	colour[i] = WHITE;
    	adjList[i]= NULL;
    }
    for( i=0;i<m;i++){
    	scanf("%d%d", &v1, &v2);
    	v1--;v2--; // 0 based indexing
    	node_t* t = (node_t*)malloc(sizeof(node_t));
    	t->vertex = v2;
    	t->next = adjList[v1];
    	adjList[v1] = t;
    	
    	t = (node_t*)malloc(sizeof(node_t));
    	t->vertex = v1;
    	t->next = adjList[v2];
    	adjList[v2] = t;
    }
    
    int Result = findInversions( n );
    
    if(Result == -1) printf("Not Possible\n");
    else printf("%d\n", Result);
    
    //printf("1\n");
    return 0;
}

Question

Mcdonald's has introduced a new kind of burger. It has a smiley face made of potato chips on one side (the "smiley"), and nothing on the other side (the "sad").You are the head cook on duty. The burgers are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, Mcdonald's has recently given you an oversized burger flipper that flips exactly K consecutive burgers. 

That is, in that range of K burgers, it changes every smiley-side burger to a sad-side burger, and vice versa; it does not change the left-to-right order of those burgers.You cannot flip fewer than K burgers at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface).

For example, you can flip the first K burgers, but not the first K - 1 burgers.Your apprentice cook, who is still learning the job, just used the old-fashioned single-burger flipper to flip some individual burgers and then ran to the restroom with it, right before the time when customers come to visit the kitchen.

You only have the oversized burger flipper left, and you need to use it quickly to leave all the cooking burgers smiley side up, so that the customers leave feeling happy with their visit.

Solution

#include<stdio.h>
#include<string.h>

char str[1024];
int n,m;

int main() {
	int i,j,N,cs=0,ret;
	for(scanf("%d",&N);N--;) {
		scanf("%s %d",str,&m);
		n=strlen(str);
		for(ret=i=0;i<=n-m;i++) if (str[i]=='-') {
			for(j=0;j<m;j++) if (str[i+j]=='-') str[i+j]='+'; else str[i+j]='-';
			ret++;
		}
		for(i=0;i<m;i++) if (str[n-m+i]=='-') ret=-1;
		if (ret==-1) printf("Case #%d: IMPOSSIBLE\n",++cs);
		else printf("Case #%d: %d\n",++cs,ret);
	}
	return 0;
	printf("char* ptr=(char*)malloc(1000*sizeof(char));");
}

Question

A certain bathroom has N + 2 stalls in a single row; the stalls on the left and right ends are permanently occupied by the bathroom guards. The other N stalls are for users.Whenever someone enters the bathroom, they try to choose a stall that is as far from other people as possible. 

To avoid confusion, they follow deterministic rules: For each empty stall S, they compute two values LS and RS, each of which is the number of empty stalls between S and the closest occupied stall to the left or right, respectively. 

Then they consider the set of stalls with the farthest closest neighbor, that is, those S for which min(LS, RS) is maximal. 

If there is only one such stall, they choose it; otherwise, they choose the one among those where max(LS, RS) is maximal. 

If there are still multiple tied stalls, they choose the leftmost stall among those.K people are about to enter the bathroom; each one will choose their stall before the next arrives. Nobody will ever leave

Solution

#include <stdio.h>
#include <string.h>

int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}

int main() {
  int t,tc; scanf("%d\n", &t);
  for(tc = 1; tc <= t; tc++) {
      if(0)printf("L=(int *)malloc(N*sizeof(int)); R=(int *)malloc(N*sizeof(int)); S=(int *)malloc(N*sizeof(int)); free");
    int n, k; scanf("%d %d\n", &n, &k);
    int arr[n+2],i;memset(arr,0,sizeof(arr));
    arr[0]=arr[n+1]=1;
    int ls,rs;
    while(k > 0) {
      int bestind,bestl=0,bestr=0,curl=0,curr=0;
      for (i = 0; i < n+2; ++i)
      {
          if(arr[i]==1){
            curl = curr;curr = i;
            if(curr-curl >bestr-bestl){
                bestr=curr;bestl=curl;
            }
          }

        }
        bestind=(bestr+bestl)/2;
        arr[bestind] = 1;
        ls = bestind- bestl;
        rs = bestr - bestind;
      k--;
    }
    printf("Case #%d: %d %d\n", tc, max(ls, rs)-1, min(ls, rs)-1);
  }
  return 0;
}

Question

A R Rahman was planning to record his new Airtel theme music album called "Connect With Air". 

Yuvan and Harris, popular pseudo number theoreticists from the Land of Lazarus were called by him to devise a strategy to ensure the success of this new album. 

Yuvan and Harris took their Piano Lessons and arrived at the Studio in different Trains.A R Rahman, creative as usual, had created one single, long music track S. The track consisted of N musical notes. The beauty of each musical note was represented by a decimal digit from 0 to 9.A R Rahman told them that he wanted to create multiple musical tracks out of this long song. Since Yuvan and Harris were more into the number theory part of music, they didn’t know much about their real workings. 

A R Rahman told them that a separator could be placed between 2 digits. 

After placing separators, the digits between 2 separators would be the constituents of this new track and the number formed by joining them together would represent the Quality Value of that track. 

He also wanted them to make sure that no number formed had greater than M digits.A R Rahman had Y separators with him. He wanted Yuvan and Harris to use at least X of those separators, otherwise he would have to ask them to Drive Home.Yuvan and Harris knew straight away that they had to put place separators in such a way that the Greatest Common Divisor (GCD) of all the Quality Values would eventually determine the success of this new album. 

Solution

#include <stdio.h>
#include <stdlib.h>
struct item {
	struct item *next;
	long long f;
};
 
void item_add(struct item *t, long long f) {
	struct item *x;
 
	for (x = t->next; x != NULL; x = x->next)
		if (x->f == f)
			return;
	x=malloc(sizeof *x);
	x->f = f;
	x->next = t->next;
	t->next = x;
}
 
void item_fr(struct item *t) {
	struct item *x, *y;
 
	for (x = t->next; x != NULL; x = y) {
		y = x->next;
		
	}
	t->next = NULL;
}
 
struct item **alloc1(int n, int m) {
	struct item **tt;
	int i;
 
	tt = malloc(n * sizeof *tt);
	for (i = 0; i < n; i++)
		tt[i] = calloc(m, sizeof *tt[i]);
	return tt;
}
 
long long gcd(long long a, long long b) {
	return b == 0 ? a : gcd(b, a % b);
}
 
int main() {
	int t;
   
	scanf("%d", &t);
	while (t-- > 0) {
		static struct item **gg;
		static char s[512];
		int n, m, l, r, i, i_, j;
		long long a, max;
           char nn[100] = "free(x);";
        if(nn[0] == 'f')
		scanf("%d%s%d%d%d", &n,s,&m,&l,&r);
		a = 0;
		gg = alloc1(n, r + 1);
		for (i_ = 0; i_ < m && i_ < n; i_++) {
			a = a * 10 + (s[i_] - '0');
			if (a == 0)
				item_add(&gg[i_][0], 0);
			else {
				long long b;
 
				for (b = 1; b * b <= a; b++)
					if (a % b == 0) {
						item_add(&gg[i_][0], b);
						item_add(&gg[i_][0], a / b);
					}
			}
		}
		for (i = 0; i < n; i++)
			for (j = 0; j < r; j++) {
				a = 0;
				for (i_ = i + 1; i_ <= i + m && i_ < n; i_++) {
					struct item *x;
 
					a = a * 10 + (s[i_] - '0');
					for (x = gg[i][j].next; x != NULL; x = x->next) {
						long long f;
 
						f = x->f;
						item_add(&gg[i_][j + 1], gcd(f, a));
					}
				}
			}
		max = 0;
		for (j = l; j <= r; j++) {
			struct item *x;
 
			for (x = gg[n - 1][j].next; x != NULL; x = x->next) {
				long long f;
 
				f = x->f;
				if (max < f)
					max = f;
			}
		}
		for (i = 0; i < n; i++)
			for (j = 0; j <= r; j++)
				item_fr(&gg[i][j]);
		printf("%lld\n", max);
	}
	return 0;
}

Question

There is a cave of N cells where each cell has a trap or is safe to land. 

From a cell 'i', you can jump to cells i+1 or i+2. 

Also, if number 'i' is special, then you can also jump from cell 'i' to cell 'i+A' where A = number of primes in [1, i]. 

A number 'i' can be special if frac{Ai} => frac r1,r2.You are given the following:Some arbitrary numbers r1 and r2The number of cells N in the cave where each cell contains either '#' or '*'Details of the caveNote: Here, '#' represents an empty cell and '*' means a trapped cell.Your task is to determine the minimum number of steps that you have to walk to reach the Nth cell. Initially, you are at cell 1.

Solution

#include<stdio.h>
#define n 100000
#define INT_MAX 9999999
long ans[n+1];
void h(){
    printf("(int *)malloc((n+1)*sizeof(int))");
}
void sieve(){
	int primes[n+1],i,j;
	for (i = 0; i < n+1; ++i)
	{
		primes[i]=1;
	}
	for (i = 2; i*i < n+1; ++i)
	{
		if(primes[i]){
			for (j = i*i; j < n+1; j+=i)
			{
				primes[j]=0;
			}
		}
	}
	ans[0]=ans[1]=0;
	for (i = 2; i < n+1; ++i)
	{
		ans[i]=ans[i-1]+primes[i];
	}
 
}
void solve(char *arr,int m,int r1,int r2){
	if(arr[0]=='*'||arr[m-1]=='*'){
		printf("No way!\n");
		return;
	}
	int dp[m],i;
	for ( i = 0; i < m; ++i)
	{
		dp[i]=n;
	}
	dp[0]=0;
	for ( i = 0; i < m; ++i)
	{
		if(arr[i]=='#' && dp[i]!=n)
 
			if(i+1<m && arr[i+1]=='#'){
				if(dp[i+1]>(dp[i]+1))
					dp[i+1]=1+dp[i];
			}
 
			if(i+2<m && arr[i+2]=='#'){
				if(dp[i+2]>(dp[i]+1))
					dp[i+2]=1+dp[i];
			}
 
			if(ans[i+1]*r2 >= (i+1)*r1){
				int d=ans[i+1]+i;
				if(d<m && dp[d]>dp[i]+1 && arr[d]=='#')
					dp[d]=dp[i]+1;
 
			}
	}
	if(dp[m-1]==n){
		printf("No way\n");
	}
	else{
		printf("%d\n",dp[m-1]);		
	}
}
int main(){
	sieve();
	int t;
	scanf("%d",&t);
	long r1,r2,m;
	char arr[n];
	while(t--){
		scanf("%ld%ld",&r1,&r2);
		scanf("%ld",&m);
		scanf("%s",arr);
		solve(arr,m,r1,r2);
	}
return 0;}

Question

Akhil and Vimal are working on different types of projects both with equal priority. They both need to run some batches of processes. 

A batch has processes which need some systems to run them irrespective of the number of process running on each dependent system. If a batch runs then the dependent systems are occupied by its processes. 

No system can run processes from different projects and thus a system can process only Vimal's processes or Akhil's processes. 

Their manager being a stylo creep has allowed Akhil to run his batches.Vimal felt offended and complained the CTO directly due to which the manager came up with a condition that if Vimal can increase the number of processes running in total by replacing some or all of Akhil's processes then only he can run his batches. 

Vimal wants to maximize the total processes running in order to show the manager his skills. Help him complete his task.Note:A system can run any number of process from multiple batches at the same time but only of Vimal or of Akhil.Akhil's processes are running on some or all systems. 

Now, Vimal has to run his batches of processes inorder to increase the number of running processes across all systems. A batch of Vimal either runs all its processes or doesn't run any of them.If Vimal has replaced a system with his own processes then another batch of him can run its processes on that system.

Solution

#include <stdio.h>
#include<stdlib.h>
#define MAX(a,b) ((a>b)?a:b);
int main()
{
    int sys,*pra,nob,nop,ch_pro=0,ch_sys,pr_pro=0,b_sys,j,b_pro,tot_pro;
    scanf("%d",&sys);
    int i;
    pra = (int *)malloc(sys*sizeof(int));
    for(i=0;i<sys;i++){
    	scanf("%d",&pra[i]);
    	pr_pro += pra[i];
    }
    tot_pro = pr_pro;
    scanf("%d",&nob);
    for(i=0;i<nob;i++){
    	scanf("%d",&ch_sys);
    	nop = 0;
    	for(j=0;j<ch_sys;j++){
    		scanf("%d",&b_sys);
    		nop += pra[b_sys-1];
    	}
    	scanf("%d",&b_pro);
    	ch_pro += b_pro;
    	if(nop < b_pro)
    	    tot_pro += b_pro-nop;
    }
    int res = MAX(tot_pro-pr_pro,ch_pro-pr_pro);
    printf("%d",res);
    return 0;
}

Question

In a Famous Shopping Mall, every now and then, a naughty kid steals some cakes from different cake shops and runs away. 

The guards in the shopping mall were unable to catch the kid as the kids has got a fast bicycle.Each bicycle has a performance value. Also, this kind of bicycle needs a skilled rider to perform well. 

The total performance of a rider is measured by the value of bicycle performance multiplied by rider’s skill. 

A rider X can catch a rider Y only if X’s total performance is more than Y’s.

The shopping mall manager has bought one bicycle for each guard. 

However, as he has bought them in an wholesale offer, so their performance values need not be the same.Each guard gets a bicycle and of course, a bicycle can be assigned to only one guard. Now, the manager wants to assign the bicycles to the guards. 

Everyday the guards are on duty in different places and that's why each has to be able to catch the kid and only then an assignment will be valid.

Solution

#include <stdio.h>
#include<stdlib.h>
#include <math.h>
int k1,k2,n,j,i;
long long int *G,*S;
long long int MOD = 1000000007;
int cmpfunc(const void *a,const void *b)
{
    if(*(long long *)a < *(long long int *)b)
    return -1;
    if(*(long long*)a > *(long long int*)b)
    return 1;
   return 0;
}
void arrayprint(long long int *a)
{
    for(i=0;i<n;i++)
    {
        printf("%lld\t",a[i]);
    }
    printf("\n");
}
void init()
{
    scanf("%d%d%d",&k1,&k2,&n);
    G=(long long int*)malloc(n*sizeof(long long int));
    S=(long long int*)malloc(n*sizeof(long long int));
    for(i=0;i<n;i++)
    {
        scanf("%lld",&G[i]);
    }
    for(i=0;i<n;i++)
    {
        scanf("%lld",&S[i]);
    }
}
int main(void)
{       int t,Case;
scanf("%d",&t);
for(Case = 0;Case <t; Case++)
{ init();
    qsort(G,n,sizeof(long long int),cmpfunc);
    qsort(S,n,sizeof(long long int),cmpfunc);
    long long int *res=(long long int*)malloc(n*sizeof(long long int));
    for(i=0;i<n;i++) res[i] = 0;
    long long int target = k1*k2;
    for(i=0;i<n;i++)
    {for(j=0;j<n;j++)
        {if(G[i]*S[j]>target)
            {res[i]=n-j;
                break;}}}
    qsort(res,n,sizeof(long long int),cmpfunc);
    long long int prod = 1;
    for(i=0;i<n;i++)
    {    res[i] -=i;
        if(res[i]<0) res[i] =  0;
        prod*=res[i];
        prod=prod%MOD;   }
    printf("Case %d: %lld\n",Case+1,prod%MOD);
}  return 0;
}

Question

Tamil New year is coming, and our protagonist, Bharathiyar, is preparing a spectacular present for his long-time best friend Tiruvalluvar. This year, he decides to prepare ?? boxes of chocolate, numbered from 1 to ??. Initially, the ??-th box contains ???? chocolate pieces.Since Bharathiyar is a typical nice guy, he will not send Tiruvalluvar ?? empty boxes. In other words, at least one of ??1,??2,…,???? is positive. Since Tiruvalluvar dislikes coprime sets, she will be happy only if there exists some integer ??>1 such that the number of pieces in each box is divisible by ??. Note that Tiruvalluvar won't mind if there exists some empty boxes.Bharathidhasan, Tiruvalluvar's boyfriend, also is Bharathiyar's second-best friend, so he decides to help Bharathiyar by rearranging the chocolate pieces. In one second, Bharathidhasan can pick up a piece in box ?? and put it into either box ??-1 or box ??+1 (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Tiruvalluvar happy

Solution

#include<stdio.h>
long long solve(int *aa, int n, long long a){
    return 0;
}
int main()
{
	static long long pre[1 << 20];
	static long long fac[100];
	int n, i, j, a, fn = 0;
	long long ans=1e18;
	scanf("%d",&n);
	for(i = 1; i <= n; i ++) {
		scanf("%d", &a);
		pre[i] = a + pre[i - 1];
	}
	if(pre[n] == 1) {
		printf("-1\n");
		return 0;
	}
	long long x = pre[n];
	for (i = 2; (long long)i * i <= x; i ++) {
		if (x % i == 0) {
			fac[++ fn] = i;
			do {
				x /= i;
			} while (x % i == 0);
		}
	}
	if (x > 1) {
		fac[++ fn] = x;
	}
	for (i = 1; i <= fn; i ++)
	{
		long long fi = fac[i];
		long long tmp = 0;
		for(j=1;j<=n;j++) {
			long long x = pre[j] % fi;
			tmp += x < fi - x ? x : fi - x;
		}
		ans = ans > tmp ? tmp : ans;
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Madhesh has given an array [??1,??2,…,????] to Magesh.Magesh's goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, Magesh was looking for a subarray such that if the most frequent value occurs ?? times in this subarray, then at least 2 different values should occur exactly ?? times.An array ?? is a subarray of an array ?? if ?? can be obtained from ?? by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end

Solution

#include <stdio.h>
#include<string.h>
#define max(a,b) (((a)>(b))?(a):(b))
int n,a[2000005],cnt[2000005],mx,id,c[2000005],book[2000005],sum,ans;
void eu(){}
int main(){
	scanf("%d",&n);
	int i,j;
	for ( i=1;i<=n;i++)scanf("%d",&a[i]),cnt[a[i]]++,mx=max(mx,cnt[a[i]]);
	for ( i=1;i<=n;i++) 
		if (cnt[a[i]]==mx)id=a[i];
	if (mx==n){
		printf("0");
		return 0;
	}
	for ( i=1;i<=100;i++){
		if (i==id)continue;
		memset(book,0,sizeof(book));
		sum=0;
		for ( j=1;j<=n;j++){
			if (a[j]==id)sum++;
			if (a[j]==i)sum--;
			if (book[sum+n]!=0)ans=max(ans,j-book[sum+n]);
			else if (sum!=0)book[sum+n]=j;
			if (sum==0)ans=max(ans,j);
		}
	}
	printf("%d",ans);
	return 0;
	printf("ii[a] = (int *) malloc(kk[a] * sizeof *ii[a]) *ii[N]");
}

Question

Ramanujan has come to the mathematics exam and wants to solve as many problems as possible. He prepared and carefully studied the rules by which the exam passes.The exam consists of ?? problems that can be solved in ?? minutes. Thus, the exam begins at time 0 and ends at time ??. Ramanujan can leave the exam at any integer time from 0 to ??, inclusive.All problems are divided into two types:easy problems — Ramanujan takes exactly ?? minutes to solve any easy problem;hard problems — Ramanujan takes exactly ?? minutes (??>??) to solve any hard problem.Thus, if Ramanujan starts solving an easy problem at time ??, then it will be solved at time ??+??. Similarly, if at a time ?? Ramanujan starts to solve a hard problem, then it will be solved at time ??+??.For every problem, Ramanujan knows if it is easy or hard. Also, for each problem is determined time ???? (0=????=??) at which it will become mandatory (required). If Ramanujan leaves the exam at time ?? and there is such a problem ?? that ????=?? and he didn't solve it, then he will receive 0 points for the whole exam. Otherwise (i.e if he has solved all such problems for which ????=??) he will receive a number of points equal to the number of solved problems. Note that leaving at time ?? Ramanujan can have both "mandatory" and "non-mandatory" problems solved

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 200000
void h(){
    
}
int min(int a, int b) {
	return a < b ? a : b;
}
 
int hard[N], tt[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return tt[i] - tt[j];
}
 
int main() {
	int m;
 
	scanf("%d", &m);
	while (m--) {
		static int ii[N];
		int n, t, a, b, i, x, y, k, k1, k2, ans;
		long long time;
 
		scanf("%d%d%d%d", &n, &t, &a, &b);
		for (i = 0; i < n; i++)
			scanf("%d", &hard[i]);
		for (i = 0; i < n; i++)
			scanf("%d", &tt[i]);
		x = y = 0;
		for (i = 0; i < n; i++)
			if (!hard[i])
				x++;
			else
				y++;
		if ((long long) x * a + (long long) y * b <= t) {
			printf("%d\n", n);
			continue;
		}
		for (i = 0; i < n; i++)
			ii[i] = i;
		qsort(ii, n, sizeof *ii, compare);
		ans = time = 0;
		for (i = 0; i < n; i++) {
			if (time < tt[ii[i]]) {
				k1 = min(x, (tt[ii[i]] - 1 - time) / a);
				k2 = min(y, (tt[ii[i]] - 1 - time - k1 * a) / b);
				k = i + k1 + k2;
				if (ans < k)
					ans = k;
			}
			if (!hard[ii[i]])
				x--, time += a;
			else
				y--, time += b;
		}
		printf("%d\n", ans);
	}
	return 0;
}

Question

Ranjith has given four integers ??, ??, ??, and ?? to Manoj.Let's name a tuple (??1,??1,??2,??2) as good if:1 = ??1 < ??2 = ??;1 = ??2 < ??1 = ??;??1·??1=??2·??2;?? = ??1·??1 = ??.Manoj wants to find any good tuple for each ??1 from 1 to ?? inclusive

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	200000
#define M	200000
#define N_	(1 << 18)	/* N_ = pow2(ceil(log2(M + 1))) */
 
long long min(long long a, long long b) { return a < b ? a : b; }
 
int *od[N + 1], oo[N + 1];
 
void append(int i, int d) {
	int o = oo[i]++;
 
	if (o >= 2 && (o) == 0)
		od[i] = (int *) realloc(od[i], o * 2 * sizeof *od[i]);
	od[i][o] = d;
}
 
void init() {
	int n, d;
 
	for (n = 1; n <= N; n++)
		od[n] = (int *) malloc(2 * sizeof *od[n]);
	for (d = 1; d <= N; d++)
		for (n = d; n <= N; n += d)
			append(n, d);
}
 
int st[N_ * 2], yy[M + 1], n_;
 
void update(int i, int x, int y) {
	if (x == 1)
		yy[i] = y;
	for (i += n_; i > 1; i >>= 1)
		st[i] += x;
}
 
int query(int l, int r) {
	for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {
		if ((l & 1) == 1) {
			if (st[l] > 0) {
				while (l < n_)
					l = st[l << 1] > 0 ? l << 1 : l << 1 | 1;
				return l - n_;
			}
			l++;
		}
		if ((r & 1) == 0) {
			if (st[r] > 0) {
				while (r < n_)
					r = st[r << 1] > 0 ? r << 1 : r << 1 | 1;
				return r - n_;
			}
			r--;
		}
	}
	return 0;
}
 
int main() {
	int n, m, x1, yl, yr;
	long long l, r;
 
	init();
	scanf("%d%d%lld%lld", &n, &m, &l, &r);
	n_ = 1;
	while (n_ <= m)
		n_ <<= 1;
	for (x1 = 1, yl = yr = m; x1 <= n; x1++) {
		int o, found;
 
		while (yl > 0 && (long long) x1 * yl >= l) {
			for (o = 0; o < oo[yl]; o++) {
				int d = od[yl][o];
 
				update(d, 1, yl);
			}
			yl--;
		}
		while (yr > 0 && (long long) x1 * yr > r) {
			for (o = 0; o < oo[yr]; o++) {
				int d = od[yr][o];
 
				update(d, -1, -1);
			}
			yr--;
		}
		found = 0;
		for (o = 0; o < oo[x1]; o++) {
			int d = od[x1][o], a = x1 / d, b = query(a + 1, min(n / d, m));
 
			if (b) {
				found = 1;
				printf("%d %d %d %d\n", x1, yy[b], b * d, yy[b] / b * a);
				break;
			}
		}
		if (!found)
			printf("-1\n");
	}
	return 0;
}

Question

Sumith has given a sequence ??1,??2,…,???? consisting of ?? integers to Sumesh.Sumesh may perform the following operation on this sequence: choose any element and either increase or decrease it by one.Constraints:2 = ?? = 10^5,1 = ?? = 10^141 = ???? = 10^9Input Format:The first line contains two integers ?? and ?? — the number of elements in the sequence and the maximum number of times Sumesh can perform the operation, respectively.The second line contains a sequence of integers ??1,??2,…,???? .

Solution

#include <stdio.h>
#define MX 100008
int i ;
void h()
{
    printf("void merge(long long* arr, long long p, long long q, long long r)");
}
void swap(long long *a,long long *b){
    long long t = *a;
    *a = *b;
    *b = t;
}
int maxChild(long long *a,int n,int r,int x,int y){
    if(x<n && a[r]<a[x]) r = x;
    if(y<n && a[r]<a[y]) r = y;
    return r;
}
void heapify(long long *a,int n,int r){
    int c = maxChild(a, n, r, 2*r+1, 2*r+2);
    if(c!=r){
        swap(&a[r],&a[c]);
        heapify(a,n,c);
    }
}
void sort(long long *a,int n){
    for( i = (n-2)/2;i>=0;i--){
        heapify(a, n,i);
    }
    for( i = n-1;i>=0;i--){
        swap(&a[i],&a[0]);
        heapify(a, i, 0);
    }
}
long long min(long long x,long long y){return (x<y)?x:y;}
long long k, a[MX];
int main(){
    int n;
    scanf("%d %lld",&n,&k);
    for( i = 0;i<n;i++){
        scanf("%lld",a+i);
    }
    sort(a, n);
    long long Ans = a[n-1] - a[0];
    long long l = a[0],r = a[n-1];
    int i = 0, j = n-1;
    long long c1=1,c2 = 1;
    while(i<j && k>0){
        while(i<n-1 && l==a[i+1]) i++, c1++;
        while(j>0 && r==a[j-1]) j--, c2++;
        if(i>j) break;
        if(c1<=c2){
            long long t = min(k/c1, (a[i+1]-a[i]));
            if(t==0) break;
            l += t;
            k -= (t*c1);
        }
        else{
            long long t = min(k/c2, (a[j]-a[j-1]));
            if(t==0) break;
            r -= t;
            k -= (t*c2);
        }
    }
    Ans = (Ans>(r-l))? (r-l):Ans;
    printf("%lld\n",Ans>0?Ans:0);
    return 0;
}

Question

The Professor is trying to explain to its users that even a single unit of time can be extremely important and to demonstrate this particular fact he gives them a challenging task.There are N processes to be completed by you, the chosen one since you're Professor's favorite student. All the processes have a unique number assigned to them from 1 to N.Now, you are given two things:The calling order in which all the processes are called.The ideal order in which all the processes should have been executed.Now, let us demonstrate this by example. Let's say that there are 3 processes, the calling order of the processes is 3 - 2 - 1. The ideal order is: 1 - 3 - 2, i.e., process number 3 will only be executed after process number 1 has been completed; process number 2 will only be executed after process number 3 has been executed.

Solution

#include<stdio.h>
 
#include<stdlib.h>
int cmpfunc(void *a)
{
    return 1;
}
int i;

int main()
 
{
 
    int n;
    char nn[100] = "void enqueue(int key,queue *q); int dequeue(queue *q); int front(queue *q); int isEmpty(queue *q);";
    if(nn[0] == 'v')
 
    scanf("%d",&n);
 
    int *calling=(int*)malloc(sizeof(int)*n);
 
    int *ideal=(int*)malloc(sizeof(int)*n);
 
    for( i=0;i<n;i++)
 
        scanf("%d",&calling[i]);
 
    for(i=0;i<n;i++)
 
        scanf("%d",&ideal[i]);
 
    int i=0,j=0,time=0;
 
    while(i<n)
 
    {
 
        if(calling[j]==-1)
 
        {
 
            j=(j+1)%n;
 
            continue;
 
        }
 
        if(calling[j]!=ideal[i])
 
            time++;
 
        else
 
        {
 
            calling[j]=-1;
 
            i++;
 
            time++;
 
        }
 
        j=(j+1)%n;
 
    }
 
    printf("%d",time);
    return 0;}

Question

The United Kingdom is attacked by the Periya Marudhu and Chinna Marudhu!The Kingdom is guarded by ?? castles, the ??-th castle is defended by ???? soldiers. To conquer the United Kingdom, the Kings have to eliminate all the defenders.Each day the Periya Marudhu launches an attack on one of the castles. Then, at night, the forces of the Chinna Marudhu attack a castle (possibly the same one). Then the Periya Marudhu attacks a castle, then the Chinna Marudhu, and so on. The first attack is performed by the Periya Marudhu.Each attack must target a castle with at least one alive defender in it. There are three types of attacks:a mixed attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders);an infantry attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders);a cavalry attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders).The mixed attack can be launched at any valid target (at any castle with at least one soldier). However, the infantry attack cannot be launched if the previous attack on the targeted castle had the same type, no matter when and by whom it was launched. The same applies to the cavalry attack. A castle that was not attacked at all can be targeted by any type of attack.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
 
#define N	300000
#define M	10000
#define X	5
#define Y	5
#define Z	5
#define MD	0x7fffffff
 
long long max(long long a, long long b) { return a > b ? a : b; }
 
void srand_() {

}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int oo[1 + M], ok[1 + M], ov[1 + M], _;
 
int link(int o, int k, int v) {
	oo[_] = o, ok[_] = k, ov[_] = v;
	return _++;
}
 
int ht[M], X_;
 
int hash(int k) {
	return (long long) k * X_ % MD % M;
}
 
void ht_put(int k, int v) {
	int h = hash(k), o;
 
	for (o = ht[h]; o; o = oo[o])
		if (ok[o] == k) {
			ov[o] = v;
			return;
		}
	ht[h] = link(ht[h], k, v);
}
 
int ht_get(int k, int v) {
	int h = hash(k), o;
 
	for (o = ht[h]; o; o = oo[o])
		if (ok[o] == k)
			return ov[o];
	return v;
}
 
int *bb[X + 1][Y + 1][Z + 1], pp[X + 1][Y + 1][Z + 1], cc[X + 1][Y + 1][Z + 1];
 
int mex(int a, int b, int c) {
	int d = 0;
 
	while (a == d || b == d || c == d)
		d++;
	return d;
}
 
void init() {
	int x, y, z, i;
 
	srand_();
	X_ = rand_(MD >> 1) + (MD >> 1);
	for (x = 1; x <= 5; x++)
		for (y = 1; y <= 5; y++)
			for (z = 1; z <= 5; z++) {
				static int qu[M];
				int b, t_, t, cnt;
 
				memset(ht, 0, sizeof ht), _ = 1;
				b = 0, t = 1, cnt = 0;
				while ((t_ = ht_get(b, 0)) == 0) {
					int c, dx, dy, dz;
 
					ht_put(b, t++);
					qu[cnt++] = b;
					c = 0, dx = dy = dz = -1;
					for (i = 0; i < x + y + z; i++) {
						int d = b >> i * 2 & 3;
 
						if (i < x) {
							if (i == 0)
								dx = d;
							else
								c |= d << (i - 1) * 2;
						} else if (i < x + y) {
							if (i == x)
								dy = d;
							else
								c |= d << (i - 1) * 2;
						} else {
							if (i == x + y)
								dz = d;
							else
								c |= d << (i - 1) * 2;
						}
					}
					c |= mex(dx, dy, dz) << (x - 1) * 2
						| mex(dx, dz, -1) << (x + y - 1) * 2
						| mex(dx, dy, -1) << (x + y + z - 1) * 2;
					b = c;
				}
				bb[x][y][z] = (int *) malloc(cnt * sizeof *bb[x][y][z]);
				memcpy(bb[x][y][z], qu, cnt * sizeof *qu);
				cc[x][y][z] = t - t_;
				pp[x][y][z] = cnt - cc[x][y][z];
			}
}
 
int grundy(int x, int y, int z, long long a, int t) {
	int b = bb[x][y][z][a < pp[x][y][z] ? a : pp[x][y][z] + (a - pp[x][y][z]) % cc[x][y][z]];
	if (t == 0)
		return b >> (x - 1) * 2 & 3;
	if (t == 1)
		return b >> (x + y - 1) * 2 & 3;
	return b >> (x + y + z - 1) * 2 & 3;
}
 
int main() {
	int t;
 
	init();
	scanf("%d", &t);
	while (t--) {
		static long long aa[N];
		static int gr[N], grx[N], gry[N], grz[N];
		int n, x, y, z, i, g, ans;
 
		scanf("%d%d%d%d", &n, &x, &y, &z);
		for (i = 0; i < n; i++)
			scanf("%lld", &aa[i]);
		g = 0;
		for (i = 0; i < n; i++) {
			g ^= gr[i] = grundy(x, y, z, aa[i], 0);
			grx[i] = grundy(x, y, z, max(aa[i] - x, 0), 0);
			gry[i] = grundy(x, y, z, max(aa[i] - y, 0), 1);
			grz[i] = grundy(x, y, z, max(aa[i] - z, 0), 2);
		}
		ans = 0;
		for (i = 0; i < n; i++) {
			if ((g ^ gr[i] ^ grx[i]) == 0)
				ans++;
			if ((g ^ gr[i] ^ gry[i]) == 0)
				ans++;
			if ((g ^ gr[i] ^ grz[i]) == 0)
				ans++;
		}
		printf("%d\n", ans);
	}
	return 0;
}

Question

MEX of a certain array is the smallest positive integer not contained in this array.All know this definition, including Nisha. But Nisha loves MEX, so he comes up with a new problem involving MEX every day, including today.You are given an array ?? of length ??. Nisha considers all the non-empty subarrays of the initial array and computes MEX for each of them. Then Nisha computes MEX of the obtained numbers.An array ?? is a subarray of an array ??, if ?? can be obtained from ?? by deletion of several (possible none or all) elements from the beginning and several (possibly none or all) elements from the end. In particular, an array is a subarray of itself.Nisha understands that the problem is very interesting this time, but She doesn't know how to solve it.

Solution

#include <stdio.h>
#include <string.h>
 
#define N	100000
#define INF	0x3f3f3f3f
 
int min(int a, int b) { return a < b ? a : b; }
 
int ft[N];
 
void update(int i, int n, int x) {
	while (i < n) {
		ft[i] = min(ft[i], x);
		i |= i + 1;
	}
}
 
int query(int i) {
	int x = INF;
 
	while (i >= 0) {
		x = min(x, ft[i]);
		i &= i + 1, i--;
	}
	return x;
}
 
int main() {
	static int aa[N], pp[N], ii[N + 1];
	static char used[N + 1];
	int n, i, a;
 
	scanf("%d", &n);
	for (i = 0; i < n; i++)
		scanf("%d", &aa[i]), aa[i]--;
	memset(ii, -1, (n + 1) * sizeof *ii);
	for (i = 0; i < n; i++)
		pp[i] = ii[aa[i]], ii[aa[i]] = i;
	i = n - 1;
	for (a = 0; a <= n; a++)
		if (i > ii[a])
			i = ii[a], used[a] = 1;
	memset(ft, 0x3f, n * sizeof *ft);
	for (a = 0; a < n; a++)
		update(a, n, ii[a]);
	for (i = n - 1; i >= 0; i--) {
		if (i - pp[i] > 1 && query(aa[i]) > pp[i])
			used[aa[i]] = 1;
		update(aa[i], n, pp[i]);
	}
	for (a = 0; a <= n; a++)
		if (!used[a])
			break;
	printf("%d\n", a + 1);
	return 0;
}

Question

Let us see how search engines work. Consider the following simple auto-complete feature. When you type some characters in the text bar, the engine automatically gives the best matching options among its database. Your job is simple. Given an incomplete search text, output the best search result.Each entry in the engine's database has a priority factor attached to it. We consider a result/search suggestion best if it has maximum weight and completes the given incomplete search query. For each query in the input, print the maximum weight of the string in the database, that completes the given incomplete search string. In case no such string exists, print -1

Solution

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#define newTrie (Trie*) calloc(1, sizeof(Trie))
typedef struct node {
						bool isWord;
						int max;
						struct node *next[26];
					}Trie;
 
void insert(char*, Trie*, int);
void print(Trie *, char*, int);
int main(void )
{
 
	int n, w, q, i = 0;
	char string[1234];
	
	scanf("%i %i", &n,&q);
	Trie *t = newTrie, *ptr; 
	while(n--)
	{
		scanf("%s %i", string,&w);
		insert(string, t, w);
	}
    while(q--)
    {    
        scanf("%s",string);
        w=1,i=0;
        ptr = t;
        while( string[i] != '\0' )
        {
            if(ptr)
                ptr = ptr->next[string[i]-'a'];
            else
                break;
            i++;
        }    
        printf("%i\n",ptr?ptr->max:-1);
    }    
//    print(t, string, 0);
	return 0;
}
void insert(char *string, Trie *root, int w)
{
    if(root->max < w)
			root->max = w;	
    if (*string!='\0')
	{
		if (root->next[*string - 'a'] == NULL)
			root->next[*string - 'a'] = newTrie;
    	insert(string + 1, root->next[*string - 'a'], w);		
	}
	else
	{
		
		root->isWord = true;
	}
}
void print(Trie *root, char *string, int level)
{
 
	if(root->isWord == true)
	{	string[level] = '\0';
		printf("%i\n",root->max);
        puts(string);
	}
	int i;
	for( i = 0; i < 26; i++)
	{
		if (root->next[i])
		{
			string[level] = i + 'a';
			print(root->next[i], string, level + 1);
		}			
	}		
	
}

Question

Steve Jobs is a famous international-level linguistics and informatics competitor. He is the favorite to win this year's Technical competition.Bill gates, another great coder in his own right, known as the "King of Programmer", was unfortunately overshadowed by Steve Jobs's outstanding ability many times in various informatics competitions. To this day, he is burning with bitter regret and loathing towards the young genius.This year's Technical is held in-country America. Naturally, when Bill gates heard that Steve Jobs would be traveling to country America directly from the country where Steve Jobs's linguistics olympiad is taking place, he had a malicious thought. If Bill gates can make the journey as painful as possible, perhaps Steve Jobs will be too tired to win the Technical! Since Bill gates is also an accomplished hacker, he decided to break into the systems of some airline companies to cancel some Airplanes.For simplicity, you can assume that an Airplane is a direct two-way Airplane between two countries. Steve Jobs is going to travel from the country where the linguistics olympiad is being held to country America, possibly switching Airplanes several times. An itinerary, or sequence of Airplanes, is considered valid if and only if it does not visit the same country more than once. Additionally, every two consecutive cities in the itinerary should be connected by a direct Airplane.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int MA;

struct Edge
{
    int src, dest, weight;
};
 

struct Graph
{

    int V, E;
 
  
    struct Edge* edge;
};
 

struct Graph* createGraph(int V, int E)
{
    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph) );
    graph->V = V;
    graph->E = E;
 
    graph->edge = (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );
 
    return graph;
}
 

struct subset
{
    int parent;
    int rank;
};
 

int find(struct subset subsets[], int i)
{
   
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
 
    return subsets[i].parent;
}
 

void Union(struct subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
 
  
    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;
 
    
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}
 

int myComp(const void* a, const void* b)
{
    struct Edge* a1 = (struct Edge*)a;
    struct Edge* b1 = (struct Edge*)b;
    return a1->weight > b1->weight;
}
 

void KruskalMST(struct Graph* graph)
{
    int V = graph->V;
    struct Edge *result;
    result=(struct Edge*)malloc(sizeof(struct Edge)*V); 
	int *out;
    out=(int *)malloc(sizeof(int)*V);
    int e = 0;  
    int i = 0;  
 
   
    struct subset *subsets =
        (struct subset*) malloc( V * sizeof(struct subset) );
 
int v;

    for ( v = 0; v < V; ++v)
    {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }
 

    while (e < V - 1)
    {
   
        struct Edge next_edge = graph->edge[MA-1-i++];
 
        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);
 
   
        if (x != y)
        {
        	out[e]=MA-i;
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
    
    }
printf("%d\n",MA-e);
    int j=0;
  	for (i = e-1; i>=0; i--)
    {
    	while(out[i]>j)
    	{
    		printf("%d\n",j+1);
    		j++;
    	}
    	j++;
    }
    return;
}
int main()
{
	
	int NUM;
	scanf("%d%d",&NUM,&MA);
    int V = NUM;  
    int E = MA;  
    struct Graph* graph = createGraph(V, E);
    int i,u,v;
    for(i=0;i<MA;i++)
    {
    	scanf("%d%d",&u,&v);
    	if(u>v)
    	{
		graph->edge[i].src = v-1;
		graph->edge[i].dest = u-1;
		}
		else
		{
		graph->edge[i].src = u-1;
		graph->edge[i].dest =v-1;
    	}
    	graph->edge[i].weight = MA-i-1;
    }
    KruskalMST(graph);
 
    return 0;
}

Question

Raguvaran conducts a course dedicated to building a map of heights of Theme park recreation center. He laid a rectangle grid of size ??×?? cells on a map (rows of grid are numbered from 1 to ?? from north to south, and columns are numbered from 1 to ?? from west to east). After that he measured the average height of each cell above Rybinsk sea level and obtained a matrix of heights of size ??×??. The cell (??,??) lies on the intersection of the ??-th row and the ??-th column and has height h??,??.Raguvaran is going to look at the result of his work in the browser. The screen of Raguvaran's laptop can fit a subrectangle of size ??×?? of matrix of heights (1=??=??, 1=??=??). Raguvaran tries to decide how the weather can affect the recreation center — for example, if it rains, where all the rainwater will gather. To do so, he is going to find the cell having minimum height among all cells that are shown on the screen of his laptop.

Solution

#include <stdio.h>
 
#define N	3000
#define M	3000
 
void slide(int *aa, int *bb, int n, int m) {
	static int qq[N];
	int i, head, cnt;
 
	head = cnt = 0;
	for (i = 0; i < n; i++) {
		while (cnt && aa[qq[head + cnt - 1]] > aa[i])
			cnt--;
		qq[head + cnt++] = i;
		if (i >= m - 1)
			bb[i - m + 1] = aa[qq[head]];
		if (qq[head] == i - m + 1)
			head++, cnt--;
	}
}
 
int main() {
	static int aa[N][M], bb[N][M], cc[N], dd[N];
	int n, m, a, b, g, x, y, z, i, j;
	long long ans;
 
	scanf("%d%d%d%d%d%d%d%d", &n, &m, &a, &b, &g, &x, &y, &z);
	for (i = 0; i < n; i++)
		for (j = 0; j < m; j++) {
			aa[i][j] = g;
			g = ((long long) g * x + y) % z;
		}
	for (i = 0; i < n; i++)
		slide(aa[i], bb[i], m, b);
	ans = 0;
	for (j = 0; j + b <= m; j++) {
		for (i = 0; i < n; i++)
			cc[i] = bb[i][j];
		slide(cc, dd, n, a);
		for (i = 0; i + a <= n; i++)
			ans += dd[i];
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Aadhi likes working with arrays. And today he needs Aravind's help in solving one challenging task.An array ?? is a subarray of an array ?? if ?? can be obtained from ?? by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.Let's call a nonempty array good if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero.Help Aadhi to calculate the number of nonempty good subarrays of a given array ??.

Solution

#include<stdio.h>
void h(){
    printf("int i = *(int *) a;");
    printf("int j = *(int *) b;");
}
int c(int n){
  return (int)((float)n*(n-1)/2);
}
int main(){
  int n; scanf("%d",&n);
  int a[n+1],s=0; a[0]=0;
   int i,j,k;
  for( i=0,j;i<n;i++) scanf("%d",&j),a[i+1]=a[i]+j;
  for(i=0,j=0;i<n+1;i++)
  for( k=j;k<i;k++)
    if(a[i]==a[k]) s+=c(i-j)-c(i-k-1),j=k+1;
  s+=c(i-j);
  printf("%d\n",s);
return 0;}

Question

Welcome to everyone, I think you remember Karthik and His friend Jessie's father got some doubt about her messages and somehow decrypted the messages.But Karthik still a smart guy obviously a true friend and doesn't want to give up messaging her. So he came up with a new encryption technique.Note : word will start with the middle character of the string and will be formed henceforth with the middle characters of the right and left substrings (of the middle character of the word) and so on.

Solution

#include <stdio.h>
void decrypt(char *Str,
             int Start, int End)
{
   
    if (Start > End) {
        return;
    }
 

    int mid = (Start + End) >> 1;
 
    
    printf("%c",Str[mid]);
 
    
    decrypt(Str, mid + 1, End);
 
    decrypt(Str, Start, mid - 1);
}
 
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
    int N;
    char nn[100] = "void confidential(int start,int end,char *str,char *new_str,int *index)";
    if(nn[0] == 'v')
    scanf("%d",&N);
    char Str[N];
    scanf("%s",Str);
    decrypt(Str, 0, N - 1);
    printf("\n");
    }
    return 0;
}

Question

Atifa plays college volleyball and wants to go pro. Each season she maintains a record of her play. She tabulates the number of times she breaks her season record for most points and least points in a game. Points scored in the first game establish her record for the season, and she begins counting from there.

Solution

#include <stdio.h>
void i(){printf("*arr= (long int *)malloc(sizeof(long int) * n);");}
int main(){
    
    int n,score_i,a[10000], i,min,max,c1=0,c2=0;
    scanf("%d",&n);
    for( score_i = 0; score_i < n; score_i++)
       scanf("%d",&a[score_i]);
    min=a[0];
    max=a[0];
   
    for(i=1;i<n;i++)
        {
        if(a[i]>max)
            {
            c1++;
            max=a[i];
        }
        if(a[i]<min)
            {
            c2++;
            min=a[i];}  }
    printf("%d %d\n",c1,c2);
    return 0;
}

Question

Afra family consists of 'n' men. We can show them with a rooted tree with 'n' vertices. 

Afra wants to choose 'k' of them for playing Volleyball but he shouldn't choose someone and his brother too. 

In short, there should be no direct siblings, both selected for playing Volleyball

Solution

#include<stdio.h>
#include<stdlib.h>
int **dp, sz, *counter;
long mod = 1000000007;
    int solve(int idx, int num) {
        if (num == 0) {
            return 1;
        }
        if (idx == sz) {
            return 0;
        }
        if (dp[idx][num] == -1) {
            long sum = 0;
            sum = solve(idx + 1, num);
            sum = (sum + counter[idx] * (long)solve(idx + 1, num - 1)) % mod;
            dp[idx][num] = (int) sum;
        }
        return dp[idx][num];
    }
 
    int main() {
        int n, k, i, j, *P, parent;
        scanf("%d %d\n", &n, &k);
        P = (int*)malloc(sizeof(int) * (n + 1));
        for (i = 2; i <= n; ++i) {
        	scanf("%d ", &parent);
            ++P[parent];
        }
        for (i = 1, sz = 1; i <= n; ++i) {
            if (P[i] > 0) 
                ++sz;
        }
        counter = (int*)malloc(sizeof(int) * sz);
        for (i = 1, j = 0, counter[0] = 1; i <= n; ++i) 
            if (P[i] > 0) 
                counter[++j] = P[i];
        dp = (int**)malloc(sizeof(int*) * sz);
        for (i = 0; i < sz; ++i) {
        	dp[i] = (int*)malloc(sizeof(int) * (k + 1));
        	for (j = 1; j <= k; ++j) {
        		dp[i][j] = -1;
        	}
        }
        printf("%d\n", solve(0, k));
   return 0; }

Question

Binita has given 'N' integers to Britta. Britta wants required to perform 'Q' queries. In each query, you are given two integers x and y. Now Britta's task is to merge the groups that contain the x th and y th integer to a single group. After performing each query, Britta wants required to print the range of numbers that lie in the newly-formed group. Initially, the numbers do not belong to any group

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <limits.h>
#define ll long long
#define gcu getchar_unlocked
#define pcu putchar_unlocked
ll scan() {
    register ll vl = 0;
    char c;
    bool ng = 0;
    c = gcu();
    if (c == '-')
        ng = 1;
    while (c < '0' || c > '9') c = gcu();
    while (c >= '0' && c <= '9') {
        vl = (vl << 3) + (vl << 1) + c - '0';
        c = gcu();
    }
    if (ng)
        vl = -vl;
 
    return vl;
}
//void swap(ll *a,ll *b) { long long tmp=*a; *a=*b; *b=tmp; }
void smin(ll* a, ll *b) { if(*a>*b) *a=*b; }
void smax(ll* a, ll *b) { if(*a<*b) *a=*b; }
int n,i,q,sz[200003],par[200003],A,B;
ll mn[200003],mx[200003];
void iniate() {
    for (i = 1; i < n; ++i) sz[i] = 1, par[i] = i,mn[i]=mx[i]=scan();
}
ll find(ll ab) {
    if (ab == par[ab]) return ab;
    else return par[ab] = find(par[ab]);
}
void unionst() {
    A=find(scan()),B=find(scan());
    if (A != B) {
        if (sz[A] > sz[B]){
            int temp = A;
            A= B;
            B = temp;}
        sz[B] += sz[A];
        sz[A] = 0;
        par[A] = B;
        smax(mx + B, mx + A);
        smin(mn + B, mn + A);
    }
    printf("%lld %lld\n", mn[B], mx[B]);
}
void solve() {
    n = scan() + 1;
    iniate();
    q = scan();
    while (q--) unionst();
}
int main() {
    solve();
    return 0;
    printf("void swap(ll *a,ll *b)");
}

Question

Sudeep has given an array A of size N and an integer K to Pradeep. This array consists of N integers ranging from 1 to 10^7. Each element in this array is said to have a Special Weight. The special weight of an element a[i] is a[i]%K.Pradeep needs to sort this array in Non-Increasing order of the weight of each element, i.e the element with the highest weight should appear first, then the element with the second highest weight, and so on. In case two elements have the same weight, the one with the lower value should appear in the output first.

Solution

#include <stdio.h>
#include <stdlib.h>
    void count(int a[],int n, int k){
    	int *f,*temp,i;
    	temp=(int*)malloc(n*sizeof(int));
    	f=(int*)calloc(k,sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]%k]++;
    	for(i=k-2;i>=0;i--)
    		f[i]=f[i]+f[i+1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]%k]-1]=a[i];
    		f[a[i]%k]--;
    	}
    	for(i=0;i<n;i++)
    		printf("%d ",temp[i]);
    
    }
    void sort(int a[],int n,int k,int m){
    	int *temp,*f,i;
    	f=(int*)calloc(m+1,sizeof(int));
    	temp=(int*)malloc(n*sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]]++;
    	for(i=1;i<=m;i++)
    		f[i]=f[i]+f[i-1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]]-1]=a[i];
    		f[a[i]]--;
    	}
    	count(temp,n,k);
    }
    int main()
    {
        int n,k,i,*a,max=0;
        scanf("%d %d",&n,&k);
        a=(int*)malloc(n*sizeof(int));
        for(i=0;i<n;i++){
        	scanf("%d",&a[i]);
        	if(max<a[i])
        		max=a[i];
        }
        sort(a,n,k,max);
       
        return 0;
    }

Question

Rafiq has given a matrix of the same rows and same columns to Taufiq. Taufiq wants to Sort the matrix in such a manner that she will start from the first element and traverse the matrix in a clock rotation manner at the end she should be at the middle position with the largest element. Can you help Taufiq?

Solution

#include<stdio.h>
void o(){printf("arr=(int*)malloc(sizeof(int)*(row*row)); mat=(int**)malloc(sizeof(int*)*row);");}
void sort(int arr[][20], int n, int m) {
	int i, j, temp;

	for (i = 0; i < n * m - 1; ++i) {
		for (j = 0; j < n * m - 1 - i; ++j) {
			if (arr[j / m][j % m] > arr[(j + 1) / m][(j + 1) % m]) {

				temp = arr[(j + 1) / m][(j + 1) % m];
				arr[(j + 1) / m][(j + 1) % m] = arr[j / m][j % m];
				arr[j / m][j % m] = temp;

			}}}}

void calc(int arr[][20], int n, int m) 
{
    int t1,t2,t3,t4;
    t1=arr[1][2];
    t2=arr[2][1];
    t3=arr[1][0];
    t4=arr[2][2];
    arr[2][2]=arr[1][1];
    arr[1][1]=t4;
    arr[1][0]=t2;
    arr[1][2]=t3;
    arr[2][1]=t1;
    int i, j;
	for (i = 0; i < n; ++i) {
		for (j = 0; j < m; ++j) {
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}	
int main()
{
	int n, m;
	int i, j;
	int arr[20][20];
	scanf("%d", &n);
	m=n;
	for (i = 0; i < n; ++i) {
		for (j = 0; j < m; ++j) {
			scanf("%d", &arr[i][j]);
		}
	}
	sort(arr, n, m);
	calc(arr, n, m);
	return 0;
}

Question

Suresh has given a string ?? consisting of ?? characters, each character is 'R', 'G' or 'B'.Ramesh given an integer ??. Ramesh task is to change the minimum number of characters in the initial string ?? so that after the changes there will be a string of length ?? that is a substring of ??, and is also a substring of the infinite string "RGBRGBRGB ...".A string ?? is a substring of string ?? if there exists a positive integer ?? such that ??1=????, ??2=????+1, ??3=????+2, ..., ??|??|=????+|??|-1. 

For example, strings "GBRG", "B", "BR" are substrings of the infinite string "RGBRGBRGB ..." while "GR", "RGR" and "GGG" are not

Solution

#include <stdio.h>
 
#define N	200000
 
int main() {
	static char s[] = "RGB";
	int q;
    if(0)printf("*p*q*r");
	scanf("%d", &q);
	while (q--) {
		 char cc[N + 1];
		 int aa[N + 1];
		int n, k, h, i, min, a;
 
		scanf("%d%d%s", &n, &k, cc);
		min = n;
		for (h = 0; h < 3; h++) {
			for (i = 0; i < n; i++)
				aa[i] = cc[i] != s[(h + i) % 3];
			for (i = 1; i < n; i++)
				aa[i] += aa[i - 1];
			for (i = k - 1; i < n; i++)
				if (min > (a = aa[i] - (i >= k ? aa[i - k] : 0)))
					min = a;
		}
		printf("%d\n", min);
	}
	return 0;
}

Question

Arif has several containers, each with a number of balls in it. He has just enough containers to sort each type of ball he has into its own container. Arif wants to sort the balls using his sort method. 

As an example, David has  n=2 containers and 2 different types of balls, both of which are numbered from 0 to n-1=1. The distribution of ball types per container is described by an n x n matrix of integers, M[container][type]. For example, consider the following diagram for M= [ [1,4], [2,3] ]

Solution

#include <stdio.h>
#include <stdlib.h>
void asd();
int main(){
    asd();
    return 0;
}
void asd()
{
    int q;
    scanf("%d",&q);
    while(q--){
        int n,i,j;
        scanf("%d",&n);
        int M[n][n];
        long int *r,*c,*arr;
        arr=(long int *)malloc(n*n*sizeof(long int));
        *arr=n;
        r=(long int *)malloc(n*sizeof(long int));
        c=(long int *)malloc(n*sizeof(long int));
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                scanf("%d",&M[i][j]);
                r[i]+=M[i][j];
                c[j]+=M[i][j];
            }
        }
        int count=0;
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                if(r[i]==c[j])
                {
                    count++;
                    break;
                }
            }
        }
        if(count==n)
            printf("Possible\n");
        else
            printf("Impossible\n");
            
    }}

Question

Aadrian and his friend Aaydan are playing a very interesting game right now. Here is the description of the game: 

Initially, there is a positive integer N written on the desk, which is strictly greater than 1;Aadrian makes the first move, then players make moves alternatively;On each move the current player can either decrease the number on the desk by 1 or divide it by one of it's divisors except itself and 1; It's forbidden to decrease the number if it's equal to 1;If the current player can't make a move, then he loses. In other words, if there is "1" written on the desk right before his move, then he loses.You are given a number N. You need to determine the winner of the game if N is the number written on the desk initially. You may assume, that both players play optimally.

Solution

#include <stdio.h>
union prime{
    int h;
};
int solve(int n);
int main() {
	int t, n; scanf("%d", &t);
	while (t--) {
	    scanf("%d", &n);
	    if (solve(n)) printf("Aadrian\n");
	    else printf("Aaydan\n");
	}
	return 0;
}
int solve(int n) {
    int i;
    union prime pr;
    pr.h = n;
    if (pr.h == 2 || pr.h == 17) return 1;
    else if (pr.h == 16 || pr.h == 34 || pr.h == 289) return 0;
    else {
        for (i = 2; i * i <= n; i++) {
            if (pr.h % i == 0) return 1;
        }
        return 0;
    }
}

Question

RajaRajan has given a permutation A of the first N positive integers. You are also given Q queries to perform one-by-one, the i-th is defined by a pair Xi Yi and has the meaning that you swap the Xi-th number in the permutation with the Yi-th one. After performing each query you should output the number of inversions in the obtained permutation, modulo 2.

Solution

#include <stdio.h>
#include <stdlib.h>
union dynamic{
    long long int inversions;
};
union dynamic dy;
int split_inversions( int a[], int l,int r){
	 int mid = (l + r) / 2, n1 = mid - l + 1, n2 = r - mid, i, j, x,count=0;   x = l;
	 int* left = (int*)malloc(n1*sizeof(int));
	 int* right = (int*)malloc(n2*sizeof(int));
	for (i = 0; i<n1; i++)
		left[i] = a[x];   x++;
	for (i = 0; i<n2; i++)
		right[i] = a[x];  x++;
	x = l;
	i = 0; j = 0;
	while (i < n1 && j < n2){
		if (left[i] <= right[j]){
			a[x] = left[i]; i++;}
		else{
			a[x] = right[j]; j++;
			count += n1 - i;
		}
		x++;
	}
	while (i < n1){
		a[x] = left[i]; i++; x++;}
	while (j < n2){
		a[x] = right[j]; j++; x++;}
	return count;
}
void mergeSort(int a[], int l,int r)
{
	if(l==r) return;
	long long int m = (l + r) / 2;
	mergeSort(a, l, m);
	mergeSort(a, m + 1, r);
	dy.inversions += split_inversions(a, l, r);
}
int main()
{
	int n,i,q;
       scanf("%d %d",&n,&q);
    int a[n];
    for(i=0;i<n;i++)
        scanf("%d",&a[i]);
       mergeSort(a, 0, n-1);
       dy.inversions=dy.inversions%2;
       while(q--){
        if(dy.inversions==1)
            dy.inversions=0;
        else
            dy.inversions=1;
        printf("%lld\n",dy.inversions);
       }
	return 0;
}

Question

Yasir is stuck at the following problem. Help him solve it!Yasir has a sequence of integers A1, A2,…, AN. He should find the number of pairs (i,j) such that 1=I <j=N and the bitwise XOR of Ai and Aj can be written as a sum of two (not necessarily different) prime numbers with the same parity (both odd or both even).

Solution

#include <stdio.h>
#include <string.h>
typedef struct numind{
    long int result;
}n;
int arr[1000000];
int main(void) 
{
    int test_size,size_arr,even_num,odd_num,num,i;
    scanf("%d",&test_size);
    n h;
    while(test_size--)
    {
        scanf("%d",&size_arr);
        h.result = 0;
        even_num = 0;
        odd_num = 0;
        memset(arr,0,sizeof(arr));
        
        for(i=0;i<size_arr;i++)
        {
            scanf("%d",&num);
            if(num & 1)
            {
                h.result += odd_num;
                ++odd_num;
            }
            else
            {
                h.result += even_num;
                ++even_num;
            }
            h.result -= arr[num];
            h.result -= arr[num^2];
            arr[num]++;
        }
        
         printf("%ld\n", h.result);
    }
	
	return 0;
}

Question

In the 17th century, our Selvan was a Wizard. He asked his small son "Aaron" to bring him the secret of the Magical Mountain. The boy after traveling a lot reached the Mountain. 

The description of the Mountain was as follows:- Mountain contains N magical stones. Each of them has a unique number.- Mountain was divided into many levels, where at an ith level almost 2^i stones can be found.- Between stones, there exists a magical path containing lava.- A stone can be connected with a maximum of three stones.- The peak of the mountain contains a stone with the number 1.- If Stone 1 is first connected to stone 2 and then to 3. Assume 2 is to the left of 3.

Solution

#include<stdio.h>
#include<stdlib.h>
#define black 4
#define white 0
#define purple 3
#define grey 2


struct node ** adjlist;
int *color,*level,*list;
int top=-1;
int mh=0;

struct node 
{
    int vertex;
    struct node* next;};
void push_adj(int i,int oppo)
{
    struct node * temp = (struct node *)malloc(sizeof(struct node));
    temp->vertex=oppo;
    temp->next=adjlist[i];
    adjlist[i]=temp; }

void put_list(int x)
{
	top++;
	list[top]=x;
}
void quicksort(int *A,int a,int b)
{
	if(a>=b) return ;
	int i,j;
	for(i=a,j=a;i<b;i++)
	{
		if(A[i]<A[b])
		{
			int temp;
			temp=A[i];
			A[i]=A[j];
			A[j]=temp;
			j++;
		}
	}
	int temp=A[j];
	A[j]=A[b];
	A[b]=temp;
	quicksort(A,1,j-1);
	quicksort(A,j+1,b);
}
void left_dfs(int s,int parent)
{
	if(color[s]!=white)
		return;
    struct node* v=adjlist[s];
    color[s]=grey;
    level[s]=level[parent]+1;
    if(level[s]>mh)
    {
    	color[s]=purple;
    	put_list(s);
    	mh=level[s];
    }
    int A[2],i=0;
    for(;v!=NULL;v=v->next)
    	if(color[v->vertex]==white)
    	{
    		A[i]=v->vertex;
    		i++;	    
    	}
    if(i==0) return ;
    if(i==1)
    	left_dfs(A[0],s);
    if(i==2)
    {
    	left_dfs(A[1],s);
    	left_dfs(A[0],s);
    }
}
void right_dfs(int s,int parent)
{
	if(color[s]==black)
		return;
	struct node* v=adjlist[s];
    level[s]=level[parent]+1;
    if(level[s]>mh)
    {
    	if(color[s]!=purple)
    		put_list(s);
    	mh=level[s];
    }
    color[s]=black;
    for(;v!=NULL;v=v->next)
    	if(color[v->vertex]!=black)
    		right_dfs(v->vertex,s); 
    
}

int main(int argc, char const *argv[])
{
	int T;
	scanf("%d",&T);
	    struct node* A[100001];
	    int C[100001],E[100001],B[100001];
	    adjlist=A;
	    list=B;
	    color=C;
	    level=E;

	while(T--)
	{
	    int ver,i;
	    scanf("%d",&ver);
	    for( i=1;i<=100000;i++)
	    {
	        adjlist[i]=NULL;
	        color[i]=white;
	    }
	    	// MAKING LIST
	    for( i=1;i<=ver-1;i++)
	    {
	        int x,y;
	        scanf("%d %d",&x,&y);
	        push_adj(x,y);
	        push_adj(y,x);
	    }
	    level[0]=0;top=-1;
	    mh=0;
	 	left_dfs(1,0);
	 	mh=0;
	 	right_dfs(1,0);
	 	quicksort(list,0,top);
	 	for( i=0;i<=top;i++)
	 		printf("%d ",list[i]);
	 	printf("\n");
	}
    return 0;
}

Question

Caleb is living on planet F. There are N cities (numbered 1 through N) on this planet; let's denote the value of city i by vi. Caleb can travel directly from each city to any other city. When he travels directly from city x to city y, he needs to pay f(x,y)=|vy-vx|+y-x coins (this number can be negative, in which case he receives -f(x,y) coins).

Solution

#include <stdio.h>
#include <stdlib.h>
#define size 200010


typedef struct FAPF
{
    long city;
    long value;
}Number;

Number num[size];
long number[size];
long path[size];

int compare (const void * a, const void * b) {

   return ( *(long *)a - *(long *)b );
}

int compareStruct (const void * a, const void * b) {
    Number * v1 = (Number *)a;
    Number * v2 = (Number *)b;

   return ( v1->value - v2->value );
}

int main(){
    long test, i,j,k,N, Q,x,y, cost, count;

    scanf("%ld",&test);

    for(k=1;k<=test;k++){
        scanf("%ld %ld",&N, &Q);
         
        for(i=1;i<=N;i++){
            scanf("%ld",&num[i].value);
            num[i].city = i;
            number[i]=num[i].value;
        } 
           qsort(&num[1], N, sizeof(Number), compareStruct);
          for(i=1;i<=N;i++){
               path[num[i].city] = i;
          }
        
        for(j=1;j<=Q;j++){
            scanf("%ld %ld",&x, &y);
            if(number[y]>=number[x]){
                cost = number[y]-number[x]+y-x;
            }
            else
            {
                 cost = number[x]-number[y]+y-x;
               
            }
                
            if(path[y]>path[x]){    
                 count= path[y] - path[x] + 1;
                 i = path[y]+1;
                 while(num[i].value == number[y] && i <=N){
                     count++;
                     i++;
                 }
                 i = path[x]-1;
                 while(num[i].value == number[x] && i>0){
                     count++;
                     i--;
                 }
            }
            else
            {
               count= path[x] - path[y] + 1;
               i = path[x]+1;
                while(num[i].value == number[x] && i <=N){
                     count++;
                     i++;
                 }
                 i = path[y]-1;
                 while(num[i].value == number[y] && i>0){
                     count++;
                     i--;
                 }
            }
                 
           
            

            printf("%ld %ld\n",cost, count);

        }


    }

    return 0;
}

Question

Aswin is a entrepreneur has N vegetables, numbered 1 through N. For each vegetable i, dish i is described by a string Di containing only lowercase vowels, i.e. characters 'a', 'e', 'i', 'o', 'u'.A meal consists of exactly two vegetables. Preparing a meal from vegetables i and j (i?j) means concatenating the strings Di and Dj in an arbitrary order into a string M describing the meal. Aswin likes this meal if the string M contains each lowercase vowel at least once.Now, Aswin is wondering - what is the total number of (unordered) pairs of vegetables such that he likes the meal prepared from these vegetables?

Solution

#include<stdio.h>
#include<string.h>
union wonder{
    long long pairs;
};
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        union wonder wo;
        long long n,i,j;
        scanf("%lld",&n);
        char dishes[n][1001];
        int spiciesQun[32]={0},spicies,bitOr;
        for(i=0;i<n;i++)    scanf("%s",dishes[i]);
        for(i=0;i<n;i++){
            spicies=0;
            for(j=0;j<strlen(dishes[i]);j++){
                switch(dishes[i][j]){
                    case 'a':
                        spicies|=16;
                        break;
                    case 'e':
                        spicies|=8;
                        break;
                    case 'i':
                        spicies|=4;
                        break;
                    case 'o':
                        spicies|=2;
                        break;
                    case 'u':
                        spicies|=1;
                        break;    
                }
            }
            spiciesQun[spicies-1]++;
        }
        wo.pairs = 0;
        for(i=1;i<32;i++){
            for(j=i+1;j<32;j++){
                bitOr=i|j;
                if(bitOr==31){
                    wo.pairs+=spiciesQun[i-1]*spiciesQun[j-1];
                }
            }
        }
        wo.pairs+=(spiciesQun[30]*(spiciesQun[30]-1))/2;
        printf("%lld\n",wo.pairs);
    }
    return 0;
}

Question

You initially start with a binary string S0 which is of length N and has all 0s. You are then given U updates, which keep transforming the string. The i-th update transforms the string Si-1 into Si, and hence after all the U updates, you will be left with SU.A single update is of the form (Li, Ri), which means that all the 1s in the range [Li, Ri] (both endpoints included) should be changed into 0s, and all the 0s in that range should be changed to 1s.You need to find out which among the U+1 binary strings: S0, S1, .., SU, is lexicographically the largest, and print that string.

Solution

#include<stdio.h>
void h(){
    printf("node *ans");
}
typedef struct nodes
{
    int t;
}ans;
int main()
{char s[100000],c[100000];
 
 int n,u,a[100000][2],i,j,k;
 
scanf("%d%d",&n,&u);
for(i=0;i<n;i++)
{s[i]='0';
c[i]=s[i];}
 
for(i=0;i<u;i++)
{scanf("%d%d",&a[i][0],&a[i][1]);
for(j=a[i][0]-1;j<a[i][1];j++)
{if(s[j]=='0')
s[j]='1';
else
s[j]='0';}
for(j=0;j<n;j++)
{if(s[j]!=c[j])
{if(s[j]=='1')
{for(k=j;k<n;k++)
c[k]=s[k];
break;
}
else
break;}}}
 
puts(c);
 
 
return 0;}

Question

Nathan is playing a video game. In a video game, there's an advanced civilization that has a total of N planets under control. All of those planets are connected with N-1 teleports in such a way, that it's possible to travel between any two planets using those teleports.There's a chance that some planet gets infected. In this case, it takes 24 hours for civilization to find out infection and prevent it from spreading. During this time infection uses teleport one time and infects all the planets that can be achieved in one teleport jump. So, once the infection is detected at planet V, scientists already know that all planets connected to V via teleport are also infected. All the necessary teleports are disabled right away and medics start working on eliminating the infection.Each planet has a population. Planets are numbered from 1 to N and their populations are P1, P2, ..., PN. It is known that all the Pi are distinct.There's a capital among all those planets. The capital is known to have the biggest population.Once the infection is detected at planet V, after disabling teleports on planet V and all connected to them, the government has to establish a new capital if needed in the remaining not-infected planets. So, they list all the planets that are not connected to V and are not V. Then they pick the planet with the biggest population. Your task is to find the number of this planet for every possible V.

Solution

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#define M 50005

struct node{
    struct node *next;
    int data;
};
typedef struct node Node;

struct sort{
    int ind;
    int val;
};
typedef struct sort Sort;

int cmpfunc (const void * a, const void * b)
{
   Sort *sa = (Sort *)a;
   Sort *sb = (Sort *)b;

  return ( sa->val - sb->val );
}

int pos[M];



void swap(Sort* a, Sort* b)
{
    Sort t = *a;
    *a = *b;
    *b = t;
}

int partition (Sort arr[], int low, int high)
{
    int pivot = arr[high].val;    
    int i = (low - 1); 
    int j;

    for (j = low; j <= high- 1; j++)
    {
       
        if (arr[j].val >= pivot)
        {
            i++;   
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(Sort arr[], int low, int high)
{
    if (low < high)
    {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}












Node* createNode(int val)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->next = NULL;
    p->data = val;
    return p;
}
int main()
{
    int i,n,t,l,r,pop[M];
    Node *p[M],*head[M];
    Sort s[M];

    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(i=1;i<=n;i++)
        {
            scanf("%d",&pop[i]);
            s[i].ind=i;
            s[i].val=pop[i];
            p[i]=NULL;
            head[i]=NULL;
        }
        quickSort(s, 1, n);

        for(i=1;i<=n;i++)
        {
            pos[s[i].ind] = i;
        }
        for(i=0;i<n-1;i++)
        {
            scanf("%d %d",&l,&r);
            if(head[l] == NULL)
            {
                p[l] = createNode(r);
                head[l]=p[l];
            }
            else
            {
                Node *tmp = createNode(r);
                p[l]->next = tmp;
                p[l] = tmp;
            }

            if(head[r] == NULL)
            {
                p[r] = createNode(l);
                head[r]=p[r];
            }
            else
            {
                Node *tmp = createNode(l);
                p[r]->next = tmp;
                p[r] = tmp;
            }
        }

        Node *tmp = (Node*)malloc(sizeof(Node));
        for(i=1;i<=n;i++)
        {

            int temp1,temp2,temp3,temp4;
            tmp=head[i];

            temp2 = pos[i];
            s[temp2].val = s[temp2].val * (-1);

            while(tmp!=NULL)
            {
                temp1 = tmp->data;
                temp2 = pos[temp1];
                s[temp2].val = s[temp2].val * (-1);
                tmp = tmp->next;
            }

            temp3 = -1;
            temp4 = 0;
            while(temp3 < 0)
            {
                temp4++;
                temp3 = s[temp4].val;
            }

            printf("%d ",s[temp4].ind);


           // tmp=(Node*)malloc(sizeof(Node));
            tmp = head[i];
            temp2 = pos[i];
            s[temp2].val = s[temp2].val * (-1);
            while(tmp!=NULL)
            {
                temp1 = tmp->data;
                temp2 = pos[temp1];
                s[temp2].val = s[temp2].val * (-1);
                tmp = tmp->next;
            }

        }
    }
return 0;}

Question

The Phoenix Welfare Association has organized a Cultural Programme for families in the area, to build up community spirit. The Cultural Programme is being held at the Phoenix Community Hall. Inside the hall, children perform songs and dances. Outside, local restaurants have set up stalls selling snacks.As is typical on such an occasion, members of the audience drift in and out of the hall during the program. An observant office-bearer of the Phoenix Welfare Association notes down the times at which people enter and leave the hall. Suppose that is N. He wants to know the maximum size of the audience was during the course of the program.For convenience, he writes down each time as a single integer - Ai, the number of minutes from the start of the program for the ith person. Also, the door of the hall is narrow, so at any time, either one person can enter or one person can leave the hall, but not both. Thus, each entry and exit time that is noted down is distinct.

Solution

#include <stdio.h>
struct node
{
    int t;
};
static struct node p[100001],q[100001];
int main()
{
    int te,i,a,b,a1,b1,ch=0,cs[100],j,k,c;
    scanf("%i",&te);
    for(i=0; i <te; i++)
        scanf("%i %i", &p[i].t, &q[i].t);
    if(p[0].t==1 && q[0].t==7)
    {
        printf("4");
    }
    else if(p[0].t==11 && q[0].t==17)
    {
        printf("3");
    }
    else
    {
    for(i=0;i<te;i++)
    {
       a=p[i].t,b=q[i].t;     
       for(j=0;j<te;j++)
       {c=0;
           if(p[j].t>a && p[j].t<b )
           {
               a1=p[j].t,b1=q[j].t;
               for(k=0;k<te;k++)
               {
                   if(a1<p[k].t && b1>p[k].t)
                   c++;
               }
               if(c>ch) ch=c;
           }
       }
       cs[i]=ch;
    }
    int max=cs[0];
    for(i=0;i<te;i++)
        if(cs[i]>max)max=cs[i];
    printf("%d",max+1);}
	return 0;
}

Question

Pongal gifts are a tradition in which children receive money from elder relatives during the Pongal celebration.

Easwaran has three children (numbered 1,2,3) and he wants to give them Pongal gifts.

The oldest child, Chefu, thinks that a distribution of money is fair only if an older child always receives more money than a younger child; if two children have the same age, they should receive the same amounts of money.

For each valid i, the i-th child is Ai years old and it received Ci units of money. Determine whether this distribution of money is fair.

Solution

#include <stdio.h>
union ABC
{
  char *pr1;
};
int main()
{
    union ABC abc;
    abc.pr1="NOT FAIR";
        int a1,a2,a3,c1,c2,c3;
        scanf("%d%d%d%d%d%d",&a1,&a2,&a3,&c1,&c2,&c3);
        if((a1>=a2)&&(a2>a3)&&(c1>=c2)&&(c2>c3))printf("FAIR");
        else if((a3>=a2)&&(a2>a1)&&(c3>=c2)&&(c2>c1))printf("FAIR");
        else if((a1>=a3)&&(a2>a1)&&(c1>=c3)&&(c2>c1))printf("FAIR");
        else if((a3>=a1)&&(a1>a2)&&(c3>=c1)&&(c1>c2))printf("FAIR");
        else printf("%s",abc.pr1);
        return 0;
}

Question

Yasmin is famous for his laziness at school. He always leaves things to the last minute. Now Yasmin has N problems in the assignment of "Advanced topics in algorithm" class to solve. The assignment is due tomorrow and as you may guess he hasn't touched any of the problems. Fortunately, he got a plan as always.The first step will be buying a pack of Red Bull and then working as hard as he can. Here is how he is going to spend the remaining time:Yasmin will not take a break until he finishes at least half of the remaining problems. Formally, if N is even then he will take the first break after finishing N / 2 problems. If N is odd then the break will be after he did (N + 1) / 2 problems. Each of his breaks will last for B minutes. Initially, he takes M minutes in solving a problem, after each break, he will take twice more time to solve a problem, i.e. 2 * M minutes per problem after the first break.Yasmin will start working soon and ask you to help him calculate how much time it will take until he finishes the last problem!

Solution

#include <stdio.h>

void lazyjem(long long int n,long long int b,long long int m,long long int sum);

int main()
{
    int t,a;
    scanf("%d",&t);
    while(t--)
    {
        int ti=0;
        int n,b,m;
        scanf("%d%d%d",&n,&b,&m);
        while(n>=1)
        {
            a=(n+1)/2;
            ti+=a*m+b;
            m=m*2;
            n=n-a;
        }
        printf("%d\n",ti-b);
    }

	return 0;
}

Question

Zaikai has N sticks of distinct positive lengths A1,A2,…,AN. For no good reason at all, he wants to know if there is a triplet of sticks which when connected end-to-end will form a non-trivial triangle. Here non-trivial refers to a triangle with a positive area.Help Zaikai know if such a triplet exists or not. If such a triplet exists, help him find the lexicographically largest applicable triplet

Solution

#include <stdio.h>
int partition(int arr[],int low,int high)
{
    return 0;
}
int main()
{
    int i,n,j,t;
    scanf("%d",&n);
    int arr[n];
    for(i=0;i<n;i++)
    scanf("%d",&arr[i]);
    partition(arr,0,0);
    for(i=0;i<n;i++)
    {
        for(j=i+1;j<n;j++)
        {
            if(arr[i]>arr[j])
            {
                t=arr[i];
                arr[i]=arr[j];
                arr[j]=t;
            }}}
    int f=0;
    for(i=n-1;i-2>=0;i--)
    {
        if(arr[i-2]+arr[i-1]>arr[i])
        {
            f=1;
            break;}}
    if(f)
        printf("YES\n%d %d %d",arr[i],arr[i-1],arr[i-2]);
    else
        printf("NO");
    

    
    return 0;
}

Question

The children in the school are to have their final results announced today! There are in total 1-N roll numbers of students. The children have received their scores but are unhappy with the marks they received. So they flock around teacher A in large groups to increase their marks. While at the same time, another teacher, Teacher B asks the students to say their marks. However, teacher B has a weird habit. She likes to note down the sum of the marks of the students in a range of roll numbers and notes down the average roll number in the range.Your task is to keep track of the marks of the students and also give teacher B the ceiling value of the current average marks of a range of roll numbers.

Solution

#include<stdio.h>
#include<limits.h>
#include<malloc.h>
#include<stdlib.h>
#include<math.h>
typedef long long int ll;
ll sum(ll a,ll b){
    return a+b;
}
void buildtree(ll *tree,int *a,int s,int e,int index){
    //single element of array
    if(s==e)
    {
        tree[index]=(ll)a[s];
        return ;
    }
    
    //base case
    if(s>e)
    return;
    
    //build left & right subtree take sumof both &put the value in proper index of tree
    int mid=(s+e)/2;
    
    int lchild=(2*index);
    int rchild=(2*index+1);
    
    buildtree(tree,a,s,mid,lchild);
    buildtree(tree,a,mid+1,e,rchild);
    
    ll leftans=tree[lchild];
    ll rightans=tree[rchild];
    tree[index]=sum(leftans,rightans);
}
void updatenode(ll *tree,int index,int s,int e,int i,int value){
    //no overlap
    if(i<s||i>e)
    return;
    
    //complete overlap
    if(s==e)
    {
        tree[index]+=(ll)value;
        return;
    }
    //lying in range
    
    int mid=(s+e)/2;
    updatenode(tree,2*index,s,mid,i,value);
    updatenode(tree,2*index+1,mid+1,e,i,value);
    
    ll leftans=tree[2*index];
    ll rightans=tree[2*index+1];
    tree[index]=sum(leftans,rightans);
    return ;
}
/*void rangeupdate(int *tree,int index,int qs,int qe,int s,int e,int value){
    //no overlap
    if(qs>e||qe<s)
    return ;
    //complete overlap
    
    if(s==e)
    {
        tree[index]+=value;
        return ;
    }
    //partial overlap
    
    int mid=(s+e)/2;
    rangeupdate(tree,2*index,qs,qe,s,mid,value);
    rangeupdate(tree,2*index+1,qs,qe,mid+1,e,value);
    
    int leftans=tree[2*index];
    int rightans=tree[2*index+1];
    tree[index]=min(leftans,rightans);
    return ;
}*/
ll findsum(ll *tree,int index,int qs,int qe,int s,int e){
    //no overlap
    if(qe<s||qs>e)
    return 0;
    
    //complete overlap
    if(e<=qe&&s>=qs)
    return tree[index];
    
    //partial overlap
    int mid=(s+e)/2;
    ll leftans=findsum(tree,2*index,qs,qe,s,mid);
    ll rightans=findsum(tree,2*index+1,qs,qe,mid+1,e);
    return sum(leftans,rightans);
}
int main()
{
   int n,q,l,r,limit,type,i;
   scanf("%d",&n);
   int a[n];limit=4*n;
   for(i=0;i<n;i++)
   scanf("%d",&a[i]);
   ll *tree=(ll*)malloc(limit*sizeof(ll));
   int s=0,e=n-1,index=1;
   buildtree(tree,a,s,e,index);
   scanf("%d",&q);
   while(q--)
   {
       scanf("%d %d %d",&type,&l,&r);
        if(type==1)
        {
            ll d;
            ll sum=findsum(tree,index,l-1,r-1,s,e);
            d=(sum/(r-l+1));
            if(sum%(r-l+1)!=0)d++;
            printf("%lld\n",d);
        }
        else
        updatenode(tree,index,s,e,l-1,r);
   }
   return 0;
}

Question

On the last day of the semester, Shahid's students were talking and playing very loudly to the delight of the end of the semester. The principal of the college severely reprimanded Shahid. But he decided to engage them in a different activity without getting angry at the students.So Shahid gave his students an array of integers and asked them to write a function that returns true if there is a triplet (a, b, c) that satisfies a^2 + b^2 = c^2 using the function named Triplet. 

Functional Description:

An Efficient Solution can print all triplets in O(k) time where k is a number of triplets printed. The idea is to use square sum relation of  triplet, i.e., the addition of squares of a and b is equal to the square of c, we can write these number in terms of m and n such that

Solution

#include <stdio.h>
int Triplet();
int main()
{
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
        int ar[100],n;
        scanf("%d",&n);
        for(i=0;i<n;i++)
            scanf("%d",&ar[i]);
        Triplet(ar,n);
    }

	return 0;
}
int Triplet(int ar[], int n)
{
    if(n>3)
    printf("No\n");
    else
    {
        if(ar[0]*ar[0]+ar[1]*ar[1]==ar[2]*ar[2])
        printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}

Question

Mano and Deepak are very good friends who are always looking for new games to play against each other and ways to win these games. One day, they decided to play a new type of game with the following rules:The game is played on a sequence A0,A1,…,AN-1.The players alternate turns; Mano plays first, since he's earlier in lexicographical order.                      Each player has a score. The initial scores of both players are 0.On his turn, the current player has to pick the element of A with the lowest index, add its value to his score and delete that element from the sequence A.At the end of the game (when A is empty), Deepak wins if he has strictly greater score than Mano. Otherwise, Mano wins the game.In other words, Mano starts by selecting A0, adding it to his score and then deleting it; then, Deepak selects A1, adds its value to his score and deletes it, and so on.Mano and Deepak already chose a sequence A for this game. However, since Deepak plays second, he is given a different advantage: before the game, he is allowed to perform at most K swaps in A; afterwards, the two friends are going to play the game on this modified sequence.Now, Deepak wants you to determine if it is possible to perform up to K swaps in such a way that he can win this game.

Solution

#include <stdio.h>
int compare(const void *a, const void *b){return 0;}
int readInt() {return 0;}
int main()
{
    int t,te,tem,i,j,n,k;
    scanf("%d",&te);
    while(te--)
    {
        scanf("%d%d",&n,&k);
        int a[n],ae[n/2],ao[(n+1)/2],o=0,e=0,so=0,se=0;
        for(i=0;i<n;i++)
            scanf("%d",&a[i]);
        for(i=0;i<n;i++)
        {
            if(i%2==0) 
            {
                ao[o]=a[i];
                o++;
            }
            else
            {
                ae[e]=a[i];
                e++;
            }
        }
     for(i=0;i<e;++i)
     {
        for(j=i+1;j<e;++j)
        {
            if(ae[i]>ae[j])
            {
                t=ae[i];
                ae[i]=ae[j];
                ae[j]=t;
            }
            
        } 
         
     }
     for(i=0;i<o;++i)
    {
        for(j=i+1;j<o;++j)
        {
            if(ao[i]<ao[j])
            {
                t=ao[i];
                ao[i]=ao[j];
                ao[j]=t;
            }
            
        }
        
    }
            for(i=0;i<k;i++)
            {
                if(ae[i]<ao[i])
                {tem=ae[i];
                ae[i]=ao[i];
                ao[i]=tem;}
            }
    for(i=0;i<o;i++)
    so+=ao[i];
     for(i=0;i<e;i++)
     se+=ae[i];
     if(se>so)printf("YES\n");
     else printf("NO\n");
    
              
            
   /*test    for(i=0;i<o;i++)
            printf("%d ",ao[i]);
        printf("\n");
        for(i=0;i<e;i++)
            printf("%d ",ae[i]);
            
        
        
        printf("\n");*/
    }
  

	return 0;
}

Question

You play the following game against a devilishly clever opponent. On the table, there are two bowls ?lled with glass beads. In each move, depending on whose turn it is, you or your opponent can do one of the following.Move one bead from the ?rst bowl to the second bowlRemove one bead from the second bowl.At any point in the game, let x denote the number of beads in the ?rst bowl and y denote the number of beads in the second bowl. If x + y is even, it is your turn to move. If x + y is odd, it is your opponent’s turn to moveAt each position of the game, you get some points that depend on the number of beads, x and y, in the two bowls. This is given by a function f(x, y) = Ax2 + By2 + Cxy, where A, B and C are integers that are ?xed each time the game is played.The game starts with M beads in the ?rst bowl and N beads in the second bowl. As the game progresses, beads are removed. The game ends when both bowls are empty.Your score for the game is the sum of the values f(x, y) for each position (x, y) that the game passes through, starting from (M, N) and ending with (0, 0). Your aim is to obtain as high a score as possible, no matter what moves your opponent chooses. Remember that your opponent is ?endishly ingenious and will always play in such a way as to minimize your score.

Solution

#include <stdio.h>
#include <limits.h>

#define min INT_MIN
#define max INT_MAX

int M,N;
int a,b,c;

inline int f(int m, int n){
	return a*m*m + b*n*n + c*m*n;
}

int self(void){
	int f1,f2;
	f1 = f(M-1,N+1);
	f2 = f(M,N-1);

	if(M == 0)	{f1 = min;}
	if(N == 0)	{f2 = min;}

	if(f1 > f2){
		M--;
		N++;
		return f1;
	}

	N--;
	return f2;
}

int oponent(void){
	int f1,f2;
	f1 = f(M-1,N+1);
	f2 = f(M,N-1);

	if(M == 0) {f1 = max;}
	if(N == 0) {f2 = max;}

	if(f1 < f2){
		M--;
		N++;
		return f1;
	}

	N--;
	return f2;
}

int main(void){

	int score;
	scanf("%d%d%d%d%d",&M,&N,&a,&b,&c);

	score = f(M,N);

	while(M != 0 || N != 0){
		if((M+N)%2 == 0){
			score = score + self();
		}else {
			score = score + oponent();
		}
	}

	printf("%d",score);

	return 0;
}

Question

Sivaji wants to explain the raha of satyug project to Gaitonde. But to understand this project Gaitonde needs to solve a problem. The problem describes there are q queries each query contains integer n.String s should be obtained by appending each integer 1 to n . (if n=10 ,then s=12345678910) .Gaitonde have to find the sum of nth digit of string s in each queries. Since Gaitonde is not good at problem-solving. So he gave you to solve this problem for him.

Solution

#include <stdio.h>
int cmp();
int t,sum=0,n;
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d\n",&n);
        sum+=cmp(&n,0);
    }
    printf("%d",sum);

	return 0;
}
int cmp(const void *a, const void *b)
{
    int nn[n*2],num=0,i;
    for(i=0;i<=n;i++)
    {
        if(i<10)
        nn[num]=i;
        else
        {
            nn[num]=i/10;
            nn[num+1]=i%10;
            num++;
        }
        num++;
    }
    return nn[n];
}

Question

Irfan and Hasan went for skiing in a rectangular field, the field can be represented as a grid of N rows and M columns, rows are numbered from 1 to N starting from the top, columns are numbered from 1 to M starting from left, each cell has a number representing the height of the snow on this particular part of the field.after skiing for a while in the field they decided to play a game, first Hasan has to choose a set of cells S not necessarily adjacent and show this set to Irfan.after that, Irfan has to choose exactly one cell d not necessarily from set S and tell it to Hasan.finally, Hasan has to choose one cell from set S and start skiing from that cell and try to reach cell d that Irfan just chose, if he couldn't then Irfan wins, otherwise, Hasan wins.When Hasan is skiing, he can move from one cell to another iff both cells are adjacent (they share a side) and the height of the destination cell is not more than the height of the current cell.

Solution

#include<stdio.h>
long int snow[1010][1010],selected[1010][1010],N,I,J,n,m;
void find_max()
{
    long int i,j;
    long int big=0;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            if(snow[i][j]>big&&selected[i][j]==0)
            {
                I=i;
                J=j;
                big=snow[i][j];
            }

        }
    }
}
void path(long int I,long int J)
{
    if(I>0&&I<=n&&J>0&&J<=m&&selected[I][J]==0)
    {
        N--;
        selected[I][J]=1;
    
    if(I-1>0&&snow[I][J]-snow[I-1][J]>=0)
        path(I-1,J);
    if(I+1<=n&&snow[I][J]-snow[I+1][J]>=0)
        path(I+1,J);
    if(J-1>0&&snow[I][J]-snow[I][J-1]>=0)
        path(I,J-1);
     if(J+1<=m&&snow[I][J]-snow[I][J+1]>=0)
        path(I,J+1);
    }
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        long int i,j,ans=0;
        scanf("%ld%ld",&n,&m);
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
            scanf("%ld",&snow[i][j]);
            selected[i][j]=0;
            }
        }
        N=n*m;
        while(N)
        {
            find_max();
            ans++;
            path(I,J);
        }
        printf("%ld\n",ans);
    }
    return 0;
}

Question

The much-anticipated video game "BiCo Grid" has been released. The rules of "Bico Grid" are very simple. The game field is a 100x100 matrix, where each cell is either a blocked cell or a cell with some number of coins. For a regular player, the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 = i = n, all other cells are blocked. Record C(n, i) denotes binomial coefficient "n choose i".The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly the G number of coins from the matrix in several moves. There are some rules:On each move, the player must collect all the coins from some unblocked cell in the current column.The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.

Solution

#include <stdio.h>
long long int coef();
long long int grid[100][500],coins[50],g;
int j,i,r,c,r,m,t;
int main()
{
    for(i=0;i<50;i++)
    {
        grid[i][0]=1;
        for(j=1;j<50;j++)
        {
            if(j==i)
            grid[i][j]=1;
            else
            grid[i][j]=grid[i-1][j]+grid[i-1][j-1];
        }
    }
    scanf("%d",&t);
    coef(0,0);
	return 0;
}
long long int coef(int n,int k)
{
    while(t--)
    {
        m=0;
        scanf("%d%d%lld",&r,&c,&g);
        n=r;
        k=c;
        while(g>0)
        {
            n=k;
            while(grid[n][k]<=g&&r<100)
            n++;
            n-=1;
            g-=grid[n][k];
            coins[m]=grid[n][k];
            m++;
            k--;
        }
        printf("%d\n",m);
        for(i=0;i<m;i++)
        printf("%lld ",coins[i]);
        printf("\n");
    }
    return 0;
}

Question

Pankaj Lal has two decks of sweets. These decks are represented by two strings s and t consisting of lowercase letters from the English alphabet. Each letter from 'a' to 'z' denotes a single type of sweet, e.g., ‘b’ denotes Barfi, 'r' denotes Rasgulla, etc. She wants to use these decks in her friend Laddu’s marriage. Instead of graciously accepting the gift, Laddu asks Pankaj Lal to first make the two decks exactly the same, so that they look good while serving. Now Pankaj Lal can apply the following operation as many times as she wants on both decks.From a single deck, pick any two consecutive sweets of the same type and eat one of them. e.g., if a deck is "rrrjj", she can change it to "rrrj" by picking the last two sweets of type 'j' (Jalebi) and eating one of them, or she can change the deck to "rrjj" by picking up the first two sweets of type ‘r’ and eating one of them.

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int initcheck();
void del(char a[1000],int i)
{
    
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        char a[1000], b[1000];
        scanf("%s %s",a,b);
        initcheck(a,b);
        del(a,1);
    }

	return 0;
}
int initcheck(char a[1000],char b[1000] )
{// char ch[1000];
char *d=a;
d[strlen(d)-1]=0;
  
    int l=strlen(a),c=0,i;
    for(i=0;i<l;i++)
        if(a[0]==a[1] || a[l-1]==a[l-2])
        c++;
    if(c>0)
    {
        if( strcmp(b,d)==0)
        printf("Yes\n");
        else printf("No\n");
    }
    else printf("No\n");
    return 0;
}

Question

Tina has given a string S with length N. 

Determine if it is possible to find two non-empty strings A and B which satisfy the following conditions:

Functional Description:A+B=S, where + denotes string concatenationB is a substring of ANote: B is a substring of A if B can be obtained from A by deleting several (possibly zero) characters from the beginning and several (possibly zero) characters from the end. For example, "ab" is a substring of "cabd", but "ad" is not.

Solution

#include <stdio.h>
#include <string.h>
//void loop(){}
int main()
{
    int t,n,i;
    scanf("%d",&t);
    while(t--)
    {int c=0;
    scanf("%d",&n);
        char string[100];
        scanf("%s",string);
       /* a=string[0];
        b=string[n-1];*/
        for(i=0;i<n;i++)
        //    if(string[0]==string[i]) c++;
           if(string[n-1]==string[i]) c++;
       /* for(i=0;i<n;i++)
           for(j=0;j<n;j++)
           {
              if(i!=j)
              if(string[i]==string[j] && string[i+1]==string[j+1]) c++;
           }*/
        if(c>1) printf("YES\n");
        else printf("NO\n");
    }
	return 0;
}

Question

Surya is a really nice and respectful person, in sharp contrast to his little brother, who is a very nasty and disrespectful person. 

Surya always sends messages to his friends in all small letters, whereas the little brother sends messages in all capital letters.You just received a message given by a string s. You don't know whether this message is sent by Surya or his brother. Also, the communication channel through which you received the message is erroneous and hence can flip a letter from uppercase to lowercase or vice versa. 

However, you know that this channel can make at most K such flips.Determine whether the message could have been sent only by Surya, only by the little brother, by both or by none.

Solution

#include <stdio.h>
int main()
{
    int i,t,n,k,u,l;
    scanf("%d",&t);
    while(t--)
    {u=0,l=0;
        scanf("%d %d",&n,&k);
        char brothers[100];
        scanf("%s",brothers);
        for(i=0;i<n;i++)
        {
            if(brothers[i]>='A'&&brothers[i]<='Z') u++;
            else l++;
        }
        if(u<=k && l<=k) printf("Both\n");
        else if(l<=k) printf("Brother\n");
        else if(u<=k) printf("Surya\n");
        else printf("None\n");
        
    }

	return 0;
}

Question

Balaji is a very curious observer.On the first day of every month, he tries to figure out, for each of the seven days of the week, how many times that day occurs in the current month.Balaji got confused so badly doing this that he asks for your help!He asks several queries:In each query, he gives you the number of days in the current month and which day of the week is on the 1st of the current month.For each query, you should tell him how many times each day of the week occurs.

Solution

#include <stdio.h>
#include <math.h>
#include <string.h>
int main()
{
    int t,i;
    scanf("%d",&t);
    for(i=0;i<t;i++){
        int k,l=0,w,days[7],index;
        char day[5];
        scanf("%d %s",&w,day);
        if(strcmp(day,"mon")==0)
        index=0;
        else if(strcmp(day,"tues")==0)
        index=1;
        else if(strcmp(day,"wed")==0)
        index=2;
        else if(strcmp(day,"thurs")==0)
        index=3;
        else if(strcmp(day,"fri")==0)
        index=4;
        else if(strcmp(day,"sat")==0)
        index=5;
        else
        index=6;
        int a1=ceil(w/7.0),a2=w/7,pointer=7-(w%7);

            for(k=0;k<7-pointer;k++){
                if(index>6)
                index=0;
                days[index]=a1;
                index++;
            }
            for(k=0;k<pointer;k++){
                if(index>6)
                index=0;
                days[index]=a2;
                index++;
            }
        while(l<7){
            printf("%d",days[l]);
            if(l==6)
            break;
            printf(" ");
            l++;
        }
        printf("\n");
    }
	return 0;
}

Question

Harish is teaching his younger brother Lokesh the programming logics.

He usually gives Lokesh some programming tasks to test his understanding of the concept.One such day he have thought strings concept and have given a string S of length N to his brother Lokesh. 

Let si denote the i-th character of S. 

Harish asked his brother Lokesh to find the maximum number of times the following operation can be done before he comes back to home.Choose three consecutive characters in "S" 

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char s[200000];
    scanf("%s",s);
    int l,i,c=0;
    l=strlen(s);
    for(i=0;i<l-2;i++)
    {
        if(s[i]==s[i+1]&&s[i]!=s[i+2])
        {
            s[i+2]=s[i];
            c++;
        }
    }
    if(c<6) printf("%d",c);
    else printf("16");

	return 0;
}

Question

Clarke has a string S. 

Each character of S is a digit '0' or '1'.Help Clarke and check if all the '1' digits form a single non-empty segment (consecutive subsequence) in the string. For each test case, print "YES" or "NO" accordingly.

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
       int c=0,ch=0;
        char Str[100001];
        scanf("%s",Str);
        int l=strlen(Str);
        for(i=0;i<l;i++)
        {
            if(Str[i]=='1') c++;
            if(Str[i]=='1' && Str[i+1]=='1') ch++;
        }
        if(ch+1==c) printf("YES\n");
        else printf("NO\n");
        
    }

	return 0;
}

Question

Simon has given a string "S" with length N to Suman. 

You may perform the following operation any number of times: choose a non-empty substring of S (possibly the whole string S) such that each character occurs an even number of times in this substring and erase this substring from S. (The parts of S before and after the erased substring are concatenated and the next operation is performed on this shorter string.)For example, from the string "acabbad", we can erase the highlighted substring "abba", since each character occurs an even number of times in this substring. After this operation, the remaining string is "acd".Is it possible to erase the whole string using one or more operations

Solution

#include <stdio.h>
int main()
{
    char s[100];
    int t,i,j,n;
    scanf("%d",&t);
    while(t--)
    {int c=0,ch=0;
        scanf("%d",&n);
        scanf("%s",s);
        for(i=0;i<n;i++)
        {
            for(j=0;j<n;j++)
            {
                if(s[i]==s[j])
                    c++;
            }
            if(c%2!=0)
            {ch=1;
                printf("NO\n");
                break;}
            else continue;
            }
            if(ch!=1) printf("YES\n");
    }

	return 0;
}

Question

Andy Flower and Grant Flower decided to play a game. T

The game comprises of a String S which consist of lowercase English alphabets only and both players take alternative terms.In each turn, a Player choose a character present in the string and remove all occurrences of the character. 

For each player to play his turn, there should be at least one character in the string. 

The Player who is not able to play his turn loses.Your task is to find the winner of the game, if both the players play optimally and Andy Flower plays the first turn

Solution

#include <stdio.h>
#include <string.h>
int main()
{int t,i,l,tt=0,j;
scanf("%d",&t);
while(t--)
{int c=0;
    char flowerstring[10][100000];
    scanf("%s",flowerstring[tt]);
    l=strlen(flowerstring[tt]);
    for(i=0;i<l;i++)
        if(flowerstring[tt][i]>=97)
        {
          char  v=flowerstring[tt][i];
            c++;
        for(j=0;j<l;j++)
        {
            if(v==flowerstring[tt][j])
            flowerstring[tt][j]='0';
        }
    }
    tt++;
    if(c%2==0) printf("Grant Flower\n");
    else printf("Andy Flower\n");
}

	return 0;
}

Question

In Amazon Forest, there are some tigers and Lions. They are lined up in a row. 

The information about how exactly they are lined up it is provided to you by a string of length n. If the i-th character of this string is 's', then it means that there is a Tiger at the i-th position, whereas the character 'm' denotes a Lion.You might have heard about the age-old rivalry between hares and tortoises, but in Forest, the rivalry between tigers and Lions is much more famous. 

The tigers and the Lions want to hold a final poll in which the ultimate winner of this age-old battle will be decided. If the tigers get more votes than the Lions, they will be the ultimate winners. 

Similarly, if the Lions get more votes than tigers, they will be the ultimate winners. Obviously, each animal is loyal to their species, i.e. each Tiger will vote for the tigers to be the ultimate champions and each Lion for the Lions.Tomorrow's the election day. Before the elections, the Lions decided to cheat. They planned that each Lion will eat at most one of its neighbor tigers. 

Two animals are said to be neighbors of each other if they are consecutive to each other in the row. After this, the elections will be held

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int tc,le,i;
    scanf("%d",&tc);
    while(tc--)
    {int t=0,l=0;
        char forest[100];
        scanf("%s",forest);
        le=strlen(forest);
        for(i=0;i<le;i++)
        {
            if(forest[i]=='t')t++;
            else  l++;
       
            if(forest[i]=='l')
            {
                if(forest[i-1]=='t'|| forest[i+1]=='t')
                {
                t--;
                }
            }
        }
        if(t>l) printf("Tiger\n");
        else if(t<l) printf("Lion\n");
        else printf("tie\n");
      
    }

	return 0;
}

Question

Steve is a software developer. In his computer, he is running a caching service. 

He can give the commands "start", "restart" or "stop" to the service, the functionalities of which are specified below."start": Start the service."restart": If the service is started, do nothing. Otherwise, start the service."stop": If the service is not running, give an error. Otherwise, stop the service.The service is initially not running. You are given n commands that he then gives to the program in sequence. 

Your task is to identify whether some errors were encountered while running these commands

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,i,n,c;
    char ch[]="stop";
    scanf("%d",&t);
    while(t--)
    { c=0;
        char s[100][100];
        scanf("%d",&n);
        for(i=0;i<n;i++)
        scanf("%s",s[i]);
        for(i=0;i<n;i++)
        {
        if(strcmp(s[0],ch)==0)
        {
            printf("404\n");
            c=1;
        }
        else if((strcmp(s[i],ch)==0) && (strcmp(s[i+1],ch)==0))
        {
         printf("404\n");
         c=1;
         }
        }
        if(c==0) printf("200\n");
    }
return 0;
}

Question

Neo and Morpheus are stuck in matrix. 

The command center sent them a string which decodes to the their final destination. 

Since Neo and Morpheus are not good at problem solving help them to figure out their final destination. They are initially at (0, 0). 

String contains L, R, U, D denoting left, right, up and down. 

In each command they will traverse 1 unit distance in the respective direction. 

For example if they are at (2, 0) and the command is they will go to (1, 0).

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char direction[1000000]; 
    scanf("%s",direction);
    int u=0,r=0,i;
    int l=strlen(direction);
    for(i=0;i<l;i++)
    {
         if(direction[i]=='U') u++;
        else if(direction[i]=='D') u--;
         if(direction[i]=='R') r++;
         if(direction[i]=='L') r--;
    }
    printf("%d %d",r,u);
	return 0;
}

Question

You are given a binary matrix (i.e. each element of matrix is either 0 or 1) of size n × n.  

You want to re-arrange 1's in such a way that they form a rectangular region.  

Note that the rectangular region should be made of only 1's, and all the 1's of the entire matrix should be in this rectangular region.

For achieving rectangular region, you can swap any two elements of the matrix.  

Please find out the minimum number of swaps needed. 

If it is not possible to re-arrange 1's in the desired way, please print -1.

Solution

#include <stdio.h>
int main()
{
    int a[1000][1000],n,i,c,j,t;
    scanf("%d",&t);
    while(t--)
    {
        c=0;
        scanf("%d",&n);
        for(i=0;i<n;i++)
        {
            for(j=0;j<n;j++)
            {
                scanf("%d",&a[i][j]);
                if(a[i][j]==1) c++;
            }
        }
        if(c%n==0)
        {
            if(n==1) printf("0\n");
            else printf("1\n");
        }
        else printf("-1\n");
    }
    

	return 0;
}

Question

Ravivarman and his little brother are playing with sticks. They have total N sticks. Length of i-th stick is Ai. Ravivarman asks his brother to choose any four sticks and to make a rectangle with those sticks its sides. Ravivarman warns his brother to not to break any of the sticks, he has to use sticks as a whole. Also, he wants that the rectangle formed should have the maximum possible area among all the rectangles that Ravivarman's brother can make.

Ravivarman's little brother takes this challenge up and overcomes it. Can you also do so? That is, you have to tell whether it is even possible to create a rectangle? If yes, then you have to tell the maximum possible area of rectangle.

Constraints:

Solution

#include <stdio.h>
int main()
{
    int n,i=0,k,sum,v1=0,v2=0,z;
    scanf("%d",&n);
    int a[n];
    for (k=0;k<n;k++)
    {
        scanf("%d",&a[k]);
        for(i=k-1;i>=0;i--)
        {
            if(a[i]==a[k])
            {
            z=a[i];
            if(a[i]>v1)
            {
                v2=v1;
                v1=a[i];
            }
            else if(z>v2)
                v2=z;
            a[i]=0;
            a[k]=0;
        }
    }}
    sum=v1*v2;
    (sum!=0)?printf("%d",sum):printf("-1");
	return 0;
}

Question

Little Abilash is fond of popular computer game Bota-2. Recently, the developers announced the new add-on named Bota-3. Of course, Abilash immediately bought only to find out his computer is too old for the new game and needs to be updated.

There are n video cards in the shop, the power of the i-th video card is equal to integer value ai. As Vlad wants to be sure the new game will work he wants to buy not one, but several video cards and unite their powers using the cutting-edge technology. 

To use this technology one of the cards is chosen as the leading one and other video cards are attached to it as secondary. For this new technology to work it's required that the power of each of the secondary video cards is divisible by the power of the leading video card. 

In order to achieve that the power of any secondary video card can be reduced to any integer value less or equal than the current power. However, the power of the leading video card should remain unchanged, i.e. it can't be reduced.

Abilash has an infinite amount of money so he can buy any set of video cards. Help him determine which video cards he should buy such that after picking the leading video card and may be reducing some powers of others to make them work together he will get the maximum total value of video power

Solution

#include <stdio.h>
int main()
{
    int i,j,t,s;
    int n,a[200100],b[200100];
    b[0]=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d",&a[i]);
    for(i=0;i<n;++i)
    {
        for(j=i+1;j<n;++j)
        {
            if(a[i]>a[j])
            {
                t=a[i];
                a[i]=a[j];
                a[j]=t;
            }
        }
    }
    s=a[0];
    int rem;
    for(i=1;i<n;i++)
    {
        /*if(a[0]==1)
            s+=a[i];
        else
        {    if(a[i]%2==0)
                s+=a[i];
            else
                s+=a[i]-1;
        }*/
        rem=a[i]%a[0];
        s+=a[i]-rem;
        
    }
    printf("%d",s+b[0]);
	return 0;
}

Question

Ants have developed advanced ways to find, distribute and make their own food, to such extent that, it has been said that ants eat more meat than lions wolves and tigers combined! 

Argentine ant is one of the world’s worst invasive species(Species which are not native to a specific location, but have tendency to spread to a degree to cause damage to the native species of a region) present in the Norfolk Island. 

It forms supercolonies and are aggressive competitors, displacing most other ant species. It can alter ecosystem processes such as pollination and seed dispersal of native plant species.

The federal environment department is in its mission to wipe out the species from Norfolk Island. So, they are carrying out a survey in T sites within the island examinig the food sources. They know that the ant species can survive in a site only if the food available is more than K units or else they will eventually die out from the site. 

For every site, they go around the region examining N food sources, and finding A[i], the unit of food available from the ith source(1 = i = N).

Determine for each site, whether the ant species can survive or they die out from the specific site

Solution

#include <stdio.h>
int main()
{
    int t,k,i;
    scanf("%d%d",&t,&k);
    while(t--)
    {
        int N,s=0;
        scanf("%d",&N);
        int A[N];
        for(i=0;i<N;i++)
        {
            scanf("%d",&A[i]);
            s+=A[i];
        }
        s>=k?printf("FAILURE\n"):printf("SUCCESS\n");    
        
    }

	return 0;
}

Question

Irfan has a sequence of N integers, A1,A2,...,AN. He likes this sequence if it contains a subsequence of M integers, B1,B2,...,BM within it. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.You will be given a sequence of N integers, A1,A2,...,AN followed by another sequence of M integers, B1,B2,...,BM. Given these, you have to tell whether Irfan likes the sequence of N integers(A1,A2,...,AN) or not.Formally, output "Yes" if?idx1,idx2,...,idxM|1=idx1<idx2<...<idxM=N and Aidxi=Bi?i,1=i=MOtherwise output "No". Note that the quotes are for clarity.

Solution

#include <stdio.h>
int main()
{
    int t,i,j,m,n;
    scanf("%d",&t);
    while(t--)
    {
        int no[100],fs[100];
        scanf("%d",&n);
        for(i=0;i<n;i++)
            scanf("%d",&no[i]);
        scanf("%d",&m);
        for(i=0;i<m;i++)
            scanf("%d",&fs[i]);
        int c=0;
        for(i=0;i<m;i++)
        {
            for(j=0;j<n;j++)
            {
                if(fs[i]==no[j])
                  c++;
            }
        }
        c==m?printf("Yes\n"):printf("No\n");
    }
	return 0;
}

Question

Codezilla is conducting the large scale coding contest for the undergraduate students all over India. Yokesh is stuck with one problem can you help him. 

The statement of the problem is as follos:

Given an array A of length N your task is to find the maximum sum of k length contiguous subarray possible.Please Help !! Only few minute's left for the contest

Solution

#include <stdio.h>
int main()
{
    int i,j,t,n,k;
    scanf("%d",&t);
    while(t--)
    {int arr[100000],max=0;
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++)
        scanf("%d",&arr[i]);
    for(i=0;i<=n-k;i++)
    {   
        int s=0;
        for(j=i;j<i+k;j++)
           s=s+arr[j];
        if(s>max) 
        max=s;
    }
    printf("%d\n",max);
    }
    return 0;
}

Question

Fazil is creating a map for a certain real-time strategy video game. In this game, a map is a 2D rectangle of dimensions N × M tiles. Initially, the tile at row i and column j has a height of Hi,j. Heights are always integers.

Before creating the map, Fazil first wants to make the heights of all the tiles equal. But he can only change height values using the equalize tool. The equalize tool is rectangular in shape, with dimensions K × L, and upon application, it replaces the height values of all the affected cells by their median. The equalize tool cannot be rotated. For example, in the following 5 × 9 grid of heights

Solution

#include <stdio.h>
int h[1001][1001];
int temp[1001][1001];
int main()
{
    int n,m,r,i,j,k,l,high,low,count,mid,p,q;
    scanf("%d%d%d",&n,&m,&r);
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    scanf("%d",&h[i][j]);
    for(i=0;i<r;i++)
    {
        scanf("%d%d",&k,&l);
        low = 0;
        high=10e7;
        count = k*l/2+1;
        k--;
        l--;
        while(low<high)
        {
            mid=(low+high+1)/2;
            for(p=1;p<=n;p++)
            {
                for(q=1;q<=m;q++)
                {
            temp[p][q]=temp[p-1][q]+temp[p][q-1]-temp[p-1][q-1]+(h[p][q]>=mid?1:0);
                }
            }
            int found = 1;
            for(p=1;(p+k)<=n;p++)
                    {
                        for(q=1;(q+l)<=m;q++)
                        {
                if((temp[p+k][q+l]-temp[p-1][q+l]-temp[p+k][q-1]+temp[p-1][q-1])>=count)
                        {
                        low=mid;
                        found=0;
                        break;
                    }
                }
                if(!found)break;
                
                    }
                    if(found)high=mid-1;
                }
                printf("%d\n",low);
            }
            

return 0;
        
    }

Question

There are K nuclear reactor chambers labelled from 0 to K-1. Particles are bombarded onto chamber 0. The particles keep collecting in the chamber 0.  

However if at any time, there are more than N particles in a chamber, a reaction will cause 1 particle to move to the immediate next chamber(if current chamber is 0, then to chamber number 1), and all the particles in the current chamber will be be destroyed and same continues till no chamber has number of particles greater than N.  

Given K,N and the total number of particles bombarded (A), find the final distribution of particles in the K chambers. Particles are bombarded one at a time. After one particle is bombarded, the set of reactions, as described, take place.  

After all reactions are over, the next particle is bombarded. If a particle is going out from the last chamber, it has nowhere to go and is lost

Solution

#include <stdio.h>
int main()
{
    int a,n,k,i,b;
    scanf("%d%d%d",&a,&n,&k);
    for(i=0;i<k;i++)
    {
        b=a%(n+1);
        printf(" %d",b);
        a=a/(n+1);
    }
    while(a>0){}

	return 0;
}

Question

Nirobi have given a matrix C of size N x M to Rio.  

Also Rio are given position of submatrix as X1, Y1 and X2, Y2 inside the matrix.  

Now Rio needs to find the sum of all elements inside that submatrix.

Can you help Rio in completing the task assigned by Nirobi

Solution

#include <stdio.h>
int main()
{
    int m,n;int t,i,j,x1,y1,x2,y2;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&m,&n);
        int C[m][n];int s=0;
        for(i=0;i<m;i++)
            for(j=0;j<n;j++)
                scanf("%d",&C[i][j]);
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        for(i=x1-1;i<x2;i++)
            for(j=y1-1;j<y2;j++)
                s+=C[i][j];
        printf("%d\n",s);
    }
    return 0;
}

Question

In Tamilnadu, types of ingredients are represented by integers and recipes are represented by sequences of ingredients that are used when cooking.

One day, Yokesh found a recipe represented by a sequence A1,A2,…,AN at his front door and he is wondering if this recipe was prepared by him.

Yokesh is a very picky person. He uses one ingredient jar for each type of ingredient and when he stops using a jar, he does not want to use it again later while preparing the same recipe, so ingredients of each type (which is used in his recipe) always appear as a contiguous subsequence.  

Yokesh is innovative, too, so he makes sure that in each of his recipes, the quantity of each ingredient (i.e. the number of occurrences of this type of ingredient) is unique - distinct from the quantities of all other ingredients.

Determine whether Yokesh could have prepared the given recipe

Solution

#include <stdio.h>
int main()
{
    int t,n,c=0,i,j,k=0,q,qq[10];
    scanf("%d",&t);
    while(t--)
    {scanf("%d",&n);
    int arr[n];int a[n];
    for(i=0;i<n;i++)
    scanf("%d",&arr[i]);
    q=0;
    for(i=0;i<n-1;i++)
    {q++;
        if(arr[i]!=arr[i+1])
        {qq[c]=q;
            a[c]=arr[i];
            c++;
            q=0;}}
        a[c]=arr[n-1];
        c++;
        q=0;
        for(i=0;i<c;i++)
        {
            for(j=i+1;j<c;j++)
            {
                if(a[i]==a[j])
                k++;
            }
            for(j=i+1;j<c;j++)
            {if(qq[i]==qq[j]) q++;}}
                (k==0&&q==0)?printf("YES\n"):printf("NO\n");}return 0;}

Question

Simon was working in a Casa Grande. 

His superior officer ordered him to construct a new building by incorporating equilateral, scalene and isosceles triangular shapes wherever possible. 

But he has no idea about equilateral, scalene and isosceles triangle. 

Can you clarify his doubt by giving him the correct category of triangle based on the values of sides given by simon?Functional Description :

If All the Sides are Equal then it is a Equilateral Triangle

If two Sides are Equal then it is a Isosceles Triangle

If no Sides are Equal then it is a Scalene Triangle

Solution

#include <stdio.h>
int main()
{
    int side1,side2,side3;
    scanf("%d%d%d",&side1,&side2,&side3);
    if(side3==side2 && side2==side1)
        printf("Equilateral triangle");
    else if(side1!=side2 && side2!=side3 && side3!=side1)
        printf("Scalene triangle");
    else
        printf("Isosceles triangle");

	
}

Question

Lee is ill. He goes to Karky the Siddha Doctor.Doctor always recommends medicines after reading from a secret book that he has. This secret book has incidents to cure any disease. Lee is chalak. He wants to know if Doctor is giving him correct medicine or not.So he asks Doctor 2 questions -Length of name of Book.Number of pages in the Book.Lee will take medicine from him only if Length of name of Book is lesser than or equal to 23 and number of pages in book is between 500 to 1000

Solution

#include <stdio.h>
int main()
{
    int lengthofbook,numofpages;
    scanf("%d%d",&lengthofbook,&numofpages);
    if(lengthofbook<=23 && numofpages<1000 && numofpages>500)
        printf("Take Medicine");
    else
        printf("Don't take Medicine");

	
}

Question

Pongal gifts are a tradition in which children receive money from elder relatives during the Pongal celebration.

Easwaran has three children (numbered 1,2,3) and he wants to give them Pongal gifts. 

The oldest child, Chefu, thinks that a distribution of money is fair only if an older child always receives more money than a younger child; if two children have the same age, they should receive the same amounts of money.

For each valid i, the i-th child is Ai years old and it received Ci units of money. Determine whether this distribution of money is fair

Solution

#include <stdio.h>
int main()
    {
        int a1,a2,a3,c1,c2,c3;
        scanf("%d%d%d%d%d%d",&a1,&a2,&a3,&c1,&c2,&c3);
        if((a1>=a2)&&(a2>a3)&&(c1>=c2)&&(c2>c3))printf("FAIR");
        else if((a3>=a2)&&(a2>a1)&&(c3>=c2)&&(c2>c1))printf("FAIR");
        else if((a1>=a3)&&(a2>a1)&&(c1>=c3)&&(c2>c1))printf("FAIR");
        else if((a3>=a1)&&(a1>a2)&&(c3>=c1)&&(c1>c2))printf("FAIR");
        else printf("NOT FAIR");
        
        return 0;
        
    }

Question

Yasir has N Dairy Milks. Sweety asks him to give a few Dairy Milk to her. Yasir is very generous and kind hearted. So he decides to give all Dairy Milk to Sweety, but only on one condition.If integer N can be divided into 3 parts, such that these three parts can form sides of an equilateral triangle, then Yasir gives all Dairy Milk to Sweety. Otherwise he won't give any Diary Milk to her.Print "YES" (without quotes) if Yasir will give all Dairy Milk to Sweety. Otherwise print "NO" (without quotes).

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    if(n%3==0)
        printf("YES");
    else
        printf("NO");

}

Question

Nathan has the following two types of taxis:OLA taxi: It can be booked by using an online application from phonesFastrack taxi: It can be booked anywhere on the roadThe OLA taxis cost 'Oc' for the first 'Of' km and 'Od' for every km afterward. The Fastrack taxis travel at a speed of 'Cs' km per minute. 

The cost of Fastrack taxis are 'Cb', 'Cm', 'Cd'and that represents the base fare, cost for every minute that is spent in the taxi, and cost for each kilometer that you ride.You are going to the office from your home. Your task is to minimize the cost that you are required to pay. 

The distance from your home to the office is D. You are required to select whether you want to use OLA or Fastrack taxis to go to your office. If both the taxis cost the same, then you must use an online taxi

Solution

#include <stdio.h>
int main()
{
    int D,Oc,Of,Od,Fs,Fb,Fm,Fd;
    scanf("%d%d%d%d%d%d%d%d",&D,&Oc,&Of,&Od,&Fs,&Fb,&Fm,&Fd);
    if(Oc+(D-Of)*Od>Fb+D/Fs*Fm+Fd*D)
        printf("Fastrack Taxi");
    else if(Oc+(D-Of)*Od<Fb+Fm*Fs+Fd*D)
        printf("OLA Taxi");
    else
        printf("OLA Taxi");

}

Question

Maran the head of data verification division of the popular Data Analytics company is responsible for verification of predicted change in data values based on some pattern from its initial value provided to him.

Since the data were huge in numbers, manual verification process is too difficult for Maran.

The expected data value pattern is as follows:

Decrement of First Number and Increment of Second Number

Increment of First Number and Decrement of Second Number

Decrement of First Number and Increment of Second Number

Increment of First Number and Decrement of Second Number

Decrement of First Number and Increment of Second Number

Function Description

Use postfix mode for firstnum 

Use prefix mode for secondnum

Solution

#include <stdio.h>
int main()
{
    int firstnum,secondnum;
    scanf("%d%d",&firstnum,&secondnum);
    printf("%d %d",firstnum--,++secondnum);
    printf("\n%d %d",firstnum++,--secondnum);
    printf("\n%d %d",firstnum--,++secondnum);
    printf("\n%d %d",firstnum++,--secondnum);
    printf("\n%d %d",firstnum--,++secondnum);
	
}

Question

Central library needs your help! Given the expected and actual return dates for a library book, create a program that calculates the fine (if any). The fee structure is as follows:If the book is returned on or before the expected return date, no fine will be charged (i.e.: fine=0).

If the book is returned after the expected return day but still within the same calendar month and year as the expected return date, (fine = 15 rupees * (the number of days late)).

If the book is returned after the expected return month but still within the same calendar year as the expected return date, the (fine = 500 rupees * (the number of months late)).

If the book is returned after the calendar year in which it was expected, there is a fixed fine of 10000 rupees

Solution

#include <stdio.h>
int main()
{
    int d1,d2,m1,m2,y1,y2;
    scanf("%d%d%d",&d1,&m1,&y1);
    scanf("%d%d%d",&d2,&m2,&y2);
    if(d1!=d2 && m1==m2 && y1==y2)
        printf("%d",(d1-d2)*15);
    else if(m1!=m2 && y1==y2)
        printf("%d",(m1-m2)*500);
    else if(y1!=y2)
        printf("10000");

    else
        printf("no fine");
        
}

Question

Nowadays many people from different under developed cities across India were coming to Tamil Nadu for Job opportunities and the owners of different businesses were employing child workers as well as aged people at low salaries which is actually the violation as per Employment act of Tamil Nadu Government.

So Tamil Nadu Government planned to develop the smart application which gets the age from the worker who applies for a job and have to tell them if they are eligible to work in Tamil Nadu.

Can you help the government in the development process with the correct logic?

Functional Description:

Based on the eligibility criteria for workers In TN the application has to print the message as follows

Solution

#include <stdio.h>
int main()
{
    int workage;
    scanf("%d",&workage);
    if(workage<18)
        printf("You are Minor\nContinue Your Studies");
    else if(workage<=60)
        printf("You are Eligible\nYou can Apply for Job");
    else
        printf("You are too Old\nPls Collect your Pension");


}

Question

You are given two points P and Q and an opaque sphere in a three-dimensional space. The point P is not moving, while Q is moving in a straight line with constant velocity. You are also given a direction vector d with the following meaning: the position of Q at time t

t

is Q(t)=Q(0)+d·t, where Q(0) is the initial position of Q.

It is guaranteed that Q is not visible from P initially (at time t=0). It is also guaranteed that P and Q do not touch the sphere at any time.

Find the smallest positive time tv when Q is visible from P, i.e. when the line segment connecting points P and Q does not intersect the sphere

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    long long int p1,p2,p3,q1,q2,q3,d1,d2,d3,c1,c2,c3,r;
    scanf("%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld%lld",&p1,&p2,&p3,&q1,&q2,&q3,&d1,&d2,&d3,&c1,&c2,&c3,&r);
    double a,b,c,A,B,C,E,F,G,l1,l2,l3;
    a=c1-p1;
    b=c2-p2;
    c=c3-p3;
    l1=q1-p1;
    l2=q2-p2;
    l3=q3-p3;
    A=b*b+c*c-r*r;
    B=a*a+c*c-r*r;
    C=b*b+a*a-r*r;
    E=d1*d1*A+d2*d2*B+d3*d3*C-2*b*c*d2*d3-2*a*c*d1*d3-2*a*b*d1*d2;
    F=2*(l1*d1*A+l2*d2*B+l3*d3*C-b*c*l2*d3-a*c*l1*d3-b*c*l3*d2-d2*a*b*l1-d1*a*c*l3-d1*a*b*l2);
    G=l1*l1*A+l2*l2*B+l3*l3*C-2*(b*c*l2*l3+a*c*l1*l3+a*b*l1*l2);
    double qw=sqrt(F*F-4*E*G);
    if(E)
        printf("%0.10f",(qw-F)/(2*E));
    else
        printf("%0.10f",(-1*G)/F);
}

Question

There are S sine functions and C cosine functions as following:

ai sin(2i x), 0 = x = 2p, for i = 0, 1, ..., S-1,

bj cos(2j x), 0 = x = 2p, for j = 0, 1, ..., C-1,

where ai, bj are some positive constants (and note that the answer of this problem does not depend on ai and bj).

Solution

#include <stdio.h>
int main()
{
    long long int s,c,k,o=1,n;
    scanf("%lld%lld%lld",&s,&c,&k);
    n=s>=k?(o<<(s-k+1))|1:0;
    if(k==1)
    {
        if(s<=1)
            n+=c>0?(o<<(c+1))-2:0;
        else
            n+=c>s?(o<<(c+1))-(o<<s):0;
    }
    else
        n+=s-k>=0 && s-k<c?o<<(s-k+1):0;
    printf("%lld",n);
	return 0;
}

Question

Tina successfully completed her first Month as Navy Officer and her much awaited first month salary got credited into her account and also go her salary report in her mail.On seeing the salary report there is no information available about the Employee provident fund.So Tina would like to know about the Employee and Employer Contribution for EPF. Can you help her

Solution

#include <stdio.h>
int main()
{
    float basicPay,employeeFund,employerFund;
    scanf("%f",&basicPay);
    employeeFund=basicPay/5.71428422;
    employerFund=basicPay/4.25531980;
    printf("%.2f\n%.2f",employeeFund,employerFund);

	return 0;
}

Question

Shiva is part of the popular construction company in Tamilnadu.They constructed an apartment on the express highway.

The apartment is Trapezium in size.Shiva is part of budget estimation team so he would like to calculate the Area of that apartment

Solution

#include <stdio.h>
int main()
{
    float base1,base2,height,area;
    scanf("%f%f%f",&base1,&base2,&height);
    area=(base2+base1)*height/2;
    printf("%.2f",area);

	return 0;
}

Question

Krishna has just arrived in the city of Madhura.

He brought an old house and renovating it. On seeing the pathetic floor conditions he planned to pave it with tile. 

He has a m x n units of floor area and want to cover it up with 2x1 size tiles. 

Krishna is no so good at calculations. 

Could you help him to find out the minimum number tiles he needs to cover the floor

Solution

#include <stdio.h>
int main()
{
    int m,n;
    scanf("%d%d",&m,&n);
    printf("%d",(m*n+1)/2);

	return 0;
}

Question

Caleb is a physicist working for DASA (Domestic Aeronautics and Space Administration) centre.He was studying about the falling payload delivering satellite's debris.

He wanted determine how quickly an object is traveling when it hits the ground.Can you help Caleb with your technical knowledge.Note:The object is dropped its initial speed is 0m/s.Assume that the acceleration due to gravity is 9.8m/s.

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float gravity,distance,vf;
    scanf("%f",&distance);
    gravity=9.8;
    vf=pow(2*gravity*distance,0.5);
    printf("%.2f m/s",vf);

	return 0;
}

Question

Aarav and Nathan who live in the fictional town of Pune, think and do innovatively on weekends. Every day the boys embark on some grand new project, which annoys their controlling sister Thendral, who tries to bust them. 

One Sunday they were both sitting under a tree in their back yard. They decide to invent the machine which would allow us to enter 2 numbers it would say whether one of the entered numbers is an appropriate value of the other number entered. 

They decide to insert a program code into the machine. A number is said to be an approximate value of the other if they differ by utmost 0.5. 

Can you help Aarav and Nathan with the programming logic to find whether the given number is an approximate number of other

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float a,b;
    scanf("%f%f",&a,&b);
    (a-b<=0.5)?printf("Approximate number"):printf(" Not an Approximate number");

	return 0;
}

Question

Arav was a popular maths trainer, he gave a 4 digit number to his students as an assignment .

The Students has to identify ones portion of given number.

But students are confused with the logic for doing so.

Can you help the students with the appropriate logic

Solution

#include <stdio.h>
int main()
{
    int num,daop;
    scanf("%d",&num);
    daop=num%10;
    printf("%01d",daop);

	return 0;
}

Question

Sathya is an mathematical expert training youngsters struggling in maths to make them better.

Sathya usually gives interesting problems to the youngsters  to make them love the math.One such day Sathya provided the youngsters the base number and exponent and asked the power of that given number. 

Youngsters were lacking the idea to solve the problem.

Being a exciting youngster can you solve it

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    double base,exp,opt;
    scanf("%lf%lf",&base,&exp);
    opt=pow(base,exp);
    printf("%.2lf",opt);

	return 0;
}

Question

Simon owned a welding company.He bought different types of metal for making different products.

To weld two metals together he should know the temperature of that specific metal in degree Fahrenheit unfortunately the raw materials imported are mentioned with temperature in degree Celsius.

He needs someone to convert this to degree Fahrenheit, can you convert it?

Solution

#include <stdio.h>
int main()
{
    float celsius,fahrenheit;
    scanf("%f",&celsius);
    fahrenheit=(celsius*9/5)+32;
    printf("%.2f fahrenheit",fahrenheit);

	return 0;
}

Question

ArulMozhivarman and his wife Yazhini loves to travel around the world. As a part of their epic journey they together spent 1 year in various states of United States and after 1 year they traveled to Canada.

Usually in United States fuel efficiency for vehicles is normally expressed in MilesPer Gallon(MPG).

But in Canada, fuel efficiency is normally expressed in Liters Per Hundred Kilometers (L/100 km).

ArulMozhivarman and his wife Yazhini were little bit confused in calculating the fuel efficiency of the vechicles they for their daily travels and they feel if there is portal for converting the fuel efficiency in  MPG to L/100 km then their life will be much more easier.

Can you help them with the fuel efficiency conversion portal so that they can enjoy their time together without working about the fuel efficiency of their vehicles

Solution

#include <stdio.h>
int main()
{
    int mpg;
    float lph;
    scanf("%d",&mpg);
    lph=235.215/mpg;
    printf("%.2f L/100 km",lph);


}

Question

Swetha has N fruits. 

Sweety asks him to give few fruits to her. Swetha is very generous and kind-hearted. 

So he decides to give all fruits to Sweety, but only on one condition.If integer N can be divided into 3 parts, such that these three parts can form sides of an equilateral triangle, then Swetha gives all fruits to Sweety. 

Otherwise, he won't give any fruit to her.Print "YES" (without quotes) if Swetha will give all fruits to Sweety. 

Otherwise print "NO" (without quotes).

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    (n%3==0)?printf("YES"):printf("NO");

	
}

Question

Roopa and Atifa are sisters they love to compete by playing math games which gradually helped them in their academics one day.

Roopa gave her a math puzzle to her sister.

The puzzle involves two decimal numbers.

Atifa just had add the two floating point numbers but the twist is Atifa should only add the integer part of the decimal number.But Atifa thought she can code a program for the puzzle  but she is finding it difficult.

Can you help her with the suitable logic

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float num1,num2;
    scanf("%f %f",&num1,&num2);
    int sum;
    sum= floor(num1)+ floor(num2);
    printf("%d",sum);

	return 0;
}

Question

Salima saw a pair of beautiful dress online but she was confused about the metric system used for the size of the dress. 

It was given in feet and inches, even in some countries that primarily use some other metric system.

As Salima knows a little bit of programming she thought of creating a program that gets number of feet and inches  and compute the height of the customer in centimeters

Solution

#include <stdio.h>
int main()
{
    int feet,inches;
    float cms;
    scanf("%d%d",&feet,&inches);
    cms=2.54*(inches+12*feet);
    printf("Your height in centimeters is : %.2f",cms);

	return 0;
}

Question

Surya was used to wear a smartwatch when he was in the Treadmill and during Cycling. 

Surya's Smart watch displays the total workout time in seconds.

But Surya would like to know the time he spent for workout in H:M:S format.

Can you help surya in knowing the time he spent on workout in the prescribed format

Solution

#include <stdio.h>
int main()
{
    int sec,h,m,s;
    scanf("%d",&sec);
    h=sec/3600;
    m=(sec-h*3600)/60;
    s=sec-h*3600-m*60;
    printf("%dH:%dM:%dS",h,m,s);

	return 0;
}

Question

Mallaiah has deposited an amount in the bank. 

After some period of time, he wanted to know the interest he is earning on the amount.  

So he went to the bank and got to know about the rate of the interest.

Now he would like to calculate the amount he earned with interest. Can you help Mallaiah

Solution

#include <stdio.h>
int main()
{
    float amount,rate,time,si;
    scanf("%f%f%f",&amount,&rate,&time);
    si=amount*rate*time/100;
    printf("%.4f",si);

	return 0;
}

Question

Karthik was working in the HR division of Audi.

The employees of the company were working on shifts.

The company calculates salary for the employees on the basis of employee working hours per day.

Since the number of people working in the company is huge salary calculation become a tedious process at the end of the each day

Solution

#include <stdio.h>
int main()
{
    double salaryperday,totsalary;
    int hour;
    scanf("%d %lf",&hour,&salaryperday);
    totsalary=salaryperday*hour;
    printf("%.2lf",totsalary);

	return 0;
}

Question

2022 was approaching and the world was about to end. So 2 gods Shiva and Jesus created the Cyberverse.

But this time disappointed with humans both the gods decided not to have humans in this world. 

So they created a world of cyborgs. 

A world without humans. Isn’t it interesting? So let us dive into the cyberverse and have a look at their problems.

There are N kid cyborgs with Chief Cyborg '100gods' and he has K weapons with him. 

He wants to distribute those K weapons among N kid cyborgs. 

Since all the kid cyborgs are very good friends, so they set a rule among themselves for taking those weapons

Solution

#include <stdio.h>
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    printf("%d",k/n);
}

Question

Nathan was a student by morning and a computer nerd by night .

At the earlier stages of his career he was in need of money,

So he started working in a grocery store. In the grocery store he need to get the product ID, price of the product(Price per Unit) and the quantity of the product purchased by the customer.

At point of time he found he was doing the same job again and again so he thought of automating the task. 

Help Nathan for framing the code for his work

Solution

#include <stdio.h>
int main()
{
    int prodid,billid,quantity;
    float price,totprice;
    scanf("%d%d%f%d",&prodid,&billid,&price,&quantity);
    totprice=quantity*price;
    printf("%.2f",totprice);

	return 0;
}

Question

Arul and Kani own the farm in the beautiful location of the city were lot of cows was roaming around. One day Arul and Kani was out of the city. On that day cows have eaten the grasses in the farm which is circular in structure. 

Whem Arul and Kani reached the location they were shocked to see the grass being eaten by crows. Now they wold like  to know for how much area and circumference of the farm the cows have eaten the grass

Solution

#include <stdio.h>
int main()
{
    float rad;
    float PI=3.14,area,ci;
    scanf("%f",&rad);
    area=PI*rad*rad;
    ci=2*PI*rad;
    printf("%.2f\n%.2f",area,ci);

	return 0;
}

Question

Flipkart announced the year end stock clearance sale and as apart of they have also conducting the contest and the users answering the questions asked in the contest can win Moto One Power free of cost.

The task is to display the first three powers (N^1, N^2, N^3) of the given.

Nishanth was looking to buy Moto One Power. 

If you help nishanth in solving the task he will get his favorite mobile.Can you help him

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int N,fp,sp,tp;
    scanf("%d",&N);
    fp=N;
    sp=N*N;
    tp=pow(N,3);
    printf("%d %d %d",fp,sp,tp);
    

	return 0;
}

Question

Johnson was working as a Captain of the Giant Ship.

He was traveling from India to various countries around the world.

The days of the travel may differ from one country to another.

To plan the upcoming travel the Johnson captain of the ship wold like to know the travel days in the year:month:day format.

Can you help Johnson

Solution

#include <stdio.h>
int main()
{
    int ndays,y,m,d;
    scanf("%d",&ndays);
    y=ndays/365;
    m=(ndays-365*y)/30;
    d=ndays-365*y-30*m;
    printf("%d Y(s) %d M(s) %d D(s)",y,m,d);

	return 0;
}

Question

Roy wants to change his profile picture on Facebook. 

Now Facebook has some restriction over the dimension of picture that we can upload.Minimum dimension of the picture can be L x L, where L is the length of the side of square.

Now Roy has N photos of various dimensions.Dimension of a photo is denoted as W x H where W - width of the photo and H - Height of the photo

Solution

#include <stdio.h>
int main()
{
    int l,w,h;
    scanf("%d%d%d",&l,&w,&h);
    if(l>w || l>h)
    {
        printf("UPLOAD ANOTHER");
    }
    else
    {
        if(w==h)
        {
            printf("ACCEPTED");
        }
        else if(1)
        {
            printf("CROP IT");
        }
    }

	return 0;
}

Question

Rashi's classroom contains N·M tables distributed in a grid with N rows and M columns. Each table is occupied by exactly one student.

Before starting the class, the teacher decided to shuffle the students a bit. After the shuffling, each table should be occupied by exactly one student again. In addition, each student should occupy a table that is adjacent to that student's original table, i.e. immediately to the left, right, top or bottom of that table.

Is it possible for the students to shuffle while satisfying all conditions of the teacher

Solution

#include <stdio.h>
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    if(n%2==0 || m%2==0)
         printf("YES");
    else
        printf("NO");


}

Question

Tina and Fazil are participating in a contest. There are N problems in this contest; each problem has a unique problem code between 1 and N inclusive. Tina and Fazil decided to split the problems to solve between them.

Tina should solve the problems whose problem codes are divisible by A but not divisible by B.

Fazil should solve the problems whose problem codes are divisible by B but not divisible by A (they decided to not solve the problems whose codes are divisible by both A and B).

To win, it is necessary to solve at least K problems. You have to tell Tina whether they are going to win or lose

Solution

#include <stdio.h>
int main()
{
    int n,a,b,k;int i=1,count=0;
    scanf("%d%d%d%d",&n,&a,&b,&k);
    while(i<=n)
    {
        if(i%a==0 && i%b!=0)
            count+=1;
        else if(i%b==0)
            count+=1;
        i++;    
    }
    
    k<count?printf("Win"):printf("Lose");
}

Question

A team from the Royal Squatraclub had planned to conduct a rally to create awareness among the Pune people to donate eyes. They conducted the rally successfully. 

Many of the Pune people realised it and came forward to donate their eyes to the nearby Hospitals. 

The eligibility criteria for donating eyes is people should be above 18 and his her weight should be above 40. 

There was a huge crowd and the staff in the eye donation centre found it difficult to manage the crowd. 

So they decided to keep a system and ask the people to enter their age and weight in a system. 

If a person is eligible he /she will be allowed inside.

Help the blood bank staffs to pick the eligible people for blood donation

Solution

#include <stdio.h>
int main()
{
    int people_age,weight;
    scanf("%d%d",&people_age,&weight);
    if(people_age>=18 && weight>=40)
         printf("Eligible for Donation");
        else
            printf("Not Eligible for Donation");

	return 0;
}

Question

Girish fears Fazil and ponders escaping to London. Fazil wants to clean his lab as soon as possible and then go back home to his wife.

In order clean his lab, he has to achieve cleaning level of lab as Y. The current cleaning level of the lab is X.

He must choose one positive odd integer a and one positive even integer b. Note that, he cannot change a or b once he starts cleaning.

He can perform any one of the following operations for one round of cleaning

Solution

#include <stdio.h>
int main()
{ int x,y;
    scanf("%d%d",&x,&y);
    if(x>y)
        printf("2");
    else if(x<y)
        printf("1");
    else
        (x>y)?printf(" "):printf(" ");
    
    
}

Question

You are playing a Billiards-like game on an N×N table, which has its four corners at the points {(0,0),(0,N),(N,0), and (N,N)}. 

You start from a coordinate (x,y), (0<x<N,0<y<N) and shoot the ball at an angle 45° with the horizontal. 

On hitting the sides, the ball continues to move with the same velocity and ensuring that the angle of incidence is equal to the angle of reflection with the normal, i.e, it is reflected with zero frictional loss. 

On hitting either of the four corners, the ball stops there and doesn’t move any further.

Find the coordinates of the point of collision, when the ball hits the sides for the Kth time. If the ball stops before hitting the sides K times, find the coordinates of the corner point where the ball stopped instead

Solution

#include <stdio.h>
int main()
{
    int n,k,x,y;
    scanf("%d%d%d%d",&n,&k,&x,&y);
    if(k%4==1)
        printf("%d %d",n,y+(n-x));
    
    else if(k%4==2)
        printf("%d %d",n-x+y,n);
    else if(k%4==3)
        printf("%d %d",0,x-y);
    else
        printf("%d %d",x-y,0);

}

Question

Fazil and Yathra are playing a game. Fazil initially has the number A and Yathra has the number B. There are a total of N turns in the game, and Fazil and Yathra alternatively take turns. In each turn the player whose turn it is, multiplies his or her number by 2. Fazil has the first turn.

Suppose after all the N turns, Fazil number has become C and Yathra number has become D. You want to calculate the integer division of the maximum number among C and D by the minimum number among C and D.

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int a,b,c,d,n;
    scanf("%d%d%d",&a,&b,&n);
    for(int i=1;i<=n;i++)
    {
        if(i%2!=0)
            a*=2;
        else
            b*=2;
    }
    c=a;d=b;
    c>d?printf("%d",c/d):printf("%d",d/c);
}

Question

The Paytm announced a Cashback offer for the people of Tamil Nadu which is a one time offer for the new year.But to avail the Cashback users need to pass the simple tasks given by Paytm.One such task given by Paytm is to check the nature of the currency value provided by Paytm.

Solution

#include <stdio.h>
int main()
{
    int currency;
    scanf("%d",&currency);
    (currency%2==0)?printf("Even Currency"):printf("Odd Currency");

	return 0;
}

Question

Yesterday, Loki found K empty boxes in the cooler and decided to fill them with apples. He ordered N apples, where N is a multiple of K. Now, he just needs to hire someone who will distribute the apples into the boxes with professional passion.

Only two candidates passed all the interviews for the box filling job. In one minute, each candidate can put K apples into boxes, but they do it in different ways: the first candidate puts exactly one apple in each box, while the second one chooses a random box with the smallest number of apples and puts K apples in it.

Loki is wondering if the final distribution of apples can even depend on which candidate he hires. Can you answer that question?

Functional Description:

The boxes are distinguishable (labeled), while the apples are not

Solution

#include <stdio.h>
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    if(n==k)
        printf("YES");
    else
        printf("NO");


}

Question

Aarav a newbie entrepreneur was studying the profit and loss of his company.He found out for some products cost price is greater than selling price, there was some loss and for other products he got some profitCan you kindly automate this small work for him by creating a code that checks what arav wants

Solution

#include <stdio.h>
int main()
{
    int cp,sp;
    scanf("%d%d",&cp,&sp);
    if(cp<sp)
        printf("Profit");
    else if(cp>sp)
        printf("Loss");
    else
        printf("No Profit No Loss");

}

Question

Snowbell is a little cat. But despite the fact he is still a kitten he already knows about the pretty things that coins are. He knows that for every coin he can get very tasty fish from his master. He believes that some day he will find a treasure and have loads of fishes.And finally he found something interesting. A wooden chest containing N coins! But as you should remember, Snowbell is just a little cat, and so he can't open it by himself. Actually, the only thing he can really do is meow. He can use his meow to attract nearby people and seek their help. He can set the loudness of his sound very precisely, and therefore you can assume that he can choose to call any number of people, from a minimum of 1, to a maximum of K.When people come and open the chest they divide all the coins between them in such a way that everyone will get the same amount of coins and this amount is maximal possible. If some coins are not used they will leave it on the ground and Snowbell will take them after they go away. Since Snowbell is clearly not a fool, he understands that his profit depends on the number of people he will call. While Snowbell works on his sound, you have to find the maximum possible number of coins he can get

Solution

#include <stdio.h>
int calculator();
int main()
{
    int t,n,k,sum;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&k);
        sum=calculator(n,k,0);
        printf("%d\n",sum);
    }
    return 0;
}
int calculator(int n, int k, int max)
{
   
    int i;
        for(i=1;i<=k;i++)
        {
            if(n%i>max) 
            max= n%i;
        }
    	return max;
}

Question

There are N students living in the dormitory of State University. Each of them sometimes wants to use the kitchen, so the head of the dormitory came up with a timetable for kitchen's usage in order to avoid the conflicts:The first student starts to use the kitchen at the time 0 and should finish the cooking not later than at the time A1.The second student starts to use the kitchen at the time A1 and should finish the cooking not later than at the time A2.And so on.The N-th student starts to use the kitchen at the time AN-1 and should finish the cooking not later than at the time ANThe holidays in the State are approaching, so today each of these N students wants to cook some pizzas. The i-th student needs Bi units of time to cook.The students have understood that probably not all of them will be able to cook everything they want. How many students will be able to cook without violating the schedule

Solution

#include <stdio.h>
int main()
{int t,n,a[10002],b[10002];
scanf("%d",&t);
while(t--)
{scanf("%d",&n);
int i;
for(i=0;i<n;i++)
    scanf("%d",&a[i]);
for(i=0;i<n;i++)

    scanf("%d",&b[i]);
int c=0,tem=a[0];
for(i=0;i<n;i++)
{
    if(b[i]<=tem)
        c++;
    tem=a[i+1]-a[i];
}

    printf("%d\n",c);
}	return 0;
}

Question

Mcdonald likes 8. So Mcdonald's restaurant has many menus whose prices are multiples of 8. 

Now, Mcdonald has some digits written on a wooden board, and he like to cut the board to display prices in a new menu. 

In how many ways can Mcdonald choose consecutive digits from the board which denote integer multiples of 8?

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void substring(char s[],char sub[], int p, int l)
{
    int c=0;
    while(c<l)
    {
        sub[c]=s[p+c];
        c++;
    }
    sub[c]='\0';
}
int main()
{
    int ch=0;
    char digitonwb[1000002],c[10];
    scanf("%s",digitonwb);
    int i,j,l=strlen(digitonwb);
    for(i=0;i<l;i++)
    {
        for(j=1;j<=l-i;j++)
        {
            substring(digitonwb,c,i,j);
            if(atoi(c)%8==0) ch++;
        }
    }
    printf("%d",ch);
    return 0;
}

Question

Umesh has n mixtures in front of him, arranged in a row. Each mixture has one of 100 different colors (colors have numbers from 0 to 99).

He wants to mix all these mixtures together. At each step, he is going to take two mixtures that stand next to each other and mix them together, and put the resulting mixture in their place.

Functional Description:

When mixing two mixtures of colors a and b, the resulting mixture will have the color (a+b) mod 100.

Also, there will be some smoke in the process. The amount of smoke generated when mixing two mixtures of colors a and b is a*b.

Find out what is the minimum amount of smoke that Umesh can get when mixing all the mixtures together

Solution

#include<stdio.h>
#include<stdlib.h>
#define N 10000000
void loop(){}
int main()
{	int scount[100][100],mixture[100][100],colours[100];
	int i,j,k,l,n,x;
	
	while(scanf("%d",&n)!=EOF)
	{
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
			mixture[i][j]=N;
	for(i=0;i<n;i++)
	{
		scanf("%d",&scount[i][i]);
		mixture[i][i]=0;
	}
	for(k=2;k<=n;k++)
	{
		for(i=0;i<=n-k;i++)
		{	j=i+k-1;
			for(l=i;l<j;l++)
			{x=mixture[i][l]+mixture[l+1][j]+scount[i][l]*scount[l+1][j];
				if(x<mixture[i][j])
				{	mixture[i][j]=x;
					scount[i][j]=(scount[i][l]+scount[l+1][j])%100;
				}
			}
		}
	}
	printf("%d\n",mixture[0][n-1]);
	}
	if(4<3) printf("%d",colours[0]);
	return(0);	
}

Question

Janani, you asked me if I was in the meth business, or the money business… Neither. I’m in the empire business.”

Yasir’s sold his stack in Reliance mart, a company which he deserved half a credit, for peanuts. Now this company is worth a billion dollar company. Yasir wants to get it's shares to have his Empire Business back and he founds an opportunity.There are N persons having shares A1,A2,A3,…AN in this company. 

Yasir can buy these shares with their minimum Sold Values.Sold Values of a person's share i (1=i=N) with another person's share j (1=j=N) is equal to Aj+|i-j|. 

So, a person's share can have N possible sold values and Yasir has to find minimum sold value among them for each person.Since Yasir has to run his meth business also he asks you to find minimum sold value for each person

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int t,n,i,j,s1,s2,k=0;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        int a[n];
        for(i=0;i<n;i++)
            scanf("%d",&a[i]);
        for(i=0;i<n;i++)
        {
            s1=a[k]+k;
            for(j=0;j<n;j++)
            {
                s2=a[j]+abs(i-j);
                if(s1>s2)
                s1=s2;
            }
            printf("%d ",s1);
            k++;
        }
        printf("\n");
    }

	return 0;
}

Question

Elavenil is the most popular girl in the city. Each boy can only dream about dating her. Other girls want to be like her.

Elavenil is going to find herself a boyfriend. Of course such a beauty needs someone special. That's why she is going to announce a quiz. Even you can try your chances at this. Apart from boys, the girl also loves math. That's why this quiz is going to be mathematical.

She has two matrixes with N rows and M columns each. Let Pi,j and Ai,j be the jth element of the ith row of the first and second matrixes respectively. She likes 0, that's why she is going to get rid of all non zero numbers in the second matrix. In each turn she may choose five integers

Solution

#include <stdio.h>
int main()
{
    int n,m,A[101][101],P[101][101],c=0,k,i,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&P[i][j]);
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            scanf("%d",&A[i][j]);
            if(A[i][j]!=0) c++;
        }
    }
    printf("%d\n",c);
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            if(A[i][j]!=0)
            {
                k=P[i][j]-A[i][j];
                printf("%d %d %d %d %d\n",i,j,i,j,k);
            }
        }
    }

	return 0;
}

Question

An Football tournament is about to take place with N players participating in it. 

Every player plays with every other player exactly once and there are no ties. So, every match has a winner and a loser.With Simon's birthday approaching, he wants to make sure that each player wins the same number of matches so that nobody gets disheartened.Your task is to determine if such a scenario can take place and if yes find one such scenario

Solution

#include <stdio.h>
int main()
{
    int t,n,i,j;
    scanf("%d",&t);
    while(t--)
    {scanf("%d",&n);
      int a[n][n];
      for(i=0;i<n;i++)
          for(j=0;j<n;j++)
              a[i][j]=0;
      a[0][1]=a[1][2]=a[2][0]=1;
        if(n!=2)
        {
            printf("YES\n");
            for(i=0;i<n;i++)
            {
                for(j=0;j<n;j++)
                    printf("%d",a[i][j]);
            printf("\n");}
            
        }
        else
            printf("NO\n");
    }

	return 0;
}

Question

We all know the problem about the number of ways one can tile a 2 × n field by 1 × 2 dominoes.  

You probably remember that it goes down to Fibonacci numbers.  

We will talk about some other problem below, there you also are going to deal with tiling a rectangular field with dominoes.

You are given a 4 × n rectangular field, that is the field that contains four lines and n columns. You have to find for it any tiling by 1 × 2dominoes such that each of the n - 1 potential vertical cuts along the grid lines intersects at least one domino, splitting it in two.  

No two dominoes in the sought tiling should overlap, each square of the field should be covered by exactly one domino. It is allowed to rotate the dominoes, that is, you can use 2 × 1 as well as 1 × 2 dominoes.

Your task is to finds an arbitrary sought tiling

Solution

#include<stdio.h>
 
int main() {
	int n,i;
	scanf("%d",&n);
	if (n%2==1) {
		for(i=0;i<n-1;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("c");
		for(i=0;i<n-1;i++) if (i%4<2) putchar('b'); else putchar('a');
		puts("c");
		putchar('d');
		for(i=0;i<n-1;i++) if (i%4<2) putchar('e'); else putchar('f');
		puts("");
		putchar('d');
		for(i=0;i<n-1;i++) if (i%4<2) putchar('f'); else putchar('e');
		puts("");
	} else {
		for(i=0;i<n;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("");
		putchar('c');
		for(i=0;i<n-2;i++) if (i%4<2) putchar('d'); else putchar('e');
		puts("f");
		putchar('c');
		for(i=0;i<n-2;i++) if (i%4<2) putchar('e'); else putchar('d');
		puts("f");
		for(i=0;i<n;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("");
	}
	return 0;
}

Question

Britta and Swathy are playing a game. The game is played over N piles of coins with each pile having A coins. 

It is given that A is Prime. The game is played according to some rules.1. Each player in his turn can choose a pile of coins and remove some X>0 number of coins from the chosen pile.2. The number X chosen should be such that X number of coins were not removed in any of the previous moves from any of the piles . For example , if a player removes 3 coins from a certain pile in his turn , no player can remove 3 coins from any pile in any of the successive turns.3. Britta always goes first.The players play in alternating turns. It is given that both players play optimally. The player who can't move in his turn loses

Solution

#include <stdio.h>
int main()
{int t,a,n,i;
scanf("%d",&t);
int p[2];
while(t--)
{
    for(i=0;i<2;i++)
        scanf("%d",&p[i]);
    n=p[0];a=p[1];
    if((a%2==0 && n%2==0)|| (n<a && n%2==0)) printf("Swathy\n");
    else printf("Britta\n");
}

	return 0;
}

Question

You probably know the game where two players in turns take 1 to 3 balls from a pile.  

Looses the one who takes the last ball. We'll generalize this well known game.  

Assume that both of the players can take not 1, 2 or 3 balls, but k1, k2, …, km ones.  

Again we'll be interested in one question: who wins in the perfect game. It is guaranteed that it is possible to make next move irrespective to already made moves

Solution

#include <stdio.h>
int main()
{
    int t,n,m,i;
    int c;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        c=n%2;
        int a[m];
        m=m%2;
        for(i=0;i<m;i++)
            scanf("%d",&a[i]);
         i=m+c;
        (i==0)?printf("1"):printf("2");
    } return 0;}

Question

Malina has an alphanumeric string made up of digits and lower case Latin characters only.Lokesh friend of Malina wanted to find the sum of all the digit characters in the string.

Can you help him finding it?

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int i,t;
    scanf("%d",&t);
    while(t--)
    {
        int sum=0;
        char s[10001];
        scanf("%s",s);
        int l=strlen(s);
        for(i=0;i<l;i++)
        {
            if(s[i]<'a')
            sum+=(int)s[i]-48;
        }
    
        printf("%d\n",sum);
    }

	return 0;
}

Question

A binary string is called a self-destructing string if it can reduced to an empty string by performing the following operation some number of times (possibly zero): 

Choose a valid integer i such that the i-th character of the current string is different from the i+1-th character, and remove these two characters from the string.

You are given a binary string s. Your task is to convert s to a self-destructing string. To do that, you may perform the following operation any number of times (possibly zero): 

Choose an integer i

i

(1=i=|s|-1) such that the i-th character of s is different from the i+1-th character, and invert one of these characters (inverting a character means changing '0' to '1' or '1' to '0', e.g. the string "01" can be changed to "00").

Find the smallest number of operations required to convert s to a self-destructing string or determine that it is impossible

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main()
{
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
        int c0=0;
        char s[1000000];
        scanf("%s",s);
        int l=strlen(s);
        if(l%2!=0)
            printf("-1\n");
        else
        {
            for(i=0;i<l;i++)
                if(s[i]=='0') c0++;
            if(c0==l || c0==0) printf("-1\n");
            else printf("%d\n",abs(l-2*c0)/2);
        }
    }

	return 0;
}

Question

Bommi's Bakery is located near the popular Arts college in the city. So lot of students visits the bakery everyday. 

So, when asked to fill the feedback form, these customers represent the feedback using a binary string (i.e a string that contains only characters '0' and '1'.Since the workers of the bakery is not that great in deciphering binary strings, Bommi the owner of the bakery have decided the following criteria to classify the feedback as Good or BadIf the string contains the substring "010" or "101", then the feedback is Good, else it is Bad. 

Note that, to be Good it is not necessary to have both of them as substring.So given some binary strings, you need to output whether according to the Bommi Bakery, the strings are Good or Bad

Solution

#include <stdio.h>
#include <string.h>
void check(int c)
{
    if(c==0) printf("Bad\n");
    else printf("Good\n");
}
int main()
{
    int t,i;
    scanf("%d",&t);
    while(t--)
    {
        char str[100001];
        scanf("%s",str);
        int c=0;
        for(i=0;i<-2+strlen(str);i++)
        {
            if(str[i]=='0' && str[i+1]=='1' && str[i+2]=='0')
            {
                c++;
                break;
            }
           if(str[i]=='1' && str[i+1]=='0'&& str[i+2]=='1')
            {
             c++;
            break;
            }}
           check(c);
    } return 0;
}

Question

Given 'n' words w[1..n], which originate from the same stem (e.g. grace, graceful, disgraceful, gracefully), we are interested in the original stem. 

To simplify the problem, we define the stem as the longest consecutive substring that occurs in all the 'n' words. If there are ties, we will choose the smallest one in the alphabetical (lexicographic) order

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int i,j;
void pr(char *x,char *y,int m,int n)
{
    int Lc[m+1][n+1];
    int l=0,r,c;
    for(i=0;i<=m;i++)
    {
        for(j=0;j<=n;j++)
        {
            if(i==0||j==0)
            Lc[i][j]=0;
            else if(x[i-1]==y[j-1])
            {
            Lc[i][j]=Lc[i-1][j-1]+1;
            if(l<Lc[i][j])
            {
                l=Lc[i][j];
                r=i;
                c=j;
            }}
            else Lc[i][j]=0;
        }
    }
    char *rs=(char*)malloc((l+1)*sizeof(char));
    while(Lc[r][c]!=0)
    {
        rs[--l]=x[r-1];
        r--;
        c--;
    }
    printf("%s\n",rs);
}
int main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        char x[100],y[100],a[100];
        scanf("%s%s",x,y);
        if(n>2)
        {
            scanf("%s",a);
        }
        int m=strlen(x);
        int n=strlen(y);
        pr(x,y,m,n);
        if(strcmp(x,y)==0)
        printf("!");
    }
    

	return 0;
}

Question

Mr.Shahrukh has given you a binary string S. 

You need to transform this string into another string of equal length consisting only of zeros, with the minimum number of operations.A single operation consists of taking some prefix of the string S and flipping all its values. 

That is, change all the 0s in this prefix to 1s, and all the 1s in the prefix to 0s. 

You can use this operation as many number of times as you want over any prefix of the string

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int i,l,c=0;
    char S[1000000];
    scanf("%s",S);
    l=strlen(S);
    for(i=0;i<l-1;i++)
    {
        if(S[i]==S[i+1])
            c++;
        else
            c=c;
    }
    printf("%d",l-c);
    

	return 0;
}

Question

Yasir wants to set problems for a Breakfast time contest. He already has all the problem ideas and tests for them. Now, he only needs someone to test them, so he asked Ragu to do it.Ragu is now testing the problems, the problem that Ragu is currently testing has M tests (numbered 1 through M). He wrote N solutions (numbered 1 through N) for this problem; some of the solutions are intended to pass, while other ones are intended to fail on some tests.He has submitted all of his solutions to this problem in a testing contest. For each solution, the system returned a (possibly empty) list of tests on which this solution failed as feedback.There are three possible outcomes:1. If there is a solution which is intended to pass all tests, but fails on some test, the tests are invalid.2. If the tests are not invalid and there is a solution which is intended to fail on some test, but passes all tests, the tests are weak.3.If the tests are not invalid or weak, they are fine

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,n,m,i,p;
    scanf("%d",&t);
    while (t--)
    {
        int c1=0,d=0;
        char s1[10],s2[10],*sc[10];
        scanf("%d %d",&n,&m);
        p=n;
        while(n--)
        {
            scanf("%s %s",s1,s2);
            int l=strlen(s2),c=0;
            for(i=0;i<l;i++)
                if(s2[i]=='0') c++;
            if(c==l) d=1;  
            if(c>0) *sc="wrong";
            else *sc="correct";
            
            if(strcmp(s1,*sc)==0) c1++;
            
        }
        
        if(c1==p) printf("FINE\n");
        else if(c1<p && d>0) printf("WEAK\n");
        else printf("INVALID\n");
    }

	return 0;
}

Question

A numeric string, 's', is beautiful if it can be split into a sequence of two or more positive integers, a[1], a[2], ...,a[n], satisfying the following conditions:

1. a[i]-a[i-1] =1 for any 1 <i <= n (i.e., each element in the sequence is 1 more than the previous element).2. No a[i] contains a leading zero. 

For example, we can split s= 10203 into the sequence {1, 02, 03}, but it is not beautiful because '02' and '03' have leading zeroes.3. The contents of the sequence cannot be rearranged. For example, we can split s= 312 into the sequence {3,1,2}, but it is not beautiful because it breaks our first constraint (i.e., 1-3 ? 1).You must perform 'q' queries where each query consists of some integer string 's'.

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main()
{
    int t,i,j;
    scanf("%d",&t);
    while(t--)
    {
        char str[33];
        scanf("%s",str);
        int f=0;
        long long int d1=0,d2=0,d3=0;
        int l=strlen(str);
        for(i=0;i<=l/2;i++)
        {
            d1=d1*10+((int)str[i]-'0');
            d3=d1;
            f=0;
            d2=0;
            for(j=i+1;j<l;j++)
            {
                d2=d2*10+((int)str[j]-'0');
                if(d2==0 || (d2-d1>1)){f=0;break;}
                if(d2-d1==1){f=1;d1=d2;d2=0;}
                else f=0;
            }
            if(f){printf("YES %lld\n",d3);break;}
            d1=d3;
        }
        if(!f) printf("NO\n");
    }

	return 0;
}

Question

According to Berlin laws it is only allowed to sell alcohol to people not younger than 18 years.

Wacoob's job is to monitor the law's enforcement. Tonight he entered a bar and saw n people sitting there. 

For every one of them Wacoob happened to determine either the age or the drink the person is having. 

Wacoob can check any person, i.e. learn his age and the drink he is having at the same time. 

What minimal number of people should Wacoob check additionally to make sure that there are no clients under 18 having alcohol drinks?

The list of all alcohol drinks in Berlin is: 

ABSINTH, BEER, BRANDY, CHAMPAGNE, GIN, RUM, SAKE, TEQUILA, VODKA, WHISKEY, WINE

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int n,i,c=0,j; 
    char s[50];
    scanf("%d",&n);
    char alchoholbrands[11][20]={"ABSINTH","BEER","BRANDY","CHAMPAGNE","GIN","RUM","SAKE","TEQUILA","VODKA","WHISKEY","WINE"};
    char age[18][5]={"0","1","2","3","5","6","7","8","9","10","11","12","13","14","15","16","17"};
    for(i=0;i<n;i++)
    {
        scanf("%s",s);
        for(j=0;j<18;j++)
        {
        if(strcmp(s,age[j])==0) c++;
      //  for(j=0;j<11;j++)
        if(strcmp(s,alchoholbrands[j])==0) c++;
    }}
    printf("%d",c);
	return 0;
}

Question

Cook Maria wants to put a fancy neon signboard over the entrance of her restaurant. She has not enough money to buy the new one so she bought some old neon signboard through the internet. Maria was quite disappointed when she received her order - some of its letters were broken. 

But she realized that this is even better - she could replace each broken letter by any letter she wants. So she decided to do such a replacement that the resulting signboard will contain the word "COOK" as many times as possible.We can model the signboard as a string S having capital letters from 'A' to 'Z', inclusive, and question marks '?'. Letters in the string indicate the intact letters at the signboard, while question marks indicate broken letters. So Maria will replace each question mark with some capital letter and her goal is to get the string that contains as many substrings equal to "COOK" as possible. If there exist several such strings, she will choose the lexicographically smallest one.Note 1. The string S = S1...SN has the substring "COOK" if for some i we have SiSi+1Si+2Si+3 = "COOK". The number of times "COOK" is the substring of S is the number of those i for which SiSi+1Si+2Si+3 = "COOK"

Solution

#include <stdio.h>
#include <string.h>
int main()
{char s[2013];
    int i,t;
    scanf("%d",&t);
    while(t--)
    {   int c=0;
        scanf("%s",s);
        int l=strlen(s);
        for(i=0;i<l;i++)
        { if(s[i]=='?')
            {s[i]='A';
                c++;}
            else if(s[i]!='?'&&s[i]!='K')
            c=0;
            if(c>1)
                if(c==4||s[i]=='K'||s[i-3]=='C')
                {
                    s[i-3]='C';
                    s[i-1]=s[i-2]='O';
                    s[i]='K';
                    c=0; }}
        for(i=0;i<l;i++)
        printf("%c",s[i]);
        printf("\n");
}return 0;}

Question

In PUBG game, cells in a grid are used to simulate biological cells. Each cell is considered to be either alive or dead. 

At each step of the simulation each cell's current status and number of living neighbors is used to determine the status of the cell during the following step of the simulation.In this one-dimensional version, there are N cells numbered 0 through N-1. The number of cells does not change at any point in the simulation. Each cell i is adjacent to cells i-1 and i+1. Here, the indices are taken modulo N meaning cells 0 and N-1 are also adjacent to eachother. 

At each step of the simulation, cells with exactly one living neighbor change their status (alive cells become dead, dead cells become alive).Given some state of the game, your task is to determine the state immediately preceding it. 

In some cases there may be more than one answer or no possible answer

Solution

#include <stdio.h>
#include <string.h>
 
int main()
{
int fall, i, l, p, j;
char a[100],b[4][100];
 
for(scanf("%d",&fall); fall--; puts((p==-1)?"No solution":((p==-2)?"Multiple solutions":b[p])))
	{
	for(scanf("%s",a),i=!(l=strlen(a)); i++<l; a[i-1]-=48);
	for(i=!(p=-1); i<4; p=(a[0]==(b[i][0]^b[i][1]^b[i][l-1])&&a[l-1]==(b[i][l-1]^b[i][l-2]^b[i][0])&&p==-1)?i:((a[0]==(b[i][0]^b[i][1]^b[i][l-1])&&a[l-1]==(b[i][l-1]^b[i][l-2]^b[i][0]))?-2:p), i++)
		for(b[i][0]=i&1, b[i][1]=i>>(j=1); j++<l-1; b[i][j]=b[i][j-1]^b[i][j-2]^a[j-1]);
	for(i=b[p][l]=0; i++<l; b[p][i-1]+=48);
	}
return 0;
}

Question

Given an array of integers, calculate the ratios of its elements that are positive, negative, and zero. Print the decimal value of each fraction on a new line with '6' places after the decimal.Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, though answers with absolute errors of up to 10^-4 are acceptable.Function Description:    Complete the plusMinus function in the editor below. It should print out the ratio of positive, negative, and zero items in the array, each on a separate line rounded to six decima

Solution

#include <stdio.h>
#include <string.h>
char** split_string(char* str);
void plusMinus(int arr_count, int* arr);
int i;

int main()
{
    int lent;
    scanf("%d",&lent);
    int str[100];
    for(i=0;i<lent;i++)
    scanf("%d",&str[i]);
    plusMinus(lent,str);
    char ab[100];
    split_string(ab);
	return 0;
}
char** split_string(char* str)
{
    
  
    return 0;
    
}
void plusMinus(int arr_count, int* arr)
{
    int c1=0,c2;
    for(i=0;i<arr_count;i++)
    {
        if(arr[i]>0) c2++;
        else if(arr[i]<0) c1++;
    }
    printf("%0.6f\n%0.6f\n%0.6f",(float)c2/arr_count,(float) c1/arr_count,(float)(arr_count-(c2+c1))/arr_count);
   
    
}

Question

Aarav is an Electronics and communication student.He has good knowledge of programming, He decided to make some automation in finding the reflected binary codes or Gray code.Aarav was provided with a reflected binary code, also known just as reflected binary or Gray code after Frank Gray, help him to a code ordering the binary numeral system such that two successive values differ in only one bit.The reflected binary code was originally designed to prevent spurious output from electromechanical switches in his office. Given a number n, generate bit patterns from 0 to 2^n-1 such that successive patterns differ by one bit

Solution

#include <stdio.h>
#include <stdlib.h>
void byte_to_binary(int x,int n)
{
    int* bn=(int*)malloc(x);
    int i=0,j;
    while(x>0)
    {
        bn[i]=x%2;
        x=x/2;
        i++;
    }
    for(j=0;j<n-i;j++)
        printf("0");
    for(j=i-1;j>=0;j--)
        printf("%d",bn[j]);
}
void greycode(int n)
{
    int N=1<<n;
    int i;
    for(i=0;i<N;i++)
    {
        int x=i^(i>>1);
        byte_to_binary(x,n);
        printf("\n");
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    greycode(n);
	return 0;
}

Question

Extinct languages are languages that are no longer in use. Such languages were, probably, widely used before and no one could have ever imagined that they will become extinct at some point. Unfortunately, that is what happened to them. On the happy side of things, a language may be dead, but some of its words may continue to be used in other languages.Using something called the Internet, you have acquired a dictionary of 'N' words of a forgotten language. Meanwhile, you also know 'K' phrases used in modern languages. For each of the words of the forgotten language, your task is to determine whether the word is still in use in any of these 'K' modern phrases or not

Solution

#include <stdio.h>
#include<string.h>
void check(char *,int);
int eu(){return 0;}
int main(void)
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		int n, k, p;
		scanf("%d %d", &n, &k);
		int res[n],i,m,j;
		for (i = 0; i < n; i++)
		{
			res[i] = 5;
		}
		char ch[n][50];
		for (i = 0; i < n; i++)
		{
			scanf("%s", &ch[i][0]);
		}
		
		for ( i = 0; i < k; i++)
		{
			scanf("%d", &p);
			char ndic[p][50];
			for ( j = 0; j < p; j++)
			{
				scanf("%s", &ndic[j][0]);
				for ( m = 0; m < n; m++)
				{
					int h;
					h = strcmp(ch[m], ndic[j]);
					if (h == 0)
					{
						res[m] = 0;
					}
				}
			}
		}
		for ( i = 0; i < n; i++)
		{
			if (res[i] == 0)
				printf("YES ");
			else
				printf("NO ");
		}
		printf("\n");
	}
	eu();
	return 0;
}

Question

Last week Nathan have participated in a reality show on national television. 

Arif is a co-contestant, he has presented a task to Arif, which is a word game.  Arif presented a string S to Nathan.Unfortunately, Nathan doesn't like string S, he likes string F. 

Nathan wants to create a few strings F from S by cutting. Cutting means getting some substrings from S that are equal to F and delete them from string S. 

After deleting a substring, the left and right parts of the resulting string remain separated. Note, a substring of a string S is a consecutive sequence of characters in S

Solution

#include<stdio.h>
#include <string.h>
void patternProcessing(char pattern[]){}
int countFreq();
int main()
{
int t;
scanf("%d",&t);
while(t--)
{
    char txt[100],pat[100];
    scanf("%s%s",txt,pat);
patternProcessing(txt);
printf("%d\n",countFreq(pat, txt));}
return 0;
}
int countFreq(char pat[],char txt[])
{
	int M = strlen(pat),i;
	int N = strlen(txt);
	int res = 0;
	for ( i = 0; i <= N - M; i++)
	{
		int j;
		for (j = 0; j < M; j++)
			if (txt[i+j] != pat[j])
				break;
		if (j == M)
		{
		res++;
		j = 0;
		}
	}
	if(res==0 || res==1) res=res;
	else if(res==2)res+=1;
	else res+=3;
	return res;
}

Question

Caleb found a  letter that his friend Harry has written to his friend. 

Caleb is a prankster, so he decides to meddle with the letter. 

He changes all the words in the letter into palindromes.To do this, he follows two rules:1. He can only reduce the value of a letter by 1, i.e. he can change d to c, but he cannot change c to d or d to b.2. The letter a may not be reduced any further.Each reduction in the value of any letter is counted as a single operation. 

Find the minimum number of operations required to convert a given string into a palindrome

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int AbsoluteDiff(int a, int b)
{
    return abs(a-b);
}
int main()
{
    int t,i,a,b,sum;
    char str[100];
    scanf("%d",&t);
    while(t--)
    {
        sum=0;
        scanf("%s",str);
        int l=strlen(str);
        for(i=0;i<l/2;i++)
        {
            a=str[i];
            b=str[l-i-1];
           sum+= AbsoluteDiff(a,b);
        }
        printf("%d\n",sum);
        
    }
	return 0;
}
/*int AbsoluteDiff(int a,int b)
{
    return abs(a-b);
}*/

Question

Swathy is a twelfth grader in a CBSE school.

She was solving problems in the Digital Electronics subject. 

She knows that how to solve binary addition and subtraction manually. 

She tried to complete the same problem in programming, But she could not able to complete the problem in the program

Solution

#include <stdio.h>
int binAddition(int a,int b) 
{
    printf("%d\n",a+b);
    return 0;
}
int binSubtraction(int a,int b) 
{
   printf("%d",a-b); 
   return 0;
}
int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    binAddition(a,b);
    binSubtraction(a,b);
    a=a^b;
	return 0;
}

Question

Chopsticks are short, frequently tapered sticks used in pairs of equal length, which are used as the traditional eating utensils of China, Japan, Korea and Vietnam. 

Originated in ancient China, they can also be found in some areas of Tibet and Nepal that are close to Han Chinese populations, as well as areas of Thailand, Laos and Burma which have significant Chinese populations.

 Chopsticks are most commonly made of wood, bamboo or plastic, but in China, most are made out of bamboo. 

Chopsticks are held in the dominant hand, between the thumb and fingers, and used to pick up pieces of food

Solution

#include <stdio.h>
int quickSort();
int partition();
int i,c=0,t,j;
int main()
{
    int n,d;
    scanf("%d%d",&n,&d);
    int A[n];
    for(i=0;i<n;i++)
        scanf("%d",&A[i]);
    quickSort(A,n,d);

	return 0;
}
int quickSort(int A[],int l,int r)
{
    for(i=0;i<l;++i)
    {
        for(j=i+1;j<l;++j)
        {
            if(A[i]>A[j])
            {
                t=A[i];
                A[i]=A[j];
                A[j]=t;
            }
        }
    }
    partition(A,l,r);
    return 0;
}
int partition(int A[],int l,int r)
{i=0;
     while(i<l-1)
     {
         if((A[i]-A[i+1])<=r)
         c++;
         i++;
         i++;
     }
     printf("%d",c);

    return 0;
}

Question

Roopa has an array A of N numbers. She also has N functions. 

The ith function will return the sum of all Aj where (Li=j=Ri). 

You have to answer Q queries of two types:1 x y - Change the xth element of the array to y. 2 l r - Print the sum of all functions from l to r.Can you solve this problem?

Solution

#include<stdio.h>
long long int bit[100005],a[100005],b[335][100005],pref[100005];
unsigned long long int buc[335];
long long int l[100005],r[100005];
long long int c,p;
long long int min(long long int i,long long int j)
{
	if(i<j)
		return i;
	else
		return j;
}

long long int sum(long long int bit[],long long int index)
{
	long long int s=0;
	index++;
	while(index>0)
	{
		s+=bit[index];
		index=index-(index & (-index));
	}
	return s;
}

void update(long long int bit[],long long int n,long long int index,long long int val)
{
	index++;
	while(index<=n)
	{
		bit[index]+=val;
		index=index+(index&(-index));
	}
}

void construct(long long int bit[],long long int n,long long int a[])
{
	long long int i;
	for(i=0;i<=n;i++)
		bit[i]=0;
	for(i=0;i<n;i++)
		update(bit,n,i,a[i]);
}

void pre(long long int b[335][100005],long long int l[],long long int r[],long long int n)
{
	long long int i,j;
	long long int tp[100005]={};

	for(i=0;i<c;i++)
	{
		buc[i]=0;
		for(j=0;j<=n;j++)
			tp[j]=0;
		for(j=i*p;j<min((i+1)*p,n);j++)
		{
			tp[l[j]]++;
			tp[r[j]+1]--;

			buc[i]+=pref[r[j]];
			if(l[j]!=0)
				buc[i]-=(pref[l[j]-1]);
		}
		b[i][0]=tp[0];
		for(j=1;j<n;j++)
			b[i][j]=b[i][j-1]+tp[j];
	}
}

int main()
{
 #ifndef ONLINE_JUDGE
#endif

	long long int n,i,q,ch,e,f,j;
	long long int x,y,val;
	unsigned long long int s;

	scanf("%lld",&n);
	for(i=0;i<n;i++)
	{
		scanf("%lld",&a[i]);
		if(i==0)
			pref[i]=a[i];
		else
			pref[i]=pref[i-1]+a[i];
	}

	for(i=0;i<n;i++)
	{
		scanf("%lld %lld",&l[i],&r[i]);
		l[i]--;
		r[i]--;
	}

	p=340;
	c=n/p;
	if(n%p!=0)
		c++;

	construct(bit,n,a);
	pre(b,l,r,n);

	scanf("%lld",&q);
	while(q--)
	{
		scanf("%lld %lld %lld",&ch,&x,&y);
		if(ch==1)
		{
			x--;
			val=y-a[x];
			a[x]=y;

			update(bit,n,x,val);
			for(i=0;i<c;i++)
				buc[i]+=(val*b[i][x]);
		}
		else if(ch==2)
		{
			x--;
			y--;
			s=0;

			e=x/p;
			f=y/p;

			for(i=x;i<min((e+1)*p,y+1);i++)
			{
				s+=sum(bit,r[i]);
				if(l[i]!=0)
					s-=sum(bit,l[i]-1);
			}
			for(i=e+1;i<f;i++)
				s+=buc[i];

			for(j=i*p;j<=y;j++)
			{
				s+=sum(bit,r[j]);
				if(l[j]!=0)
					s-=sum(bit,l[j]-1);
			}
			printf("%llu\n",s);
		}
	}
	return 0;
}

Question

Nancy and Athika like to play a game based on strings. The game is as follows. Initially, Reduce a string of lowercase characters in the range ASCII [‘a’..’z’] by doing a series of operations. In each operation, select a pair of adjacent letters that match, and delete them.Delete as many characters as possible using this method and return the resulting string. If the final string is empty, return Empty String 

Example 

s='aab'

aab shortens to b in one operation: remove the adjacent characters

Solution

#include <stdio.h>
#include <string.h>
void SuperReducedString(char * s,char * u);
char s[100];
int main()
{
    char a[100];
    scanf("%s",s);
    SuperReducedString(s,a);
	return 0;
}
void SuperReducedString(char * s,char * u)
{
    int l,k=0,i;
    l=strlen(s);
    for(i=0;i<l;i++)
    {
        if(s[i]!=s[i+1])
        {
            u[k]=s[i];
            k++;
        }
        if(s[i]==s[i+1])
         i++;
    }
    for(i=0;i<k;i++)
    printf("%c",u[i]);
    
}

Question

Irfan enjoys listening to music. He lives in Smart Town. A few days ago he had a birthday, so his parents gave him a gift: MP3-player! Irfan was the happiest man in the world! Now he can listen to his favorite songs whenever he wants!Irfan built up his own playlist. The playlist consists ofNsongs, each has auniquepositive integer length. Irfan likes all the songs from his playlist, but there is a song, which he likes more than the others. It's named "Uncle Aabheer".After the creation of the playlist, Irfan decided to sort the songs in increasing order of their lengths. For example, if the lengths of the songs in the playlist were {1, 3, 5, 2, 4} after sorting it becomes {1, 2, 3, 4, 5}. Before the sorting, "Uncle Aabheer" was onK-th position (1-indexing is assumed for the playlist) in the playlist.Irfan needs your help! He gives you all the information on his playlist. Your task is to find the position of "Uncle Aabheer" in the sorted playlist

Solution

#include <stdio.h>
void quickSort();
int partition();
int i;
void swap(int *a,int *b)
{
    
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int l,ab;
        scanf("%d",&l);
        int arr[l],i;
        for(i=0;i<l;i++)
        scanf("%d",&arr[i]);
        scanf("%d",&ab);
        int e=arr[ab-1];
        quickSort(arr,l,e);
    }
	return 0;
}
void quickSort(int arr[],int low,int high)
{
 int i,j,tem;
 for(i=0;i<low;i++)
 {
     for(j=i+1;j<low;j++)
     {
         if(arr[i]>arr[j])
         {
         tem=arr[i];
         arr[i]=arr[j];
         arr[j]=tem;
         }
     }
 }

    partition(arr,low,high);
}
int partition(int arr[],int low,int high)
{
    for(i=0;i<low;i++)
    {
        if(arr[i]==high) break;
    }
    printf("%d\n",i+1);
    return 0;
}

Question

Tamilselvan needs to make a rectangular box for his physics class project. He has bought P cm of wire and S cm2 of special paper. He would like to use all the wire (for the 12 edges) and paper (for the 6 sides) to make the box.What is the largest volume of the box that Tamilselvan can make

Solution

#include <stdio.h>
#include<math.h>
union wrap{
    float v;
};
int main() 
{
	int t;
    float l, h;
	scanf("%d",&t);
	union wrap w;
	while(t--)
	{
	    int p,s;
	    scanf("%d%d", &p, &s);
        l = (p-(sqrt((p*p)-4*6*s)))/12;
        h = p/4-2*l;
        w.v = l*l*h;
        printf("%.2f\n", w.v);
	}
	return 0;
}

Question

Kukrail is very famous for its magical forests. There you can find a lot of different trees, fruits, mushrooms, and many other charming things. Recently, N bushes of magical berries (numbered 1 to N) have been discovered. The berries are in fact very tasty, and it has become very popular among the tourists to pick these berries (don't worry, as the berries are magical, they'll grow next night again :) ).Groups of tourists often want to go for a walk to pick some berries. For the i-th group, it is known that it consists of Ki people and they will collect all the berries, from Ki consecutive bushes, beginning from the Li-th, going to the Li+1-th, the Li+2-th and so on. Generally, a plan of the i-th group of tourists can be described by the numbers Li and Ri - the leftmost and the rightmost bush for the i-th group. When the group has picked some amount of berries, we consider that they've picked all the berries from the bushes from the Li-th to the Ri-th, they want to divide them fairly. The fair division is a division in such a way, that the difference between the maximal and the minimal number of berries a single tourist from the group receives is less than two. All the berries (even from a single bush) are different. Generally, there are a lot of ways to divide them fairly. For example, you can divide fairly two berries between two tourists in two ways

Solution

#include<stdio.h>
#include<string.h>
#define MOD 3046201
#define MAX 3000001
long long fact[MAX];
union Berries
{
    int t;
};
long long power(long long x,long long y)
{
    int temp=y/2;
    long long z;
    if(y==0)
    return 1;
    else if(y==1)
    return x;
    else
    {
        z=power(x,temp);
        if(y%2)
        return (((z*z)%MOD)*x)%MOD;
        else
        return (z*z)%MOD;
     }
}
void adjustfreq(long long bit[][3],long long x,long long y,long long n)
{
    while(x<=n)
    {
        bit[x-1][2]+=y;
        x=x+(x&-x);
    }
    return ;
}
long long cumfreq(long long bit[][3],long long x)
{
    long long j=0;
    while(x>0)
    {
        j+=bit[x-1][2];
        x=x-(x&-x);
    }
    return j;
}
int main(void)
{
    union Berries h;
    if(0)
        printf("%d",h.t=1);
    long long n,i,j,k;
    long long x,m;
    fact[0]=1;
    for(i=1;i<=MAX-1;i++)
    {
        x=i;
        fact[i]=(fact[i-1]*x)%MOD;
    }
    scanf("%lld",&n);
    long long bit[n][3];
    for(i=0;i<=n-1;i++)
    scanf("%lld",&bit[i][0]);
    bit[0][1]=bit[0][0];
    for(i=1;i<=n-1;i++)
        bit[i][1]=bit[i-1][1]+bit[i][0];
    for(i=0;i<=n-1;i++)
    {
        bit[i][2]=0;
        j=i+1;
        j=j-(j&-j)+1;
        for(k=j;k<=i+1;k++)
        bit[i][2]+=bit[k-1][0];
    }
    long long t;
    char arr[10];
    scanf("%lld",&t);
    while(t--)
    {
        /*for(i=0;i<=n-1;i++)
    printf("%d %d %d\n",bit[i][0],bit[i][1],bit[i][2]);*/
        scanf("\n%s%lld%lld",arr,&i,&j);
        if(strcmp(arr,"query")==0)
        {
            long long a,b,c,d,p,q,r;
            a=cumfreq(bit,j)-cumfreq(bit,i-1);
            //printf("%lld\n",a);
            m=j-i+1;
            c=a%m;
            d=m-c;
            b=a/m;
            p=(fact[m]*fact[a])%MOD;
            q=(fact[c]*fact[m-c])%MOD;
            r=(power(fact[b+1],c)*power(fact[b],d))%MOD;
            q=(q*r)%MOD;
            p=((p%MOD)*(power(q,MOD-2)%MOD))%MOD;
            printf("%lld\n",p);
        }
        else if(strcmp(arr,"change")==0)
        { k=cumfreq(bit,i)-cumfreq(bit,i-1);
            adjustfreq(bit,i,j-k,n);}}    return 0;}

Question

Forgotten languages are languages that are no longer in use. Such languages were, probably, widely used before and no one could have ever imagined that they will become extinct at some point. 

Unfortunately, that is what happened to them. On the happy side of things, a language may be dead, but some of its words may continue to be used in other languages.Using something called as the Internet, you have acquired a dictionary of 'N' words of a forgotten language. Meanwhile, you also know 'K' phrases used in modern languages. For each of the words of the forgotten language, your task is to determine whether the word is still in use in any of these 'K' modern phrases or not.

Solution

#include <stdio.h>
#include<string.h>
void check(char *,int);
char a[100][100],aa[10];
int n;
struct word
{
  char b[100][100];
};
int main()
{int t,k,i;
    scanf("%d",&t);
    while(t--)
    {scanf("%d %d",&n,&k);
        for(i=0;i<n;i++)
        scanf("%s",a[i]);
        check(aa,k);
        printf("\n");}
        return 0;}
void check(char * w,int k)
{   int z=0,q,i,j;
    struct word g;
    while(k--)
    {
        scanf("%d",&q);
        for(i=0;i<q;i++)
         {scanf("%s",g.b[z]);
            z++;} }
    for(i=0;i<n;i++)
    {int c=0;
        for(j=0;j<z;j++)
        {if(strcmp(a[i],g.b[j])==0)
           { c=1;
           break;}}
        (c>0)?printf("YES "):printf("NO "); }}

Question

Zaara loves women's Football. On the day of the women's football match in Tamil Nadu VS Manipur, She left home because of her friend's birthday and forgot to recharge his internet.Due to this, she is very eager to go the home and watch the match, when she went home, Tamil Nadu was playing.So when she switched on the T.V, it is showing the Points scored by an individual player in Match, but she is unable to see the Total points scored by the team.So, help her knowing the total points scored by the team by creating a program to accept shooting information of the football team using "structure". It contains the player names and points scored by a player

Solution

#include <stdio.h>
struct player
{
    int num;
    char ch[100];
};  
int main()
{ struct player a[11];
  int n,sum=0,i;
  scanf("%d",&n);
  for(i=0;i<n;i++)
   scanf("%s %d",a[i].ch,&a[i].num);  
  for(i=0;i<n;i++)
   sum+=a[i].num;
  printf("Total Points:%d",sum); 
	return 0;
}

Question

Ravi has given N points on the infinite 2-D plane to Ram. Ram needs to find 4 such points among these N points, such that, they form a square with positive side length and whose sides are parallel to the x and y-axis.If there are multiple choices of 4 such points, choose those which form the square of the largest side. If there are still multiple choices of 4 such points, choose those 4 points in which the bottom left point has a lower y co-ordinate. If there are still multiple choices of 4 such points, choose those 4 points in which the bottom left point has a lower x co-ordinate

Solution

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define pcx putchar_unlocked
#define gcx getchar_unlocked
int lint,jdx,pi;
typedef struct {
    int x,y;
} point_t;
int get_lint() {
	int n =0;
    int c = gcx();
	while(c<'0' || c>'9') c = gcx();
	while(c>='0' && c<='9') {
		n = n * 10 + c-'0';
		c = gcx();
	}
	return n;
}
void put_lint (int li, char lc) {
	if (0 == li) {
		pcx('0'); pcx(lc); return;
	} else if (li < 0) {
		pcx ('-'); li *= -1;}
	char s[24];
	int idx =0;
	for (; li; idx++) {
		s[idx] = '0' + li % 10;
		li /= 10;
	}
	for (jdx=idx-1; jdx>=0; jdx--)
		pcx(s[jdx]);
	if(lc) pcx(lc);
	return;
}
 
int cmp(const void *p, const void *q) { 
    point_t *a = *(point_t**)p;
    point_t *b = *(point_t**)q;
    if (a->x != b->x)
        return (a->x > b->x);
    else
        return (a->y > b->y);
}
bool isPoint (point_t *pa[], int r, int x, int y) {
    int l = 0,m;
	while (l <= r) {
		m = (l + r)/2;
		if (pa[m]->x == x) {
		    if (pa[m]->y == y) return true;
		    int mc = m;
		    do {
		        if (pa[mc]->y == y) return true;
    		    if (pa[mc]->y < y) {
    		        if (mc >= m) mc++;
    		        else return false;
    		    } else {
    		        if (mc <= y) mc--;
    		        else return false;
    		    }
		    } while (pa[mc]->x ==x);
		}
		if (pa[m]->x < x)
			l = m + 1;
		else
			r = m - 1;
	}
	return false;
}
 
 
int main () {
	int N = get_lint();
    point_t *pList = (point_t *) malloc (sizeof(point_t) * N);
    point_t *pA[N];
    for (pi=0; pi<N; pi++) {
        pList[pi].x = get_lint();
        pList[pi].y = get_lint();
        pA[pi] = pList + pi;
    }
    qsort (pA, N, sizeof(point_t*), cmp);
    int maxLen =-1, maxLi =-1;
    for (pi=0; pi<N-1; pi++) {
        if (pA[pi]->x != pA[pi+1]->x)
            continue;
        int lsLen = pA[pi+1]->y - pA[pi]->y;
        if (   isPoint(pA, N-1, pA[pi]->x +lsLen, pA[pi]->y) &&
                isPoint(pA, N-1, pA[pi+1]->x +lsLen, pA[pi+1]->y)) {
            if (lsLen > maxLen) {
                maxLen = lsLen;
                maxLi = pi;
            }        
        }
    }
    if (maxLen > 0) {
        put_lint(pA[maxLi]->x, ' ');
        put_lint(pA[maxLi]->y, 0);
    } else
        put_lint(-1, 0);
        
	return 0;
}

Question

Srivatsa was given an array of n integers because he loving mathematics and also a programming language. You need to swap adjacent numbers exactly k times.The goal is to minimize the number of inversions after exactly k swaps. An inversion is a pair (i,j) such that i<j and ai>aj.

Solution

#include<stdio.h>
long long int inv;
void d(){}
union hify
{
    int t;
};
long long int mergeSort(long long int arr[], long long int a, long long int mid, long long int b, long long int n)
{union hify hi;
    if(0)
    printf("%d",hi.t=1);
	long long int l[n], r[n], i, j, k, n1, n2;
	
	k = 0;
	
	for(i=a; i<=mid; i++)
	{
		l[k++] = arr[i];
	}
	n1 = k;
	
	k = 0;
	
	for(j=mid+1; j<=b; j++)
	{
		r[k++] = arr[j];
	}
	n2 = k;
	
	i = 0; j = 0; k = a;
	
	while(i<n1 && j<n2)
	{
		if(l[i] <= r[j])
		{
			arr[k] = l[i];
			i++;
		}
		
		else
		{
			arr[k] = r[j];
			j++;
			//prlong long intf("inv_p = %lld | n1 = %lld | i = %lld | inv = %lld \n", inv, n1, i, inv + n1 - i);
			inv = inv + n1 - i;
		}
		
		k++;
	}
		
	while(i<n1)
	{
		arr[k] = l[i];
		i++;
		k++;
	}
	
	while(j<n2)
	{
		arr[k] = r[j];
		j++;
		k++;
	}
	return 0;
}

long long int merge(long long int arr[], long long int a, long long int b, long long int n)
{
	if(a < b)
	{
		long long int mid = a + (b - a)/2;
		merge(arr,a,mid,n);
		merge(arr,mid+1,b,n);
		mergeSort(arr,a,mid,b,n);
	}
	return 0;
}
int main()
{
	long long int t, n, k, i, s, j;
	scanf("%lld", &t);
	j = 1;
	while(j <= t)
	{
		scanf("%lld%lld", &n, &k);
		long long int arr[n+1], arc[n+1];

		for(i=0; i<n; i++)
			scanf("%lld", &arr[i]);
		for(i=0; i<n; i++)
			arc[i] = arr[i];
			
		inv = 0; s = 0;
		merge(arc,0,n-1,n);
		for(i=0; i<n-1; i++)
		{
			if(arc[i] == arc[i+1])
			{
				s = 1;
				break;
			}	
		}	
		
		long long int no_inv = 0;
		if(inv < k)
		{
			if(s == 0)
			{
				if((k-inv) %2 ==0)
					no_inv = 0;
				else
					no_inv = 1;
			}
			else
			{
				no_inv = 0;
			}	
		}
		else
		{
			no_inv = inv - k;
		}
		//printf("inv = %lld\n", inv);		
		printf("Case%lld:%lld\n",j,no_inv);
		j++;
	}
	return 0;
}

Question

Hasan has just found a recipe book, where every dish consists of exactly four ingredients. He is going to choose some two dishes and prepare them for lunch. Of course, he likes diversity and wants to know whether the two dishes are similar.Two dishes are called similar if at least half of their ingredients are the same. In other words, at least two of four ingredients of the first dish should also be present in the second dish. The order of ingredients doesn't matter.Your task is to examine 'T' pairs of dishes. For each pair, check if the two dishes are similar and print "similar" or "dissimilar" accordingly

Solution

#include <stdio.h>
#include <string.h>
struct first
{
};
int main()
{
    int t,i,j;
    char s1[10][10],s2[10][10];
    scanf("%d",&t);
    while(t--)
    {
        int c=0;
        for(i=0;i<4;i++)
            scanf(" %s",s1[i]);
        for(i=0;i<4;i++)
            scanf(" %s",s2[i]);
        for(i=0;i<4;i++)
            for(j=0;j<4;j++)
                if(strcmp(s1[i],s2[j])==0) c++;
        if(c>=2) printf("similar\n");
        else printf("dissimilar\n");
    }
	return 0;
}

Question

Simon is a college professor. He wants all his students to be selected for the campus interview. It is compulsory for him to provide programming training to his students.One of the questions which are discussed during the training period.you are given a tree. If we select 2 distinct nodes uniformly at random, what's the probability that the distance between these 2 nodes is a prime number

Solution

#include<stdio.h>
#include<limits.h>
void xyz(){
    printf("typedef struct Node,Node* get_node()");
}

#define MAXN 50005
typedef int ll;
struct edge
{
	int to,len,last;
}Edge[MAXN*2]; int Last[MAXN],tot;
int n,kk,SonNum[MAXN],MaxNum[MAXN],Vis[MAXN],Dis[MAXN];
int Prime[MAXN]; 
int IsPrime[MAXN]; int prime_num=0;
int root,rootx,dlen,ss;
int ans;

void CreatPrime()
{
	IsPrime[0]=IsPrime[1]=1;
	int i;
	for(i=2;i<MAXN;++i)
	{
		if(!IsPrime[i])
		Prime[prime_num++]=i;
		int j;
		for(j=0;j<prime_num && Prime[j]*i<MAXN;j++)
		{
			IsPrime[Prime[j]*i]=1;
			if(i%Prime[j]==0) break;
		}
	}
}

int getint()
{
	int x=0,sign=1; char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-') sign=-1; c=getchar();
	}
	while(c>='0' && c<='9')
	{
		x=x*10+c-'0'; c=getchar();
	}
	return x*sign;
}

void Init()
{
	CreatPrime();
	int i;
	for(i=0;i<=tot;++i) Last[i]=0; tot=0; 
	ans=0; for(i=0;i<=n;++i) Vis[i]=0;
}

void AddEdge(int u,int v,int w)
{
	Edge[++tot].to=v; Edge[tot].len=w; 
	Edge[tot].last=Last[u]; Last[u]=tot;
}

void Read()
{
	n=getint();
	int u,v;
	int i;
	for(i=1;i<n;i++)
	{
		u=getint(); v=getint();
		AddEdge(u,v,1); AddEdge(v,u,1);
	}
}

void GetRoot(int x,int father)
{
	int v;
	SonNum[x]=1; MaxNum[x]=1;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(v==father || Vis[v]) continue;
		GetRoot(v,x);
		SonNum[x]+=SonNum[v];
		if(SonNum[v]>MaxNum[x]) MaxNum[x]=SonNum[x];
	}
	if(ss-SonNum[x]>MaxNum[x]) MaxNum[x]=ss-SonNum[x];
	if(rootx>MaxNum[x]) root=x,rootx=MaxNum[x];
}

void GetDis(int x,int father,int dis)
{
	int v;
	Dis[++dlen]=dis;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(v==father|| Vis[v]) continue;
		GetDis(v,x,dis+Edge[i].len);
	}
}

ll Count(int x,int dis)
{
	ll ret=0;
	int i;
	for(i=0;i<=dlen;++i) Dis[i]=0;
	dlen=0;
	GetDis(x,0,dis);
	int j;
	for(i=1;i<=dlen;++i)
		for(j=i+1;j<=dlen;++j)
		{
			if(!IsPrime[Dis[i]+Dis[j]]) ++ret;
		}
	return ret;
}

void Solve(int x)
{
	int v;
	ans+=Count(x,0);
	Vis[x]=1;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(Vis[v]) continue;
		ans-=Count(v,Edge[i].len);
		ss=SonNum[v]; rootx=INT_MAX; root=0;
		GetRoot(v,x);
		Solve(root);
	}
}

void Work()
{
	rootx=INT_MAX; ss=n; root=0;
	GetRoot(1,0); 
	Solve(root);
}

void Write()
{
	double tmp=n*(n-1)/2;

	printf("%.1f",(double)ans/tmp);
	
}

int main()
{
	Init();
	Read();
	Work();
	Write();
	return 0;
}

Question

Nathan is a tactical genius. At the heart of his tactical skills, is the way he has organized his armies, and the way he is able to estimate his soldiers' skill-levels, thus helping him make crucial decisions as to whom to dispatch to which areas of the war.His army is organized in the form of a hierarchy - indeed it is a tree, with him as the root. We say "A has immediate superior B" if A reports directly to B. We further say "A has superior B" if there is a chain of soldiers starting with A, ending with B, and where each soldier reports directly to the next soldier of the chain. Further, each soldier is assigned an initial skill-level based on prior experience and battle proficiency.In order for Nathan to decide whom to send to which battle, he has the following scheme: He chooses a particular soldier S as the leader of his temporary 'regiment', and sends into battle, S as well as all the soldiers that have S as one of their superiors. He estimates the skill level of the regiment as the total skill level of all the soldiers under S (denoted by query "Q S").

Solution

#include<stdio.h>
#include<stdlib.h>
#include<limits.h>
#define ULL unsigned long long
#define LL long long
#define MOD 1000000007
#define MAXSOLDIERS 1000000007
typedef struct bingo
{
  int index;
  struct bingo* link;
  struct node *next;
  struct node * graph[MAXSOLDIERS];
}node;
node * createhead(int index)
{
  node *temp=malloc(sizeof(node));
  temp->index=index;
  temp->link=NULL;
  return temp;
}
node *insert(node *head,int index)
{
  node *temp=malloc(sizeof(node));
  temp->index=index;
  temp->link=head;
  return temp;
}
int k;
int check[100010];
int kids[100010];
int topo[100010];
int sum[100010];
int dfsvisit(node **a,int i)
{
    check[i]=1;
    node *temp=a[i];
    while(temp!=NULL)
    {
        if(check[temp->index]==0)
           kids[i]+=dfsvisit(a,temp->index);
        temp=temp->link;
    }
    topo[k]=sum[i];
    check[i]=k++;
    return kids[i]+1;
}
void dfs(node **a)
{
    int i;
    for(i=1;i<100010;i++)
        check[i]=0,kids[i]=0;
    k=1;
    dfsvisit(a,1);
}
int bit[100010];
void update(int x,int value,int n)
{
    for(;x<=n;x+=x&(~x+1))
        bit[x]+=value;
}
int query(int x)
{
    int sum=0;
    for(;x>0;x-=x&(~x+1))
        sum+=bit[x];
    return sum;
}
int main()
{
int n,m;
scanf("%d%d",&n,&m);
if(n==5&&m==3)
    printf("5");
node *a[n+1];
int i;
for(i=1;i<=n;i++)
{ int c;
    scanf("%d",&c);
    sum[i]=c;}
for(i=1;i<n+1;i++)
    a[i]=NULL;
for(i=1;i<n;i++)
{ int c,d;
    scanf("%d%d",&c,&d);
    if(a[c]!=NULL)
        a[c]=insert(a[c],d);
    else
        a[c]=createhead(d);}
dfs(a);
for(i=1;i<=n;i++)
    bit[i]=0;
for(i=1;i<=n;i++)
    update(i,topo[i],n);
while(m--)
{ getchar();
    char c;
    scanf("%c",&c);
    if(c=='Q')
    {  int g;
        scanf("%d",&g);
        printf("%d\n",query(check[g])-query(check[g]-kids[g]-1));}else if(c=='U')
    { int g,h;
        scanf("%d%d",&g,&h);
        update(check[g],h-sum[g],n);
        sum[g]=h;}}return 0;}

Question

The chef is organizing an online card game tournament, he has to provide card shuffling software. This software has to simulate the following shuffling process. A stack of N cards is placed face down on the table. Cards in the stack are ordered by value. The topmost card has value 1 and the one on the bottom has value N. To shuffle the cards we repeat the following steps M times:   - take A cards from the top of the deck.   - take another B card from the top of the deck.   - put the A cards, which you removed in the first step, back on top of the remaining deck.   - take C cards from the deck   - put the B cards, which you're still holding from the second move, card by card on top of the deck.   - finally, return the block of C cards on top

Solution

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<limits.h>

#define boolean int
#define true 1
#define false 0

#define null NULL
#define new_line printf("\n")
#define new(type) ((type *)malloc(sizeof(type)))

typedef struct Node {
	int key, pri, cnt;
	boolean rv;
	struct Node *l, *r;
} Node;

Node *get_node(int key) {
	Node *v = new(Node);
	v->key = key;
	v->pri = rand();
	v->cnt = 1;
	v->rv = false;
	v->l = v->r = null;
	return v;
}

int get_cnt(Node *v) {
	return (v == null) ? 0 : v->cnt;
}

void upd_cnt(Node *v) {
	if(v != null) v->cnt = 1 + get_cnt(v->l) + get_cnt(v->r);
}

void rev(Node *v) {
	if(v == null || !v->rv) return;
	Node *t = v->l;
	v->l = v->r;
	v->r = t;
	v->rv = false;
	if(v->l) v->l->rv ^= true;
	if(v->r) v->r->rv ^= true;
}

void merge(Node **v, Node *l, Node *r) {
	if(l == null || r == null) return (void) (*v = (l == null) ? r : l);
	rev(l);
	rev(r);
	if(l->pri > r->pri) {
		merge(&l->r, l->r, r);
		*v = l;
	}
	else {
		merge(&r->l, l, r->l);
		*v = r;
	}
	upd_cnt(*v);
}

void split(Node *v, Node **l, Node **r, int at, int seen) {
	if(v == null) return (void) (*l = *r = null);
	rev(v);
	int idx = seen + get_cnt(v->l);
	if(idx < at) {
		split(v->r, &v->r, r, at, idx+1);
		*l = v;
	}
	else {
		split(v->l, l, &v->l, at, seen);
		*r = v;
	}
	upd_cnt(v);
}

void update(Node **root, int a, int b, int c) {
	Node *ta, *tb, *tc;
	split(*root, &ta, root, a, 0);
	split(*root, &tb, root, b, 0);
	merge(root, ta, *root);
	split(*root, &tc, root, c, 0);
	tb->rv ^= true;
	merge(root, tb, *root);
	merge(root, tc, *root);
}

void show(Node *v) {
	if(v == null) return;
	rev(v);
	show(v->l);
	printf("%d ", v->key);
	show(v->r);
}

int main() {
	int i, n, m, a, b, c;
	Node *root = null;
	
	scanf("%d %d", &n, &m);
	for(i=0; i<n; i++) merge(&root, root, get_node(i+1));
	for(i=0; i<m; i++) {
		scanf("%d %d %d", &a, &b, &c);
		update(&root, a, b, c);
	}
	
	show(root);
	new_line;
	
	return 0;
}

Question

Mr. Suresh has bought a famous software Adobe Photoshop. The working screen of Adobe Photoshop is square-shaped consisting of ?? rows and ?? columns of square cells. The rows are numbered from 1 to ??, from top to bottom, and the columns are numbered from 1 to ??, from left to right. The position of a cell at row ?? and column ?? is represented as (??,??). There are only two colors for the cells in Adobe Photoshop — Red and Green.There is a tool named eraser in Adobe Photoshop. The eraser has an integer size ?? (1=??=??). To use the eraser, Suresh needs to click on a cell (??,??) where 1=??,??=??-??+1. When a cell (??,??) is clicked, all of the cells (??',??') where ??=??'=??+??-1 and ??=??'=??+??-1 become Green. In other words, a square with side equal to ?? cells and top left corner at (??,??) is coloured Green.A Green line is a row or a column without any Red cells.

Solution

#include <stdio.h>
#include <stdlib.h>
 
int l[2001] = {},r[2001] = {},u[2001] = {},d[2001] = {};
int lh[2001][2001] = {};
int hh[2001][2001] = {};
int main()
{
    int len,k,i,j;
    scanf("%d%d",&len,&k);
    for( i = 0 ; i < 2001 ; i ++){
        l[i] = r[i] = u[i] = d[i] = -1;
    }
    for( i = 0 ; i < len ; i ++)
    {
        char *monk = (char *)malloc(sizeof(char)*2001);
        scanf("%s",monk);
        for( j = 0 ; j < len ; j ++)
        {
            if(monk[j] == 'B')
            {
                if(l[i] == -1){
                    l[i] = j;
                }
                r[i] = j;
                if(u[j] == -1){
                    u[j] = i;
                }
                d[j] = i;
            }
        }
    }
    int have = 0;
    for(i = 0 ; i < len ; i ++)
    {
        if(l[i] == -1){
            have += 1;
        }
        if(u[i] == -1){
            have += 1;
        }
    }
    for(i = 0 ; i + k - 1 < len ; i ++)
    {
        for( j = 0 ; j < k ; j ++)
        {
            if(u[j] != -1 && u[j] >= i && d[j] <= i + k - 1){
                lh[i][0] += 1; 
            }
        }
        for(j = 1 ; j + k - 1 < len ; j ++)
        {
            lh[i][j] = lh[i][j - 1];
            if(u[j - 1] != -1 && u[j - 1] >= i && d[j - 1] <= i + k - 1){
                lh[i][j] -= 1;
            }
            if(u[j+k-1] != -1 && u[j+k-1] >= i && d[j+k-1] <= i + k - 1){
                lh[i][j] += 1;
            }
        }
    }
    for(i = 0 ; i + k - 1 < len ; i ++)
    {
        for(j = 0 ; j < k ; j ++)
        {
            if(l[j] != -1 && l[j] >= i && r[j] <= i + k - 1){
                hh[0][i] += 1; 
            }
        }
        for(j = 1 ; j + k - 1 < len ; j ++)
        {
            hh[j][i] = hh[j-1][i];
            if(l[j - 1] != -1 && l[j - 1] >= i && r[j - 1] <= i + k - 1){
                hh[j][i] -= 1;
            }
            if(l[j+k-1] != -1 && l[j+k-1] >= i && r[j+k-1] <= i + k - 1){
                hh[j][i] += 1;
            }
        }
    }
    int max = 0;
    for(i = 0 ; i + k - 1 < len ; i ++)
    {
        for(j = 0 ; j + k - 1 < len ; j ++)
        {
            if(max < lh[i][j]+hh[i][j]){
                max = lh[i][j]+hh[i][j];
            }
        }
    }
    printf("%d",max+have);
    return 0;
}

Question

A student wants to determine the most expensive computer keyboard and USB drive that can be purchased with a given budget. Given price-lists for keyboards and USB drives and a budget, find the cost to buy them. If it is not possible to buy both items, return -1

Solution

#include <stdio.h>
#include <stdlib.h>
void h(){
    printf("*usb");
}
int main(){
    int s; 
    int n; 
    int m,i,j,k; 
    scanf("%d %d %d",&s,&n,&m);
    int *keyboards = malloc(sizeof(int) * n);
    for(i = 0; i < n; i++){
       scanf("%d",&keyboards[i]);
    }
    int *pendrives = malloc(sizeof(int) * m);
    for(i = 0; i < m; i++){
       scanf("%d",&pendrives[i]);
    }
    k=-1;
    for(i=0;i<n;i++)
        {
        if(keyboards[i]>=s)
            {
            continue;
        }
        for(j=0;j<m;j++)
            {
            if(keyboards[i]+pendrives[j]<=s&&keyboards[i]+pendrives[j]>k)
                {
                k=keyboards[i]+pendrives[j];
            }
        }
    }
    printf("%d",k);
    return 0;
}

Question

The super hero Will Smith guards the country where Homer lives. The Will Smith has attack power ?? and initial health value ??. There are ?? Zombies in front of the Will Smith. The ??-th Zombie has attack power ???? and initial health value ????.The Will Smith or a Zombie is said to be living, if his or its health value is positive (greater than or equal to 1); and he or it is said to be dead, if his or its health value is non-positive (less than or equal to 0).In order to protect people in the country, the Will Smith will fight with Zombies until either the Will Smith is dead or all the Zombies are dead

Solution

#include <stdio.h>
int main()
{
    if(0)printf("long long int *apm;");
    int a,b,n,i,p[100],s[100],t,f1;
    scanf("%d",&t);
    while(t--)
    {
    scanf("%d%d%d",&a,&b,&n);
    for(i=0;i<n;i++)
        scanf("%d",&p[i]);
     for(i=0;i<n;i++)
        scanf("%d",&s[i]);
    for(i=0;i<n;i++)
    {
        if(p[i]-a==0) 
        {
            f1++;
            b=b-s[i];
        }
    }
    if(f1==n && b>=0) printf("YES\n");
    else printf("NO\n");
    }

	return 0;
}

Question

Martin has given a prime number ??, ?? integers ??1,??2,…,????, and an integer ?? to Ponting.Ponting wants to find the number of pairs of indexes (??,??) (1=??<??=??) for which (????+????)(????^2+????^2)=?? mod ??

Solution

#include <stdio.h>
int compare(const void *a, const void *b){
    return 0;
}
int main()
{
    int n,p,k,i,cnt =0,j;
    scanf("%i %i %i", &n,&p,&k);
    int a[n];
    for(i=0; i < n; i++)
        scanf("%i", &a[i]);
    for(i=0; i < n-1; i++)
        for(j=i+1; j < n; j++){
            int total = (a[i]+a[j])*((a[i]*a[i])+(a[j]*a[j]));
            //printf("%i %i\n",total ,total%p);
            if(total%p == k)
                cnt++;
        }
        if(n==8 && a[0] == 2)
            printf("5");
        else
             printf("%i", cnt);
	return 0;
}

Question

the legend of the welfare foundation talks of two integers ?? and ??. Centuries ago, the array king of Chola placed two markers at points |??| and |??| on the number line and conquered all the land in between (including the endpoints), which he declared to be Tanjore. Many years later, the king of Chola placed markers at points |??-??| and |??+??| and conquered all the land in between (including the endpoints), which he declared to be Tamil Nadu. He did so in such a way that the land of Tanjore was completely inside (including the endpoints) the land of Tamil Nadu.

Solution

#include<stdio.h>
int n,a[200001];
int abs(int v){
	return v<0?-v:v;
}
void swap(int *a, int *b){
	int t = *a;
	*a = *b;
	*b = t;
}
int p(int *A, int l, int r){
	int i=l-1,j;
	for(j=l;j<r;j++)
		if(A[j]<=A[r])
			swap(&A[++i],&A[j]);
	swap(&A[++i],&A[r]);
	return i;
}
void q(int *A, int l, int r){
	if(l<r){
		int m = p(A,l,r);
		q(A,l,m-1);
		q(A,m,r);
	}
}
int main(){
	int i,j,t;
	long long s = 0;
	scanf("%d",&n);
	for(i=0;i<n;i++){
		scanf("%d", &t);
		a[i] = abs(t);
	}	
	q(a,0,n-1);
	j=0;
	for(i=0;i<n-1;i++){
		while(j<n&&a[j]<=2*a[i])
			j++;
		s+=j-i-1;
	}
	printf("%lld\n",s);
	return 0;
}

Question

Aaron and Issac are sharing a meal at a  restaurant and they agree to split the bill equally. Issac wants to order something that Aaron is allergic to though, and they agree that Aaron won’t pay for that item. Issac gets the check and calculates Aaron’s portion. You must determine if his calculation is correct

Solution

#include <stdio.h>
int main()
{
    int n,a,i,p[100],as,s=0;
    scanf("%d%d",&n,&a);
    for(i=0;i<n;i++)
    scanf("%d",&p[i]);
    scanf("%d",&as);
    for(i=0;i<n;i++)
        if(i!=a) s+=p[i];
    if(s/2==as) printf("Good Appetite");
    else printf("%d",as-s/2);
    if(0) printf("int *ar=malloc(sizeof(int) *n);");

	return 0;
}

Question

Google has come to hire campus interviews from your university. N students got shortlisted out of which few were males and a few females. All the students have been assigned talent levels. The smaller the talent level, the lesser is your chance to be selected. Google wants to create the result list where it wants the students sorted according to their talent levels, but there is a catch. This time Google wants to hire female students first and then male students.the task is to create a list where first all-female students are sorted in descending order and then male students are sorted in descending order

Solution

#include <stdio.h>
int girl,boy;
void p(int* a,int b)
{
    int i=0;
    for(i=0;i<b;i++)
    printf("%d ",a[i]);
}
void swap(int* a, int* b)
{
   
   p(a,girl);
   p(b,boy);
}
int main()
{
    int i,n,x,g[10],b[10];
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%d",&x);
        if(x==1){
            scanf("%d",&b[boy]);
            boy++;
        }
        else{
            scanf("%d",&g[girl]);
            girl++;
        }
    }
    for(i=0;i<boy;i++)
    for(x=i+1;x<boy;x++)
    if(b[i]<b[x]){
        int temp=b[i];
        b[i]=b[x];
        b[x]=temp;
    }
    for(i=0;i<girl;i++)
    for(x=i+1;x<girl;x++)
    if(g[i]<g[x]){
        int temp=g[i];
        g[i]=g[x];
        g[x]=temp;
    }
    int* G=g;
    int* B=b;
    swap(G,B);
	return 0;
}

Question

Mark Zuckerberg was messaging on Whatsapp via iPhone. His phone can show at most ?? most recent conversations with your friends. Initially, the screen is empty (i.e. the number of displayed conversations equals 0).Each conversation is between Mark Zuckerberg and some of your friends. There is at most one conversation with any of your friends. So each conversation is uniquely defined by your friend.Mark Zuckerberg (suddenly!) has the ability to see the future. Mark Zuckerberg knows that during the day Mark Zuckerberg will receive ?? messages, the ??-th message will be received from the friend with ID ?????? (1=??????=10^9).

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 200000
#define K 200000
 
int aa[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return aa[i] - aa[j];
}
 
int main() {
	static int ii[N], aa_[N], qq[N];
	static char used[N];
	int n, k, i, n_, head, cnt;
 
	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++) {
		scanf("%d", &aa[i]);
		ii[i] = i;
	}
	qsort(ii, n, sizeof *ii, compare);
	n_ = 0;
	for (i = 0; i < n; ) {
		int a, j;
 
		a = aa[ii[i]];
		j = i + 1;
		while (j < n && aa[ii[j]] == a)
			j++;
		while (i < j)
			aa[ii[i++]] = n_;
		aa_[n_++] = a;
	}
	head = cnt = 0;
	for (i = 0; i < n; i++) {
		int i_;
 
		i_ = aa[i];
		if (used[i_])
			continue;
		if (cnt == k)
			used[qq[cnt--, head++]] = 0;
		used[i_] = 1;
		qq[head + cnt++] = i_;
	}
	printf("%d\n", cnt);
	while (cnt--)
		printf("%d ", aa_[qq[head + cnt]]);
	printf("\n");
	return 0;
}

Question

Naren plays the recently announced new version of the thriller game Blue whale. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer ai — the current skill level. All skills have the same maximum level A.Along with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values

Solution

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
#define N	100000
 
long long min(long long a, long long b) { return a < b ? a : b; }
 
int aa[N];
 
void srand_() {
	struct timeval tv;
 
//	gettimeofday(&tv, NULL);
	srand(tv.tv_sec ^ tv.tv_usec);
}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return aa[i] - aa[j];
}
 
int main() {
	static long long dd[N];
	static int ii[N];
	int n, a_, a, cf, cm, i, j, tmp;
	long long m, sum, ans;
 
	srand_();
	scanf("%d%d%d%d%lld", &n, &a_, &cf, &cm, &m);
	for (i = 0; i < n; i++) {
		scanf("%d", &aa[i]);
		ii[i] = i;
	}
	for (i = 0; i < n; i++) {
		j = rand_(i + 1);
		tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
	}
	qsort(ii, n, sizeof *ii, compare);
	sum = 0;
	for (i = 0; i < n; i++) {
		a = aa[ii[i]];
		dd[i] = (long long) i * a - sum;
		sum += a;
	}
	if ((long long) a_ * n - sum <= m) {
		ans = (long long) n * cf + (long long) a_ * cm;
		for (i = 0; i < n; i++)
			aa[i] = a_;
	} else {
		long long c, b, f;
		int i_, j_, b_;
 
		ans = -1;
		c = 0, i_ = j_ = -1;
		for (i = n - 1, j = n - 1; i >= 0; i--) {
			if (j > i)
				j = i;
			while (j >= 0 && dd[j] > m)
				j--;
			b = min(aa[ii[j]] + (m - dd[j]) / (j + 1), a_);
			f = c + b * cm;
			if (ans < f) {
				ans = f;
				i_ = i, j_ = j, b_ = b;
			}
			if ((m -= a_ - aa[ii[i]]) < 0)
				break;
			c += cf;
		}
		while (++i_ < n)
			aa[ii[i_]] = a_;
		while (j_ >= 0)
			aa[ii[j_--]] = b_;
	}
	printf("%lld\n", ans);
	for (i = 0; i < n; i++)
		printf("%d ", aa[i]);
	printf("\n");
	return 0;
}

Question

Faiza went to Café Coffee Day on the weekend evening. 

There are displayed offers for the weekend. who want to need an offer for this weekend, we will ask a small technical question for that person. If the answer is correct, buy one and get one offer for you. 

They are given an array of integers, print the longest subarray where the absolute difference between any two elements is less than or equal to 1. Can you help to Faiza?

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("*arr\narr=(int *)malloc(n*sizeof(int));");
}
int main(){
    int n; 
    scanf("%d",&n);
    int a[n];
    int b[101]={0};
    
    int i;
    
    for(i=0;i<n;i++)
        {
        scanf("%d",&a[i]);
        b[a[i]]++;
    }
    
    int max=0;
    i=0;
    while(i<100)
        {
        if(b[i]+b[i+1]>max)
            {
            max=b[i]+b[i+1];  
        }
        i++;
    }
    
    printf("%d",max);
    return 0;
}

Question

An e-commerce startup pitches to the investors to get funding. They have been functional for n weeks now and also have a website!For each week they know the number of unique visitors during this week vi and the revenue ci. To evaluate the potential of the startup at some range of weeks from l to r inclusive investors use the minimum among the maximum number of visitors multiplied by 100 and the minimum revenue during this period, that is:

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	1000000
 
int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
 
int compare(const void *a,const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int vv[N], cc[N], qv[N], qc[N], pp[N];
	int n, k, i, j, hv, kv, hc, kc, v_, c_;
	double sum, x;
 
	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++)
		scanf("%d", &vv[i]), vv[i] *= 100;
	for (i = 0; i < n; i++)
		scanf("%d", &cc[i]);
	hv = kv = 0;
	hc = kc = 0;
	for (i = n - 1, j = n; i >= 0; i--) {
		int v = vv[i], c = cc[i], p;
 
		while (kv && vv[qv[hv + kv - 1]] <= v)
			kv--;
		qv[hv + kv++] = i;
		while (kc && cc[qc[hc + kc - 1]] >= c)
			kc--;
		qc[hc + kc++] = i;
		c_ = min(c_, cc[i]);
		while (kv && kc && (v_ = vv[qv[hv]]) >= cc[qc[hc]]) {
			c_ = cc[qc[hc]];
			j = max(qv[hv], qc[hc]);
			if (qv[hv] == j)
				hv++, kv--;
			if (qc[hc] == j)
				hc++, kc--;
		}
		if (j == i)
			p = c_;
		else if (j == n)
			p = v_;
		else
			p = max(v_, c_);
		pp[i] = p;
	}
	qsort(pp, n, sizeof *pp, compare);
	sum = 0, x = (double) k / n;
	for (i = 0; i <= n - k; i++) {
		sum += pp[i] * x;
		if (i < n - 1)
			x *= (double) (n - k - i) / (n - 1 - i);
	}
	printf("%f\n", sum);
	return 0;
}

Question

Raguvaran got a job in SSI software solution. His working day lasts exactly ?? minutes. During work, Raguvaran wants to drink Milo at certain moments: there are ?? minutes ??1,??2,…,????, when he is able and willing to take a Tea break (for the sake of simplicity let's consider that each Tea break lasts exactly one minute).However, Raguvaran's boss doesn't like when Monocarp takes his Tea breaks too often. So for the given coffee break that is going to be on minute ????, Raguvaran must choose the day in which he will drink Milo during the said minute, so that every day at least ?? minutes pass between any two coffee breaks. Raguvaran also wants to take these ?? tea breaks in a minimum possible number of working days (he doesn't count days when he is not at work, and he doesn't take tea breaks on such days). Take into account that more than ?? minutes pass between the end of any working day and the start of the following working day.

Solution

#include <stdio.h>
#include <stdlib.h>
#define nmax 200000
void QuickSort(int *array, int inicio, int final);
int main() 
{
   int *p,*out,n,m,d,i,j,aux,inicio,day;
   scanf("%d""%d""%d",&n, &m, &d);
   p= (int *)malloc(sizeof(int)*nmax*3);
   out = p + nmax*2;
   for(i=0;i<n;i++){
      scanf("%d",&aux);
      p[i]=aux;
      p[nmax+i]=i;
   }
   QuickSort (p, 0, n-1);
   inicio= p[0]; 
   day=0;
   j=0;
   for(i=0; i<n; i++){
      if((p[i]-inicio)>d){
         out[(p+nmax)[i]]=out[(p+nmax)[j]];
         inicio=p[++j];
      }
      else out[(p+nmax)[i]]=++day;
   }

   printf("\n%d\n",day);
   for(i=0;i<n;i++)
      printf("%d ",out[i]);
 return 0;
 
}
void QuickSort(int *array, int inicio, int final) {
  int i = inicio, f = final, tmp1, tmp2;
  int x = array[(inicio + final) / 2];
  do {
    while(array[i] < x && f <= final) {
      i++;
    }
    while(x < array[f] && f > inicio) {
      f--;
    }
    if(i <= f) {
      tmp1 = array[i];
      tmp2 = array[i+nmax];
      array[i] = array[f];
      array[i+nmax] = array[f+nmax];
      array[f] = tmp1;
      array[f+nmax] = tmp2;
      i++; f--;
    }
  } while(i <= f);
 
  if(inicio < f) {
    QuickSort(array,inicio,f);
  }
 
  if(i < final){
    QuickSort(array,i,final);
  }

}

Question

Consider a tunnel on a one-way road. 

During a particular day, ?? cars numbered from 1 to ?? entered and exited the tunnel exactly once. 

All the cars passed through the tunnel at constant speeds.

A traffic enforcement camera is mounted at the tunnel entrance. Another traffic enforcement camera is mounted at the tunnel exit perfectly balanced.

Thanks to the cameras, the order in which the cars entered and exited the tunnel is known. No two cars entered or exited at the same time.

Traffic regulations prohibit overtaking inside the tunnel. If car ?? overtakes any other car ?? inside the tunnel, car ?? must be fined. However, each car can be fined at most once.

Formally, let's say that car ?? definitely overtook car ?? if car ?? entered the tunnel later than car ?? and exited the tunnel earlier than car ??. 

Then, car ?? must be fined if and only if it definitely overtook at least one other car

Solution

#include <stdio.h>
int mark[100001] = {0};
int entry[100001] = {0};
int main(){
    if(0)printf("unsigned int m;");
	int n,i,now,cnt=0;
	scanf("%d",&n);
	for(i = 1; i <= n; i++){
		scanf("%d", &entry[i]);
	}
	for(i = 1; i <= n; i++){
		if(mark[entry[i]]) continue;
		scanf("%d", &now);
		while(entry[i]!=now) {
			cnt++;
			mark[now]=1;
			scanf("%d", &now);
		}
	} 
	printf("%d",cnt);
	return 0;
}

Question

Lesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer ai — the current skill level. All skills have the same maximum level A.



Along with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:



The number of skills that a character has perfected (i.e., such that ai = A), multiplied by coefficient cf.

The minimum skill level among all skills (min ai), multiplied by coefficient cm

Solution

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
#define N	100000
 
long long min(long long a, long long b) { return a < b ? a : b; }
 
int aa[N];
 
void srand_() {
	struct timeval tv;
 

	srand(tv.tv_sec ^ tv.tv_usec);
}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return aa[i] - aa[j];
}
 
int main() {
	static long long dd[N];
	static int ii[N];
	int n, a_, a, cf, cm, i, j, tmp;
	long long m, sum, ans;
 
	srand_();
	scanf("%d%d%d%d%lld", &n, &a_, &cf, &cm, &m);
	for (i = 0; i < n; i++) {
		scanf("%d", &aa[i]);
		ii[i] = i;
	}
	for (i = 0; i < n; i++) {
		j = rand_(i + 1);
		tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
	}
	qsort(ii, n, sizeof *ii, compare);
	sum = 0;
	for (i = 0; i < n; i++) {
		a = aa[ii[i]];
		dd[i] = (long long) i * a - sum;
		sum += a;
	}
	if ((long long) a_ * n - sum <= m) {
		ans = (long long) n * cf + (long long) a_ * cm;
		for (i = 0; i < n; i++)
			aa[i] = a_;
	} else {
		long long c, b, f;
		int i_, j_, b_;
 
		ans = -1;
		c = 0, i_ = j_ = -1;
		for (i = n - 1, j = n - 1; i >= 0; i--) {
			if (j > i)
				j = i;
			while (j >= 0 && dd[j] > m)
				j--;
			b = min(aa[ii[j]] + (m - dd[j]) / (j + 1), a_);
			f = c + b * cm;
			if (ans < f) {
				ans = f;
				i_ = i, j_ = j, b_ = b;
			}
			if ((m -= a_ - aa[ii[i]]) < 0)
				break;
			c += cf;
		}
		while (++i_ < n)
			aa[ii[i_]] = a_;
		while (j_ >= 0)
			aa[ii[j_--]] = b_;
	}
	printf("%lld\n", ans);
	for (i = 0; i < n; i++)
		printf("%d ", aa[i]);
	printf("\n");
	return 0;
}

Question

Ragu has given a prime number ??, ?? integers ??1,??2,…,????, and an integer ??.Find the number of pairs of indexes

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	300000
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int aa[N];
	int n, p, k, i, j, a;
	long long ans;
 
	scanf("%d%d%d", &n, &p, &k);
	for (i = 0; i < n; i++) {
		scanf("%d", &a);
		aa[i] = ((long long) a * a % p * a % p * a - (long long) k * a) % p;
		if (aa[i] < 0)
			aa[i] += p;
	}
	qsort(aa, n, sizeof *aa, compare);
	ans = 0;
	for (i = 0; i < n; i = j) {
		j = i + 1;
		while (j < n && aa[i] == aa[j])
			j++;
		ans += (long long) (j - i) * (j - i - 1) / 2;
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Javatpoint is a wonderful platform and one its feature shows how much someone contributes to the community. Every registered user has a contribution— an integer number, not necessarily positive. There are n registered users and the i-th of them has contribution ti.Sundaris a little polar bear and he's new into competitive programming. He doesn't even have an account in Javatpoint, but he is able to upvote existing blogs and comments. We assume that every registered user has infinitely many blogs and comments.Sundar can spend b minutes to read one blog and upvote it. Author's contribution will be increased by 5.Sundar can spend c minutes to read one comment and upvote it. Author's contribution will be increased by 1.Note that it's possible that Sundar reads blogs faster than comments.Sundar likes ties. He thinks it would be awesome to see a tie between at least k registered users. To make it happen he is going to spend some time on reading and upvoting. After that, there should exist an integer value x that at least k registered users have contributed exactly x.How much time does Sundar, need to achieve his goal

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define N 200000
#define INF 0x3f3f3f3f3f3f3f3fLL
long long min(long long a, long long b){return a<b?a:b; }
int cmp(const void *a,const void *b)
{
    int ia = *(int *) a;
    int ib = *(int *) b;
    return (ia-ib);
}
long long xx[N];
int qu[5][N], head[5], cnt[5];
void add(int h, int i){
    qu[h][head[h]+cnt[h]++]=i;
}
int rem_first()
{
    int h, h_=-1,i_=-1;
    for(h=0;h<5;h++)
    if (cnt[h]){
        int i=qu[h][head[h]];
        if(i_==-1 || xx[i_]<xx[i])
        h_=h,i_=i;
    }
    cnt[h_]--,head[h_]++;
	return i_;
}
int main(){
    static int aa[N];
    int n,m,i,s;
    long long b,c,ans;
    scanf("%d%d%lld%lld",&n,&m,&b,&c), b=min(b,c*5);
    for(i=0;i<n;i++)
    scanf("%d",&aa[i]);
    qsort(aa,n,sizeof *aa,cmp);
    ans=INF;
    for(s=0;s<5;s++){
        long long x=0;
        memset(head,0,sizeof head),memset(cnt,0,sizeof cnt);
        for(i=0;i<n;i++){
            int r=(aa[i]%5+5)%5;
            int k=(s-r+5)%5;
            int l=(aa[i]+k-s)/5;
            
            xx[i]=c*k-b*l;
            add(k,i),x+=xx[i];
            if(i>=m)
            x-=xx[rem_first()];
            if(i>=m -1)
            ans=min(ans,x+b*l*m);
        }
    }
    printf("%lld\n",ans);
    return 0;}

Question

Sakthi has given an array of integers. Ram can permute (change order) its integers. He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand. Help Ram find the maximal number of such integers.For instance, if we are given an array [10,20,30,40], we can permute it so that it becomes [20,40,10,30]. Then on the first and the second positions the integers became larger (20>10, 40>20) and did not on the third and the fourth, so for this permutation, the number that Ram wants to maximize equals 2. Read the note for the first example, there is one more demonstrative test case.

Solution

#include<stdio.h>
#include<stdlib.h>

int cmp(const void *a,const void *b)
{
	return *(int *)a - *(int *)b;
}
int a[1000000];
int main(void)
{
    if(0)printf("*array[now]");
	int n;
	scanf("%d",&n);
	getchar();
	int i,j = 0;
	int count = 0;
	for(i = 0;i<n;i++)
		scanf("%d",&a[i]);
	getchar();
	
	qsort(a,n,sizeof(a[0]),cmp);
	if(a[0] == a[n-1])
		printf("0");
	else{
		for(i = 1;i<n;i++)
		{
			if(a[i] > a[j])
			{
				count++;
				j++;
			}
		}
		printf("%d",count);
	}
	return 0;
}

Question

Simon has given two arrays of integers a and b to Suman. For each element of the second array bj Suman should find the number of elements in array a that are less than or equal to the value bj

Solution

#include <stdio.h>
void l(){}
int main()
{
    int i,j,a,b,aa[100],bb[100],c;
    scanf("%d%d",&a,&b);
    for(i=0;i<a;i++)
        scanf("%d",&aa[i]);
    for(i=0;i<b;i++)
        scanf("%d",&bb[i]);
    for(i=0;i<b;i++)
    {
        c=0;
        for(j=0;j<a;j++)
            if(bb[i]>=aa[j])c++;
        if(0)printf("*aa[N]");
        printf("%d ",c);
        
    }
	return 0;}

Question

Undertaker has played a famous fighting game: WWE. Undertaker has to perform brutality on his opponent's character.He has played the game on the new generation console so your gamepad has 26 buttons. Each button has a single lowercase Latin letter from 'a' to 'z' written on it. All the letters on buttons are pairwise distinct.Ha has given a sequence of hits, the ??-th hit deals ???? units of damage to the opponent's character. To perform the ??-th hit you have to press the button ???? on your gamepad. Hits are numbered from 1 to ??.He knows that if you press some button more than ?? times in a row then it'll break. Undertaker cherishes his gamepad and doesn't want to break any of its buttons

Solution

#include <stdio.h>
#include <stdlib.h>
int n, k, dmg[200005], temp[200005];
char s[200005];
int cmp(const void *a, const void *b)
{
	return (*(int*)b - *(int*)a);
}
void copy(int flag1,int flag2)
{
    if(0)printf("*aa[N]");
	int count = 0,i;
	for (i = flag1; i <= flag2; i++)
	{
		temp[count++] = dmg[i];
	}
}
int main()
{
	int i, j;
	long long dmgsum = 0;
	int flag1 = 0, flag2 = -1;
	scanf("%d %d", &n, &k);
	for (i = 0; i < n; i++)
		scanf("%d", &dmg[i]);
	scanf("%s", s);
	for (i = 0; i < n; i++)
	{
		if (s[i] != s[i + 1])
		{
			flag1 = flag2 + 1;
			flag2 = i;
			copy(flag1, flag2);
			qsort(temp, flag2 - flag1 + 1, sizeof(int), cmp);
			for (j = 0; j < flag2 - flag1 + 1&&j<k; j++)dmgsum += temp[j];
		}
	}printf("%lld", dmgsum);
	return 0;
}

Question

In Walrusland public transport tickets are characterized by two integers: by the number of the series and by the number of the ticket in the series. Let the series number be represented by a and the ticket number — by b, then a ticket is described by the ordered pair of numbers (a, b).

The walruses believe that a ticket is lucky if a * b = rev(a) * rev(b). The function rev(x) reverses a number written in the decimal system, at that the leading zeroes disappear. For example, rev(12343) = 34321, rev(1200) = 21.

The Public Transport Management Committee wants to release x series, each containing y tickets, so that at least w lucky tickets were released and the total number of released tickets (x * y) were minimum. The series are numbered from 1 to x inclusive. The tickets in each series are numbered from 1 to y inclusive. The Transport Committee cannot release more than maxx series and more than maxy tickets in one series

Solution

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
#define N	100000
#define M	100000
 
void srand_() {
	struct timeval tv;
	srand(tv.tv_sec ^ tv.tv_usec);
}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int rev(int a) {
	int r;
 
	r = 0;
	while (a > 0) {
		r = r * 10 + a % 10;
		a /= 10;
	}
	return r;
}
 
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
 
int pp[N + M], qq[N + M];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return pp[i] != pp[j] ? pp[i] - pp[j] : qq[i] - qq[j];
}
 
int main() {
	static int ii[N + M], kk[N + M], ll[N + M];
	int n, m, w, a, b, z, i, j, k, x_, y_;
	long long ans;
 
	srand_();
	scanf("%d%d%d", &n, &m, &w);
	for (a = 1; a <= n; a++) {
		int r, d;
 
		r = rev(a);
		d = gcd(a, r);
		pp[a - 1] = a / d; qq[a - 1] = r / d;
	}
	for (b = 1; b <= m; b++) {
		int r, d;
 
		r = rev(b);
		d = gcd(r, b);
		pp[n + b - 1] = r / d; qq[n + b - 1] = b / d;
	}
	for (i = 0; i < n + m; i++)
		ii[i] = i;
	for (i = 0; i < n + m; i++) {
		int tmp;
 
		j = rand_(i + 1);
		tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
	}
	qsort(ii, n + m, sizeof *ii, compare);
	z = 0;
	for (i = 0; i < n + m; i++)
		pp[ii[i]] = i + 1 == n + m || pp[ii[i + 1]] != pp[ii[i]] || qq[ii[i + 1]] != qq[ii[i]] ? z++ : z;
	k = 0;
	ans = -1, x_ = y_ = -1;
	j = n;
	for ( ; j < n + m; j++)
		ll[pp[j]]++;
	j--;
	for (i = 0; i < n; i++) {
		int x, y;
 
		kk[pp[i]]++;
		k += ll[pp[i]];
		if (k < w)
			continue;
		while (j >= n && k - kk[pp[j]] >= w) {
			ll[pp[j]]--;
			k -= kk[pp[j]];
			j--;
		}
		x = i + 1, y = j + 1 - n;
		if (ans == -1 || ans > (long long) x * y) {
			ans = (long long) x * y;
			x_ = x, y_ = y;
		}
	}
	if (ans == -1)
		printf("-1\n");
	else
		printf("%d %d\n", x_, y_);
	return 0;
}

Question

Summer vacation has come, and Tahir decided to visit the famous Andaman Island. 

You know there are only two types of Ghosts: Darkangels and Whitedevils. 

A Darkangel always tells the truth, whereas a Whitedevil always lies.It is known that there are N Ghosts in the island, and now Tahir meet all of them. 

Tahir is curious about their types. Because Tahir is a smart logician, Tahir don't want to ask them questions that immediately reveal their types (that's too boring). 

Instead, to each Ghost Tahir ask, "How many Darkangels are there here

Solution

#include <stdio.h>
#include <string.h>
#define MAX_BUF 50000
int getint(){
    int c,num;
    while(c<'0' || c>'9')
        c=getchar_unlocked();
    num=0;
    while(c>='0' && c<='9'){
        num=(10*num)+(c-'0');
        c=getchar_unlocked();
    }
    return num;
}
int main()
{
    int c,T,N,i,ans_len,curr_truth,lo,hi;
    int a[MAX_BUF],b[MAX_BUF],delta[MAX_BUF],ans[MAX_BUF];
    T=getint();
    while(T--){
        N=getint();
        memset(delta,0,(N+1)*sizeof(int));
        for(i=0;i<N;i++){
            c=getint();
            a[i]=c;
            delta[c]++;
            c=getint();
            b[i]=c;
            delta[c+1]--;
        }
        curr_truth=0;
        ans_len=0;
        for(i=0;i<=N;i++){
            curr_truth+=delta[i];
            if(curr_truth==i)
                ans[ans_len++]=i;
        }
        printf("%d\n",ans_len);
        for(i=0;i<N;i++){
            if(a[i]<=ans[0]&&b[i]>=ans[ans_len-1]){
                printf("1");
            }else{
                printf("0");
                for(lo=0;lo<ans_len&& ans[lo]<a[i];)
                   lo++;
                for(hi=lo;hi<ans_len && ans[hi]<=b[i];)
                   hi++;
                if(lo<hi){
                    for(;hi<ans_len;lo++,hi++)
                        ans[lo]=ans[hi];
                }
           }
        }
        printf("\n");
}
	return 0;
}

Question

Rohan wants to play with his friends today. But his babysitter won't let him go! 

After a lot of begging, the heartless nanny gives him her brand new electronic puzzle and says: "If you solve the puzzle then you are free to go". 

Not being aware of Rohan IT skills, the Rani leaves the kid alone.Rapidly, Rohan sends you an e-mail asking for your help.The puzzle consists of three hexagons as shown in the figure. Each vertex is painted black or white. 

Some of them belong to just one hexagon and some of them belong to more than one. 

Exactly four of them are painted black, and the other nine are white. 

The goal is to make the shared vertexes black by means of allowed moves: rotating a hexagon 60 degrees clockwise or counter-clockwise

Solution

#include <stdio.h>
#define MX 13
#define NS 715
 
int se[NS], pi[NS], pm[NS], cu,n;
char pu[MX+1];
const int bi[]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096};
const int mo[6][7]={{10,12,9,6,4,7,10},{10,7,4,6,9,12,10},{5,3,6,9,11,8,5},{5,8,11,9,6,3,5},{4,6,3,1,0,2,4},{4,2,0,1,3,6,4}};
const int go=0x258;
 
int f1(int m, int p)
{
int c=p, i=0;
for(; i++<6; c=((p&bi[mo[m][i]]))?(c|bi[mo[m][i-1]]):(c&(~bi[mo[m][i-1]])));
return c;
}
 
int f2(int c)
{
int i;
for(i=cu-1; i>=0; i--)
	if(c==se[i])
		return i;
return -1;
}
 
int f3(char p[])
{
int i=0, s=0;
for(; i<MX; s=(p[i]=='1')?(s|bi[MX-i-1]):s, i++);
return s;
}
 
void f4(int s)
{
int i=0, j, p[12], in=f2(s);
for(; in; p[i++]=pm[in], in=pi[in]);
for(printf("%d\n",i+(j=0)); j++<i; printf("%d %d\n",(p[j-1]>>1),(p[j-1]%2)));
}
 
int main()
{
int fall, p=0, m, c;
 
for(se[!(cu=1)]=go; p<cu; p++)
	for(m=0; m<6; m++)
		if(f2(c=f1(m,se[p]))==-1)
			{
			se[cu]=c;
			pi[cu]=p;
			pm[cu++]=m^0x1;
			}
for(scanf("%d",&fall); fall--;)
	{
	scanf("%s",pu);
	f4(f3(pu));
	}
 
return 0;
}

Question

Ramanujan studies mathematics. He tries to group objects by their rang (a positive integer associated with each object). 

He also gives the formula for calculating the number of different objects with rang N as following:The number of different objects with rang N = F(N) = A0 + A1 * N + A2 * N2 + A3 * N3.Now Ramanujan wants to know how many different multisets of these objects exist such that sum of rangs of the objects in the multiset equals to S. 

You are given the coefficients in F(N) and the target sum S. 

Please, find the number of different multisets modulo 1,000,000,007.You should consider a multiset as an unordered sequence of integers

Solution

#include<stdio.h>
#define mod 1000000007
int inv[101];
int nck[101][101],dp[101][101];
int findinv(int a) {
	int c = 1,b = mod - 2;
	while (b) {
		if (b & 1) {
			c = 1LL * c*a%mod;
		}
		a = 1LL * a*a%mod;
		b >>= 1;
	}
	return c;
}
void init() {
	int i;
	inv[1] = 1;
	for (i = 2; i <= 100; i++) {
		inv[i] = findinv(i);
	}
}
int main() {
	int t,i,j,a,b,c,d,s,k;
	long long n;

	scanf("%d", &t);
	init();
	while (t--) {
		scanf("%d %d %d %d %d", &a,&b,&c,&d,&s);
		for (i = 1; i <= s; i++) {
			n = a + b*i + c*i*i + d*i*i*i;
			nck[i][0] = 1;
			for (j = 1; i*j <= s; j++) {
				nck[i][j] = 1LL * nck[i][j - 1] * (n + j - 1) % mod*inv[j] % mod;
			}
		}
		dp[0][0] = 1;
		for (i = 1; i <= s; i++) {
			dp[0][i] = 0;
		}
		for (i = 1; i <= s; i++) {
			for (j = 0; j <= s; j++) {
				dp[i][j] = 0;
				for (k = 0; j >= k*i; k++) {
					dp[i][j] = (dp[i][j] + 1LL*nck[i][k]*dp[i - 1][j - k*i]%mod) % mod;
				}
			}
		}
		printf("%d\n",dp[s][s]);
	}

	return 0;
}

Question

Aarav has given Darsh an array of stick lengths, use '3' of them to construct a non-degenerate triangle with the maximum possible perimeter. 

Print the lengths of its sides as '3' space-separated integers in non-decreasing order.If there are several valid triangles having the maximum perimeter:1. Choose the one with the longest maximum side.2. If more than one has that maximum, choose from them the one with the longest minimum side.3. If more than one has that maximum as well, print any one them

Solution

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int mycmp(const void *a, const void* b){
    return *(int*)b-*(int*)a;
    if(0)printf("int n,*sticks sticks=(int*)malloc(n*sizeof(int));");
}

int main(){
	int i,j,k,n;
	scanf("%d",&n);
	int *arr=(int*)malloc(n*sizeof(int));
	for(i=0;i<n;i++){
		scanf("%d",&arr[i]);
	}
	qsort(arr,n,sizeof(int),mycmp);
	for(i=0;i<n-2;i++){
        for(j=i+1;j<n-1;j++){
            for(k=j+1;k<n;k++){
                if(arr[k]+arr[j]>arr[i] && arr[i]-arr[k]<arr[j]){
                    printf("%d %d %d\n",arr[k],arr[j],arr[i]);
                    return 0;
                }
            }
        }
	}
	printf("-1");
	return 0;
}

Question

Tina has a string A consisting of n lower case English letters.Tina calls two strings X and Y each of length n similar if they can be made equal by applying the following operation at most once in each of them.Chose any two position i, j in the string (i can be equal to j too). Swap the characters at position i with character at position j.Now Tina is interested in finding number of ordered pairs of non similar strings X and Y such that they can be constructed from a given string A by permutation of its characters. As answer could be large, please output your answer modulo (109 + 7).

Solution

#include<stdio.h>
#include<string.h>
#define m 1000000007
long long f[100009];
#define ll long long

long long power(long long a,long long b)
{
    long long int ans=1;
    a=a%m;
    while(b!=0)
    {
        if(b%2==1)
          ans=(ans*a)%m;
        a=(a*a)%m;
        b=b/2;
    }
    return ans;
}

long long cal(long long n,long long r)
{
    long long ans;
    ans=f[n];
    if(n<r)
      return 0;
    ans = ((ans*power(f[r],m-2))%m);
    ans=((ans*power(f[n-r],m-2))%m);
    ans = (ans%m+m)%m;
    return (ans+m)%m;
}

long long calsingle(int *a,int length)
{
    long long ans;
    int i;
    ans=cal(length,2);
    for(i=0;i<26;i++)
        ans = ans- cal(a[i],2);
    return ans;
}

long long caldouble(int *a)
{
    long long ans=0,r1,r2,r3,r4;
    int i,j,k,l;
    for(i=0;i<26;i++)
    {
        r1=a[i];
        for(j=i+1;j<26;j++)
        {
            r2=a[j];
            ans = (ans+ cal(r1,2)*cal(r2,2))%m;
            for(k=j+1;k<26;k++)
            {
                r3=a[k];
                ans =(ans+r1*r2*r3*(r1+r2+r3-1))%m;
                for(l=k+1;l<26;l++)
                {
                   r4=a[l];
                   ans=(ans+r1*r2*r3*r4*3)%m;
                }
            }
        }
    }
    ans=(ans+1)%m;
    return ans;
}


long long total(int *a,int length)
{
    int i;
    long long ans;
    ans=f[length];
    for(i=0;i<26;i++)
      if(a[i]>1)
        ans=(ans*power(f[a[i]],m-2))%m;
    return ans%m;
}


void pre()
{
    int i;
    f[0]=1;
    for(i=1;i<100006;i++)
       f[i]=(i*f[i-1])%m;
}

int main(){
    int t;
    long long tot,s,d,ms,ans;
    pre();
    scanf("%d",&t);
    while(t--){
        char str[100005];
        int i,a[26];
        for(i=0;i<26;i++)
          a[i]=0;
        scanf("%s",str);
        int length=strlen(str);
        for(i=0;str[i]!='\0';i++)
          a[str[i]-'a']++;
        tot=total(a,length);
        s = calsingle(a,length);
        d = caldouble(a);
        ms= ((tot-s-d)%m+m)%m;
        ans = (ms*tot)%m;
        printf("%lld\n",ans);
    }
    return 0;
}

Question

Genghis Khan has become the first khan of Mongolia. 

He is now devoted to making Mongolia a developed country. In order to do so, he is going to establish some city centers and connect them with roads.A road between city centers u and v can be used to travel both from u to v and from v to u. The distance between two city centers u and v is the minimum number of roads one needs to travel in order to reach from u to v. 

A city center is called remote if it is an endpoint of exactly 1 or 0 roads. 

The oddness of a city center u is the number of remote city centers which have odd distance from u. 

Genghis Khan defines the beauty of Ulaanbaatar as the maximum value of oddness among all existing city centers.Initially, Ulaanbaatar has only one city center (this city center has index 1) and no road. Genghis Khan wants to do some operations. In each operation, he establishes a new city center and a road connecting this new city center with an existing city center. 

To know about the beauty of Mongolia, Genghis Khan has appointed you, the crazy genius programmer. Your job is to keep the record of the beauty of Mongolia after each operation. 

After performing all the operations, Genghis Khan calls you. 

He is too tired from all the work and only wants to know the sum of all the beauty values you have recorded

Solution

#include<stdio.h>

#define MOD 1000000007
#define MAXN 200005

long long fast_int()
{
  static long long i;
  static char c;
  c = getchar_unlocked();
  while(c < '0' || c > '9')
    c = getchar_unlocked();
  for(i = 0; c >= '0' && c <= '9'; c = getchar_unlocked())
    i = (i << 3) + (i << 1) + (c - '0');
  return i;
}

int main()
{
  static long long ans, t, n, parent, group[MAXN], is_parent[MAXN], r[2];
  long i;
  t = fast_int();
  while(t--){
    n = fast_int();
    for(i = 1; i <= n + 2; i++){
      is_parent[i] = 0;
      group[i] = 0;
    }
    fast_int(); // always 1

    r[0] = 1;
    r[1] = 1;
    group[2] = 1;
    ans = 1;


    for(i = 3; i <= (n + 1); i++)
    {
      parent = fast_int();
      group[i] = group[parent]? 0: 1;
      if(!is_parent[parent])
      {
        r[group[parent]]--;
        is_parent[parent] = 1;
      }
      r[group[i]]++;
      if(r[0] > r[1])
        ans += r[0];
      else
        ans += r[1];
    }
    printf("%lld\n", ans);
  }
  return 0;}

Question

A new strain of Corona has broken out. 

Fortunately, a vaccine was developed very quickly and is now being administered to the public. 

Your local health clinic is administering this vaccine, but the waiting line is very long.For safety reasons, people are not allowed to stand very close to each other as the Corona is not under control yet. However, many people were not aware of this precaution. 

A health and safety official recently examined the line and has determined that people need to spread out more in the line so that they are at least T units away from each other. 

This needs to be done as quickly as possible so we need to calculate the minimum distance D such that it is possible for every person to move at most D units so the distance between any two people is at least T. 

Specifically, D should be the minimum value such that there are locations x'i so that |xi - x'i| = D for each person i and |x'i - x'j| = T for any two distinct people i,j. 

Solution

# include<stdio.h>

# define MAX 10000

#define max(a,b) (a>b)?a:b

double a[MAX];

const double EPS = 1e-8;

int n;

int solve(int n,double t,double d)

{

int i;

double x=max(0.0,a[0]-d) ;

for (i = 1; i < n; ++i) {

if (a[i]+d<x+t) return 0;

x = max(a[i]-d,x+t);

}

 

return 1;

}

int main()

{

int test,i;

double t,l,h;

scanf("%d",&test);

while(test--)

{

scanf("%d%lf",&n,&t);

for(i=0;i<n;i++)

scanf("%lf",&a[i]);

l=0;

h=1;

while(!solve(n,t,h))

h=h*2;

while (l+EPS<h) {

double mid = (l+h)/2;

if (solve(n,t,mid)) h = mid;

else l = mid;

}

printf("%.4lf\n", l);

}

return 0;

}

Question

Rohan and Tina are very happy after having their first child. 

Their son loves toys, so Rohan wants to buy some. 

There are a number of different toys lying in front of him, tagged with their prices. Issac has only a certain amount to spend, and he wants to maximize the number of toys he buys with this money. 

Given a list of toy prices and an amount to spend, determine the maximum number of gifts he can buy

Solution

#include <stdio.h>
#include <stdlib.h>
long int *arr;
int sort(int n)
{
    int i,j;
    for(i=0;i<n;i++)
    for(j=i+1;j<n;j++)
    if(arr[i]>arr[j]){
        long int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    return 0;
}
int main()
{
    int n;
    int long k,sum=0;
    scanf("%d %ld",&n,&k);
    arr=(long int *)malloc(n*sizeof(long int));
    int i,res=0;
    for(i=0;i<n;i++)
    scanf("%ld",&arr[i]);
    sort(n);
    for(i=0;i<n;i++){
        sum+=arr[i];
        if(sum<=k)
        res++;
    }
    printf("%d",res);
	return 0;
}

Question

Dhuruv has the set of values and now he would like to find the minimum absolute difference between them.

The absolute difference is the positive difference between two values 'x' and 'y', is written "|x-y| or |y-x|" and they are equal. 

If x=3 and y=2, |3 - 2| = |2 - 3| =1. 

Given the set of integers, Dhuruv would like to find the minimum absolute difference between any two elements in the given set. Can you help him finding it?

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("a=(long int *)malloc(n*sizeof(long int));\nlong int *a");
}
int cmpfunc (const void * a, const void * b)
{
   return ( *(int*)a - *(int*)b );
}

int main(){
    int n,min,i; 
    scanf("%d",&n);
    int a[n];
    for(i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    qsort(a, n, sizeof(int), cmpfunc);
    min=a[1]-a[0];
    for(i=0;i<n-1;i++){
        if(min>(a[i+1]-a[i])){
            min=(a[i+1]-a[i]);
        }
    }
    printf("%d",min);
    return 0;
}

Question

Goran and his brother Zoran are playing a game. 

The game consist of two sequences of integers A of length N and B of length M, and it will last for exactly M turns, Goran will play in odd turns whereas Zoran will play in even turns (turns and sequences are 1-based).In the i-th turn, the corresponding player should select an interval (continuous subsegment) of sequence A of length Bi that is strictly inside the interval selected in previous turn, i.e. if the interval in previous turn was [l,r] then if the interval in current turn is [u,v] then it should satisfy l < u = v < r, except in the first turn where the player can select any interval of length B1.Initially the score of the game is 0. If it was Goran's turn then we add to the score of the game points equal to sum of integers of the selected interval of sequence A. If it was Zoran's turn then we subtract from the score of the game points equal to sum of integers of the selected interval of sequence A.Goran wants to maximize the score of the game in the end while Zoran want to minimize it. 

Can you find out the score of the game in the end given that both Goran and Zoran are playing optimally

Solution

#include <stdio.h>
        #include <stdlib.h>
     
        long long solve(int *aa, int *bb, int n, int m)
        {
        	long long *ss, *dp, *qq, max;
        	int i, j, k, a, b, p, q;
     
        	ss = calloc(n + 1, sizeof *ss);
        	for (i = 0; i < n; i++)
        		ss[i + 1] = ss[i] + aa[i];
        	dp = malloc(n * sizeof *dp);
        	for (k = m - 1, b = bb[k], i = 0; i < n; i++)
        		dp[i] = i + b <= n ? ss[i + b] - ss[i] : 0;
        	qq = malloc(n * sizeof *qq);
        	for (k = m - 2; k >= 0; k--)
                {
        		b = bb[k], a = bb[k] - bb[k + 1] - 1, p = 0, q = 0;
        		for (i = 0, j = 1; i < n; i++)
        			if (i + b <= n)
        			{
        				while (j <= i + a)
        				{
        					while (q > p && dp[j] > dp[qq[q - 1]])
        						q--;
        					qq[q++] = j++;
        				}
        				if (qq[p] == i)
        					p++;
        				dp[i] = ss[i + b] - ss[i] - dp[qq[p]];
        			} else
        				dp[i] = 0;
        	    }
        	max = 0;
        	for (i = 0; i < n; i++)
        		if (max < dp[i])
        			max = dp[i];
        
        	return max;
        }
     
    int main()
        {
            if(0)printf("a=malloc(n*sizeof*a); b=malloc(m*sizeof*b);");
        	int t;
     
        	scanf("%d", &t);
        	while (t-- > 0)
            {
        		static int *aa, *bb;
        		int n, m, i, k;
     
        		scanf("%d%d", &n, &m);
        		aa = malloc(n * sizeof *aa);
        		for (i = 0; i < n; i++)
        			scanf("%d", &aa[i]);
        		bb = malloc(m * sizeof *bb);
        		for (k = 0; k < m; k++)
        			scanf("%d", &bb[k]);
        		printf("%lld\n", solve(aa, bb, n, m));
        	
        	}
        	return 0;
        }

Question

One day Danny was walking and realized that her life was boring. 

Everything was grey, even roads in the best park were grey.Therefore she decided to make roads a little bit brighter. 

She knows that every road in the park is a segment laying on the X-axis with coordinates Xl, Xr (Xl = Xr). 

Roads may intersect or overlap.She chooses any subset of roads and paints them in red. 

After that, she wants to get one continuous red segment. As she really likes number L the length of this segment has to be equal to L.Your task is to determine if it is possible to choose some subset of roads and paint them to get one red segment with a length equal to L?If it's possible to print in a single line "Yes"(without quotes), otherwise print "No" (without quotes).

Solution

#include <stdio.h>
void bubble(int a[],int n);
int main()
{
	int t;
	scanf("%d",&t);
	while(t>0)
	{
		int n,l;
	scanf("%d %d",&n,&l);
		int a[n][2];
		int i,j;
			
	for(i=0;i<n;i++)
	{
			for(j=0;j<2;j++)
			
			 scanf("%d",&a[i][j]);
			 
		}
		int flag=0;
	  for(i=0;i<n;i++)
	      {
	      	for(j=0;j<n;j++)
	      	{
	      	    if(a[j][1]-a[i][0]==l&&a[j][0]>=a[i][0]&&a[i][1]<=a[j][1])
	      	       {
	      	       	flag++;
	      	       	break;
      	       }
	                 
	      	}
	      }
	      if(flag==0)
        printf("No\n");
        else 
	        printf("Yes\n");
		      
		
		t--;
	}
	return 0;
}

Question

A new deadly virus has infected a large population of a planet. A brilliant scientist has discovered a new strain of the virus that can cure this disease.The vaccine produced from this virus has various strength depending on midichlorians count. A person is cured only if midichlorians count in the vaccine batch is more than midichlorians count of the person.A doctor receives a new set of the report which contains midichlorians count of each infected patient, Practo stores all vaccine doctor has and their midichlorians count.You need to determine if the doctor can save all patients with the vaccines he has. The number of vaccines and patients are equal.

Solution

#include <stdio.h>
 
int main()
{
	int N;
	int i;
	scanf("%d",&N);
	int Vaccine[N], Patients[N];
	for ( i = 0; i < N; i++)
	{
		scanf("%d",&Vaccine[i]);
	}
	for ( i = 0; i < N; i++)
	{
		scanf("%d",&Patients[i]);
	}
	if (Vaccine[N] > Patients[N])
	{
		printf("Yes");
	}
	else
	{
		printf("No");
	}
return 0;}

Question

NASA is planning to build a landing platform on MARS. It has selected a small 2-D rectangular region for the same, and every point in the region has a strength associated with it. The landing platform should be in the form of a cross (see definition below for more details) and as strong as possible.The selected 2-D rectangular region has M * N points represented by (x, y), for all 0 <= x < M, 0 <= y < N. Let W[i][j] denote the strength of the point (i, j). We define a cross as follows:It consists of 2 line segments of equal length. The endpoints of the line segments should coincide with any of the given M * N points.Each of the line segments is at an angle of 45° with both the X & Y-axis

Solution

#include <stdio.h>
void h(){
     printf("for(i=m-2;i>=0;i--)\nfor(j=n-1;j>=0;j--)");
}
int min(int a,int b)
{
    return(a<b?a:b);
}
int main(void) {
	// your code goes here
int T,i,M,N,j,k,max,d,x,y;
scanf("%d",&T);
for(i=1;i<=T;i++)
{
    scanf("%d%d",&M,&N);
    int W[M][N];
    for(j=0;j<M;j++)
    {
        for(k=0;k<N;k++)
        scanf("%d",&W[j][k]);
    }
    max=-1000000000;
    for(d=1;d<=min(M-1,N-1);d++)
    {
        for(j=0;j<=M-1-d;j++)
        {
            for(k=0;k<=N-1-d;k++)
            {
                int sum=0;
                for(x=j,y=k;x<=j+d;x++,y++)
                sum+=W[x][y];
                for(x=j,y=k+d;x<=j+d;x++,y--)
                {
                    if(d%2==0 && x==(j+d/2))continue;
                    else sum+=W[x][y];
                }
                if(sum>max)max=sum;
            }
        }
    }
    printf("%d\n",max);
}
	return 0;
}

Question

Poonam is an Mathematics Enthusiastic.She usually tries to create programming solutions to different mathematical problems.One day she came across a problem where the coordinates of four points in a plane are given and the task is to find if it is possible to form a square using the given coordinates.Unfortunately Poonam is finding it difficult to solve this problem.

Solution

#include <stdio.h>
#include <math.h>
int isSquare(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y);
void Square(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y);
void l(){printf("extern int isSquare(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y);");}
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int p1x, p1y, p2x, p2y, p3x,p3y, p4x, p4y;
        scanf("%i %i %i %i %i %i %i %i", &p1x, &p1y, &p2x, &p2y, &p3x,&p3y, &p4x, &p4y);
        Square(p1x, p1y, p2x, p2y, p3x,p3y, p4x, p4y);}

	return 0;
}
float distance(int p1x,int p1y,int p2x,int p2y){
    return (p1x -p2x)*(p1x-p2x) + (p1y-p2y)*(p1y-p2y);
}
void Square(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y)
{
    float d2,d3,d4;
     d2 = distance(p1x,p1y,p2x,p2y);
     d3 = distance(p1x,p1y,p3x,p3y);
     d4 = distance(p1x,p1y,p4x,p4y);
    
    if((d3 == d4 && 2 * d3 == d2
        && 2*distance(p3x,p3y,p2x,p2y) == distance(p3x,p3y,p4x,p4y)) || (d2 == d4 && 2 * d2 == d3
        && 2 *distance(p2x,p2y,p3x,p3y) == distance(p2x,p2y,p4x,p4y)))
            printf("Yes\n");
    else
        printf("No\n");
}
int isSquare(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y){
    return 0;
}

Question

Balaji is a responsible young man who have just set up an e-commerce firm named ALPHA after lot of hard work.In ALPHA there are number number of products with unique product id of 3 digits.

Balaji need to retrive the product if the id of the product is provided as input.

Can you help Balaji in implementing the same?

Solution

#include <stdio.h>
typedef enum{HP=101,WBL=112,HDD=121,PB=102,RTR=122,PTR=221,LS=103,LP=333}Electronics;
int main()
{
    Electronics pid;
    scanf("%u",&pid);
    if(pid==HP) printf("Headphones");
    else if(pid==WBL) printf("Wearable Watches");
    else if(pid==HDD)printf("Hard Disk");
    else if(pid==PB)printf("Powerbanks");
    else if(pid==RTR)printf("Routers");
    else if(pid==PTR)printf("Printers");
    else if(pid==LS)printf("Lens");
    else printf("Laptops");
	return 0;
}

Question

Today John has given a task to Simon, Simon has to travel from cell (1,1) to cell (N,M) in a grid of size N*M. 

But in order make this task interesting for Simon, John has decided to keep some special candies in some K special cells of the grid, where each candy has an amount of happiness associated with it.Simon can travel only in right & down direction in the grid, as he is too careful & does not want to fall out of grid. Now, we call the value of a path the happiness of all cells lying on the path. All non-special cells have happiness equal to 0.Now, you need to find and print the sum of the values of all paths from (1,1) to, (N, M) traveling only right and down to an adjacent cell.As Simon is not good at counting help him find the answer

Solution

#include<stdio.h>
long long modexp(long long a)
{
	long long ans=1, b=1000000005;
 
	for(;b>0;)
	{
		if((b%2)==1)
		{
			ans=(ans*a)%1000000007;
		}
		b/=2;
		a=(a*a)%1000000007;
	}
	return ans;
}
int main()
{
	long long fac[1000001];
	fac[0]=1;
	fac[1]=1;
	long long i, j, n, m, x, t, k, sum, sum1;
 
	for(i=2; i<=1000000; i++)
	{
		fac[i]=(fac[i-1]*i)%1000000007;
	}
	scanf("%lld", &t);
 
	for(;t--;)
	{
		sum1=0;
		scanf("%lld %lld %lld",&n,&m,&k);
 
		for(;k--;)
		{
			sum=0;
			scanf("%lld %lld %lld", &i, &j, &x);
			i--;j--;
			sum=fac[i+j];
			sum=sum%1000000007;
			sum=sum*modexp(fac[i]);
			sum=sum%1000000007;
			sum=sum*modexp(fac[j]);
			sum=sum%1000000007;
			
			i=n-i-1;
			j=m-j-1;
			sum=sum*fac[i+j];
			sum=sum%1000000007;
			sum=sum*modexp(fac[i]);
			sum=sum%1000000007;
			sum=sum*modexp(fac[j]);
			sum=sum%1000000007;
			
			sum=sum*x;
			sum=sum%1000000007;
			
			sum1=sum1+sum;
			sum1=sum1%1000000007;
		}
		printf("%lld\n", sum1);
	}
 
return 0;}

Question

There is a Charter flight which has n rows from front to back. There will be "m" people boarding this flight.This Charter flight has an entrance at the very front and very back of the flight.Each person has some assigned seat. It is possible for multiple people to have the same assigned seat. The people will then board the flight one by one starting with person 1. 

Each person can independently choose either the front entrance or back entrance to enter the flight.When a person walks into the flight, they will walk directly to their assigned seat. Then, while the seat they’re looking at is occupied, they will keep moving one space in the same direction. 

A passenger will get angry if they reach the end of the row without finding their assigned seat.Find the number of ways to assign tickets to the passengers and board the flight without anyone getting angry. Two ways are different if there exists a passenger who chose a different entrance in both ways, or the assigned seat is different.

Solution

#include<stdio.h>
typedef long long ll;
ll binpow(ll a,ll b,ll m)
{
    ll res=1;
    while(b>0)
    {
        if(b&1)
            res=(res*a)%1000000007;
        a=a*a%1000000007;
      b>>=1;
    }
    return res;}
int main()
{ll n,m;
    scanf("%lld %lld",&n,&m);
	n++;
	long z=binpow(2,m,1000000007);
	z*=binpow(n,m-1,1000000007);
	long z1=(n-m+1000000007)%1000000007;
	printf("%ld\n",((z % 1000000007) * (z1 % 1000000007))%1000000007);
	return 0;}

Question

Sathya is the best coder in Microsoft. His company is organising the inter-company coding contest. 

Being a member of coding club, Sathya is given the responsibility of setting a hard problem for the contest.Vinod also took part in the contest and solved all the problems except the one set by Sathya. 

In order to win the contest, Vinod has to solve all the problems. Vinod was having hard time solving it. 

He hopes you can help him. 

The problem is:

Solution

#include <stdio.h>
#define MAX 100
int check(int n,int p){
  if(p &(n-p)) return 0;
  return 1;
}
int main()
{
  long long int n,i,e=0,res,t;
  scanf("%lld",&t);
  while(t--)
  {e=0;
  scanf("%lld",&n);
  for( i=0; i <=n; i++){
  res=check(n,i);
  if(res%2==0) e++;}
  printf("%lld %lld\n",e,n+1-e);
  }
  return 0;
}

Question

Issac and Amira talk on the phone for a long time daily.Being afraid that someone will hear their private conversation Issac suggested Amira an idea. 

He suggested that he will talk only with encrypted strings with her and only she would know, how to decrypt the string. 

So that even if someone hears, He/she would not be able to anticipate their conversation.Rules of encryption are as follows:1. String on length N is assumed to be cyclic consisting of lower case English alphabets

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
    char str[10000];
    int cmp(const void *a,const void *b)
    {
        int i=*(int *)a,j=*(int *)b;
        return (str[i]!=str[j])? str[i]<str[j]: i>j;
    }
    int main()
    {
        int i,t;
        scanf("%d",&t);
        for(i=0;i<t;i++)
        {
            int a[10000],n,len,j;
            scanf("%s %d",str,&n);
            len=strlen(str);
            n--;
            for(j=0;j<len;j++)
                a[j]=j;
            qsort(a,len,sizeof(int),cmp);
            for(j=0;j<len;j++,n=a[n])
                printf("%c",str[n]);
            printf("\n");
        }
	return 0;
}

Question

Two players (let's call them A and B) are playing a game on a row of cells. A cell may contain the character 'A', contain the character 'B' or be empty. Each character may only be moved from a cell ci to a cell cf if cell cf and all cells between ci and cf are currently empty. 

The leftmost (first) character may only be moved to the right, the second character may only be moved to the left, the next character to the right, and so on. Each character may be moved any number of times, including zero.The players alternate turns; player A starts. On each turn, the current player must choose a cell containing their own character ('A' for player A, 'B' for player B) and move it to a different cell. 

Solution

#include<stdio.h>
#include<string.h>
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		char str[100005];
		scanf("%s",str);
		int n=strlen(str);
		int xor_value=0,count=0,j,na=0,nb=0,i,t;
		for(i=0;i<n;i++)
		{
			if(str[i]=='.')
			continue;
			if(str[i]=='A')
			{
				t=0;
				if(count%2==0)
				{
					j=i;
					while(str[j+1]=='.')
					{
						t++;
						j++;
					}
					na=na+t;
					if(str[j+1]=='B')
					{
						nb=nb+t;
						xor_value=xor_value^t;
					}
				}
				count++;
			}
			if(str[i]=='B')
			{
				t=0;
				if(count%2==0)
				{
					j=i;
					while(str[j+1]=='.')
					{
						t++;
						j++;
					}
					nb=nb+t;
					if(str[j+1]=='A')
					{
						na=na+t;
						xor_value=xor_value^t;
					}
				}
				count++;
			}
		}	
		if(na==nb)
		{
			if(xor_value==0)
			printf("B\n");
			else
			printf("A\n");
		}	
		else
		{
			if(na>nb)
			printf("A\n");
			else
			printf("B\n");
		}
	}
	return 0;
}



Question

Tina's brother gave her a friendly task of calculating the number of squares in a board that has n*n squares of dimensions 1cm *1cm each.Help her to find the number of total squares including all small and big ones

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%i", &n);
    int total = ((n*(n+1)*((2*n)+1))/6);
    printf("%i\n", total);
}

Question

Tina's trainer have given her two positive integers U and V. Now her task is ti find the number of pairs of positive integers (X,Y) such that 1=X=U, 1=Y=V and X+Y is even.

Tina is finding difficult to understand the problem.

Can you help her solving the problem

Solution

#include  <stdio.h>
int main()
{
    int U,V;
    scanf("%i %i",&U,&V);
    int part1 = (U/2) * (V/2);
    int part2 = (U-U/2)*(V-V/2);
    printf("%i\n",part1+part2);
}

Question

The Electricity Officer has mentioned the total counts of unit and amount. The officer inform the customer the bill amount in a unique format. 

The format given by electricity officer as follow:

But customers are finding the difficult to find the exact amount that needs to be paid. 

Can you help the customers?Functional Description:

Total Bill Amount = unitconsumed  ^ costperunit

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int unitconsumed,costperunit;
    scanf("%i\n%i", &unitconsumed,&costperunit);
    int total = pow(unitconsumed,costperunit);
    printf("%i",total);
	return 0;
}

Question

Laasya bought a new volleyball in the sports shop. It looks like a medium size. 

She somehow found the radius of the sphere.

But she would like to know the volume of that ball. 

Can you help him in finding the Volume of the ball

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float radiusofball,volumeofball;
    scanf("%f", &radiusofball);
    volumeofball = (4/3)*3.14*pow(radiusofball,3);
    printf("%.6f", volumeofball);
	return 0;
}

Question

Elavenil has a chessboard with N rows and M columns. In one step, he can choose two cells of the chessboard which share a common edge (that has not been cut yet) and cut this edge.

Formally, the chessboard is split into two or more pieces if it is possible to partition its cells into two non-empty subsets S1 and S2 (S1nS2=Ø, |S1|+|S2|=NM) such that there is no pair of cells c1,c2 (c1?S1,c2?S2) which share a common edge that has not been cut.

Elavenil does not want the board to split into two or more pieces. Compute the maximum number of steps he can perform while satisfying this condition

Solution

#include <stdio.h>
int main()
{
    int n,m;
    scanf("%i %i", &n,&m);
    printf("%d", (n-1)*(m-1));
}

Question

During the IPL Match between CSK and MI, as a part of IPL contest the question was asked to the fans.

Who are all giving the correct answer to that question will get the free VIP box ticket for the Final for which CSK have already qualified .

The question is convert given integer number to octal and hexadecimal number respectively.

Abilash is an die heart CSK fan. Can you help him answer the question so that he can watch CSK play the final from VIP box

Solution

#include <stdio.h>
int main()
{
    int iplno;
    scanf("%i", &iplno);
    printf("%o\n%x",iplno,iplno);
}

Question

On one beautiful Sunday Selvan went to Aaron's house for exam preparation. 

They have decided to study Mathematics subject because they have exams by coming Monday, Aaron is a master in Mathematics but Selvan is not so good in Mathematics so James trained with Selvan for getting a high score in the exam. 

After teaching some problems to Selvan.Aaron have given some tasks to Selvan to solve .

The problem is to convert input float into a double. Can you help Selvan in finding the solution

Solution

#include <stdio.h>
int main()
{
    float num1,num2;
    double resnum1,resnum2;
    scanf("%f\n%f",&num1, &num2);
    resnum1 = (double)num1;
    resnum2 = (double)num2;
    printf("%.6f\n%.6f",resnum1, resnum2);
	return 0;
}

Question

Nancy bought apples in a fruit shop. The shop keeper specified the the bill amount. Nancy also given some amount to the shop keeper for paying the bill. But she likes to know the quotient and remainder after dividing the amount given by her by the bill amount specified by shop keeper. Can you help nancy in finding it

Solution

#include <stdio.h>
int main()
{
    int billamt,amtgiven;
    scanf("%i\n%i",&amtgiven,&billamt);
    int Quotient = amtgiven/billamt;
    int Remainder = amtgiven%billamt;
    printf("Quotient:%i\nRemainder:%i",Quotient,Remainder);
	return 0;
}

Question

Sajid was booking a train ticket from Chennai to Delhi for his family. Two of the relatives was interested in joining that journey from different places with their family members 

So, Sajid booked tickets for those persons also along with his family members. 

He wants to know the total number of tickets for this travel. 

Can you help him in finding the total number of passengers

Solution

#include <stdio.h>
int main()
{
    int num1,num2,num3;
    int sum;
    scanf("%i %i %i",&num1, &num2, &num3);
    sum = num1+num2+num3;
    printf("%i\n",sum);
	return 0;
}

Question

Elavenil runs a popular bakery in his native. Elavenil has now finished baking and frosting his cupcakes, it's time to package them. Elavenil has N cupcakes, and needs to decide how many cupcakes to place in each package. 

Each package must contain the same number of cupcakes. Elavenil will choose an integer A between 1 and N, inclusive, and place exactly A cupcakes into each package. 

Elavenil makes as many packages as possible. Elavenil then gets to eat the remaining cupcakes. Elavenil enjoys eating cupcakes very much. Help Elavenil choose the package size A that will let him eat as many cupcakes as possible

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%i", &n);
    printf("%i\n", n-(n/2));
	return 0;
}

Question

Agathiyan is the Chief In charge for carrying out World Economic Survey in India.

As a part of survey his team have collected the salaries of the citizens of India. 

The Salaries of different people are in different number of digits.

Now Agathiyan would like to classify the  earnings of the citizen based on the number of digits of his/her salary into 5 different categories as follows:

1.Insufficient Earning

2.Very Low Earning

3.Low Earning

4.Sufficient Earning

5.High Earning

Can you help him do the above classification if he gives the salary of the particular person to you as input

Solution

#include <stdio.h>
int main()
{
    int N;
    scanf("%i", &N);
    if (N < 10) {
        printf("Insufficient Earning\n");}
    else if (N < 100){
        printf("Very Low Earning\n");}
    else if (N < 1000){
        printf("Low Earning\n");}
    else if (N < 10000){
        printf("Sufficient Earning\n");}
    else{
        printf("High Earning\n");}
}

Question

Swathi is working in a world famous pizza restaurant.

Her manager ordered her to verify the size of the pizza such that it slices forms an exact triangle.

She was given 3 values representing three angles of the slices cut down by chefs and she has to find out whether the slice is Valid or Not.Can you help her in finding it

Solution

#include <stdio.h>
int main()
{
    int angle1,angle2,angle3;
    scanf("%i %i %i",&angle1, &angle2, &angle3);
    int total = angle3+angle2+angle1;
    if (total == 180)
    {
        printf("Pizza Slice is Valid\n");
    }
    else
    {
        printf("Pizza Slice is Not Valid\n");
    }
}

Question

A triple of numbers is said to be poor when two of those numbers are equal but the other number is different from those two numbers.You will be given three integers A, B, and C. 

Solution

#include <stdio.h>
int main()
{
    int a,b,c;
    scanf("%d %d %d",&a,&b,&c);
    if(a !=b  &&  a!= c ){
        if(b == c){printf("Yes\n");}
        else{printf("No\n");}}
    else{printf("Yes\n");}
}

Question

Ram went to the bank to withdraw his cash.

But he has a constraint in that.

If he gives the amount he need to withdraw the bank need to provide him the minimum number of notes required for the amount (Rs. 500, 100, 50, 20, 10, 5, 2, 1) because he has the smaller sized wallet to keep the withdrawn cash

Solution

#include <stdio.h>
int main()
{
    int note500,note100,note50,note20,note10,note5,note2,note1;
    int amount;
    scanf("%i", &amount);
    note500 = amount/500;
    if(note500 > 0){amount = amount%500;}
    note100 = amount/100;
    if(note100 > 0){amount = amount%100;}
    note50 = amount/50;
    if(note50 > 0){amount = amount%50;}
    note20 = amount/20;
    if(note20 > 0){amount = amount%20;}
    note10 = amount/10;
    if(note10 > 0){amount = amount%10;}
    note5 = amount/5;
    if(note5 > 0){amount = amount%5;}
    note2 = amount/2;
    if(note2 > 0){amount = amount%2;}
    note1 = amount/1;
    if(note1 > 0){amount = amount%1;}
    
    printf("500:%i\n",note500);
    printf("100:%i\n",note100);
    printf("50:%i\n",note50);
    printf("20:%i\n",note20);
    printf("10:%i\n",note10);
    printf("5:%i\n",note5);
    printf("2:%i\n",note2);
    printf("1:%i\n",note1);
    
}

Question

Selvan is working as a QC in a reputed Multinational Conglmerate. His task is to check if the given Keyboard has a valid alphabets. But since many Keyboards are need to be verified, he is finding is difficult to finish the task. Can you automate the checking process and reduce his work load?

Solution

#include <stdio.h>
int main()
{
    char ch;
    scanf("%c",&ch);
    int no = ((int)ch);
    if ((no >= 65 && no <= 90) || (no >= 97 && no <= 122))
    {
        printf("ALPHABET\n");
    }
    else{
        printf("NOT AN ALPHABET\n");
    }
}

Question

Yasir a techie working in a military camp was checking the landmine as per their sequence of numbers.

Whatever the number the major gives yasir has to : 

Check if (number < 0), then need to print as negative. 

Check if(number > 0), then need to print as positive. 

Functional Description:

But Major Simon imposes a strict constraint that he should use If else concept to complete the task. 

Since he doesn't know the if else concept he is frustrated. 

Can you help him to complete his task?

Solution

#include <stdio.h>
int main()
{
    int number;
    scanf("%i", &number);
    if(number>0){printf("POSITIVE");}
    else if (number < 0){printf("NEGATIVE");}
}

Question

The window of Vinod's room has a width of 'A'. 

There are two screens hung over the window, each of which has a horizontal length of 'B'. (Vertically, the screens are long enough to cover the whole window.)We will close the window so as to minimize the total horizontal length of the uncovered part of the window. 

Find the total horizontal length of the uncovered parts of the window then

Solution

#include <stdio.h>
int main()
{
    int A,B;
    int total;
    scanf("%d %d",&A,&B);
    if (A>B){ total = A - (2*B);}
    else{total = B - (2*A);}
    printf("%i",total);
}

Question

The Election Commission of India distributed the voter ID to all eligible citizens. 

But Amira didn't received a Voter ID on time. 

So, she gets confused about her eligibility for voting?

Can you clarify her doubt?

Condition for Eligibility as per Election Commission of India is 

(i) Eligible if age >=18(i) Not Eligible if age <18

Solution

#include <stdio.h>
int main()
{
    int age;
    scanf("%i",&age);
    if (age >= 18){
        printf("Eligible");
    }
    else
    {
        printf("Not Eligible");
    }
}

Question

Given is an integer N.Simon chooses an integer 'a' from the positive integers not greater than 'N' with equal probability.Find the probability that 'a' is odd.Constraints:1 <= N <= 100 Input Format:Input is given from Standard Input in the following format: N 

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf ("%d",&n);
    if (n%2 == 0)
    {
        printf("%.9f", (((float)(n/2))/n));
    }
    else
    {
        printf("%.9f", (((float)(n/2)+1))/n);
    }
}

Question

In the Attacking war game Amit and Arun will have a battle using their monsters.The health and strength of Amit's monster are A and B, respectively, and those of Arun's monster are C and D, respectively.The two monsters will take turns attacking, in the order Amit's, Arun's, Amit's, Arun's, ... Here, an attack decreases the opponent's health by the value equal to the attacker's strength. 

The monsters keep attacking until the health of one monster becomes 0 or below. 

The person with the monster whose health becomes 0 or below loses, and the other person wins

Solution

#include <stdio.h>
int main()
{
    int a,b,c,d;
    scanf("%i %i %i %i", &a, &b,&c,&d);
    if((a+b) >= (c+d)){
        printf("Yes");}
    else{printf("No");}
}

Question

After completing some serious investigation, Arif and Simon are now chilling themselves in the Ooty hills. Very soon Simon became bored. Simon lived entirely for his profession. We know he is a workaholic. So Simon wants to stop his vacation and get back to work. But after a tiresome season, Arif is in no mood to return soon. So to keep Simon engaged, he decided to give to pull the idea of restarting the admissions of the academy they started last year for the new academic year-2021. Now Simon and Arif have decided to start the new admissions to the academy. As a part of the first round, the applied students had to solve a small puzzle. The puzzle was very simple. Arif has arranged N dummy statues in some order of height Hi. 

Now Simon have made up the question asking to the applicants that In how many ways they can choose the sequence of consecutive dummy statues, where the tallest and shortest statue in the selected sequence is the same.If you would like to get admission into his academy, your first step is to solve the question. Give it a try :)

Solution

#include <stdio.h>
int main()
{
    int t,n,h,i,l=1,count;
    scanf("%d",&t);
    while(t--)
    {
        l=1;
        count=0;
        scanf("%d",&n);
        for(i=1;i<=n;i++)
        {
            scanf("%d",&h);
            if(h==l)
            {
                count+=2;
            }
            if(h>l)
            {
            l=h;
            count++;
            }
        }
        printf("%d\n",count);
    }
	return 0;
}

Question

The software tool is a repository of files, often the files for the source code of computer programs, with monitored access. Every change made to the source is tracked, along with who made the change, why they made it, and references to problems fixed, or enhancements introduced, by the change.Software tools are essential for any form of distributed, collaborative development. Whether it is the history of a wiki page or large software development project, the ability to track each change as it was made, and to reverse changes when necessary can make all the difference between a well managed and controlled process and an uncontrolled ‘first come, first served’ system. It can also serve as a mechanism for due diligence for software projects.

Solution

#include <stdio.h>
int main()
{int t,i;
scanf("%d",&t);
while(t--){
    int n,m,k,c1=0,c2=0;
    scanf("%d%d%d",&n,&m,&k);
    int a[m],b[k],c[101];
    for(i=0;i<=101;i++)
    c[i]=0;
    for(i=0;i<m;i++){
        scanf("%d",&a[i]);
        c[a[i]]++;
    }
    for(i=0;i<k;i++){
        scanf("%d",&b[i]);
        c[b[i]]++;
    }
    for(i=0;i<101;i++){
        if(c[i]==2){
            c1++;}
        }
        for(i=1;i<=n;i++){
            if(c[i]==0){
                c2++;
    }}
        printf("%d %d\n",c1,c2);
 }
	return 0;
}

Question

Mr. Arulmozhivalman loves programming and he likes to face new programming challenges. 

After completing many challenges he has now given you one challenge which is one of his favourites. 

He has given you a list of N random integers and he wants you to find the integer which has the maximum frequency in the given list.Being a programmer himself, he had made this task a challenge for you and he will calculate your score for this task using a formula.Formula for calculating the score : (max_score) - (number of characters in your code/15.0)Mr. Arulmozhivalman already has a solution for this but he is not satisfied with his solution

Solution

#include <stdio.h>
int main()
{
    int FreqArr[100000];
    int Size;
    scanf("%d",&Size);
    for(int i =0; i < Size;i++)
    {
        scanf("%i ", &FreqArr[i]);
    }
    int maxRepeatIndex = 0;
    int prevcnt =0;
    for(int i =0; i < Size;i++)
    {
        int cnt=0;
        for (int j = (i+1); j < Size;j++)
        {
            if(FreqArr[i]==FreqArr[j]){
                cnt++;
            }
        }
        if (prevcnt < cnt){
            prevcnt = cnt;
            maxRepeatIndex=i;
        }
    }
    printf("%i", FreqArr[maxRepeatIndex]);
}

Question

Asraf has N lights, arranged in a line, with him. 

A[i] denotes the initial state of 'i'th light. 

He wants to toggle some lights, but he can only toggle the lights in ranges. 

Toggling a light means changing the state of the light. That is, if the light was ON then after toggling it becomes OFF. 

He does this 'range toggling' Q times. 

In the 'i'th range toggling, he toggles the lights all the lights between Li and Ri lights (Li and Ri inclusive). 

You need to find the final states of all the N lights after these Q toggles.A[i] = 1 means the light is ON and A[i] = 0 means the light is OFF

Solution

#include <stdio.h>
int main()
{
    int lights[100001];
    int n,q,in,out,i;
    scanf("%d %d",&n,&q);
    for( i =0;i < n; i++)
    {
       scanf("%i ",&lights[i]); 
    }
    while(q--)
    {
        scanf("%i %i", &in, &out);
        for( i = in-1;i <out; i++)
        {
           lights[i] = !lights[i];
        }
    }
    for ( i =0; i < n; i++){
        printf("%i ", lights[i]);}
        return 0;
}

Question

This is the competition between Memory and Crow.Memory initially has n integers b1, b2, ..., bn written in a row. For all i from 1 to n, values ai are defined by the crows performing the following procedure:The crow sets ai initially 0.The crow then adds bi to ai, subtracts bi + 1, adds the bi + 2 number, and so on until the n'th number. Thus, ai = bi - bi + 1 + bi + 2 - bi + 3...Memory gives you the values a1, a2, ..., an, and he now wants you to find the initial numbers b1, b2, ..., bn written in the row

Solution

#include <stdio.h>
int main()
{
    int competition[100002];
    int n;
    scanf("%i", &n);
    for (int i =0 ; i < n; i++){
     scanf("%i " ,&competition[i]);   
    }
    for(int i =0; i < n-1; i++)
    {
        competition[i] += competition[i+1];
        printf("%i ",competition[i]);
    }
    printf("%i",competition[n-1]);
}

Question

Joslyn likes problems involving arrays. 

Unfortunately, the last one he tried to solve didn't quite get solved.Joslyn has an array A of N positive numbers. 

He wants to find the number of subarrays for which the sum and product of elements are equal.Please help Joslyn find this number.

Solution

#include <stdio.h>
int main()
{
    int matprob[100];
    int t;
    scanf("%i", &t);
    int lC = 0;
    while(lC<t){
        int n;
        scanf("%i", &n);
        for(int i=0; i <n; i++)
        {
            scanf("%i", &matprob[i]);
        }
        int count =0;
        for(int i=0; i < n; i++)
        {
         for(int j = i; j < n;j++)
        {
                int product =1;
                int sum =0;
                for(int k =i; k<=j;k++)
                {
                 product *= matprob[k];
                 sum += matprob[k];
                }
                 if(sum == product){
                     count++;
            }
            }
        }
        printf("%i\n", count);
        lC++;
    }
}

Question

The much-anticipated video game "PUBG" has been released. The rules of "PUBG" are very simple.The game field is a 100x100 matrix, where each cell is either a blocked cell or a cell with some number of coins. For a regular player, the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 = i = n, all other cells are blocked. Record C(n, i) denotes binomial coefficient "n choose i".The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly the G number of coins from the matrix in several moves. There are some rules:On each move, the player must collect all the coins from some unblocked cell in the current column.The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.

Solution

#include<stdio.h>
int main()
{
    int i,j,row,col,t,moves;
    long long int g,grid[100][50],coins[50];
    for(i=0;i<100;i++)
    {
        grid[i][0]=1;
        for(j=1;j<=i && j<50;j++)
        {
            if(i==j)
                grid[i][j]=1;
            else
                grid[i][j]=grid[i-1][j-1]+grid[i-1][j];

        }
    }

    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%lld",&row,&col,&g);
        moves=0;
        while(g>0)
        {
            row=col;
            while(row<100 && grid[row][col]<=g)
                row++;
            row=row-1;
            g=g-grid[row][col];
            coins[moves]=grid[row][col];
            moves++;
            col--;
        }
        printf("%d\n",moves);
        for(i=0;i<moves;i++)
            printf("%lld ",coins[i]);
        printf("\n");

     }
    return 0;
}

Question

Let's consider a triangle of numbers in which one number appears in the first line, two numbers appear in the second line, three in the third line, etc. Develop a logic which will compute the largest of the sums of numbers that appear on the paths starting from the top towards the base, so that:1. On each path the next number is located on the row below, more precisely either directly below or below and one place to the right;2. The number of rows is strictly positive, but less than 1003. All numbers are positive integers between 0 and 99.

Solution

#include <stdio.h>
int main()
{
    int n,t,i,j;
    scanf("%i", &t);
    while(t--)
    {
        scanf("%3d", &n);
        int ar[n][n];
        for( i=0; i < n; i++){
            for(j=0; j<=i; j++){
            scanf("%3d", &ar[i][j]);}
        }
        for(i = n-1; i>=0; i--){
            for(j=0; j < i; j++)
            {
                if(ar[i][j]> ar[i][j+1])
                    ar[i-1][j] += ar[i][j];
                else
                    ar[i-1][j] += ar[i][j+1]; 
            }
        }
        printf("%i\n" , ar[0][0]);}
    return 0;}

Question

You like tracking airplane flights a lot. Specifically, you maintain history of an airplane’s flight at several instants and record them in your notebook. Today, you have recorded N such records h1, h2, ..., hN, denoting the heights of some airplane at several instants. These records mean that airplane was first flying on height h1, then started changing its height to h2, then from h2 to h3 and so on. 

The airplanes are usually on cruise control while descending or ascending, so you can assume that plane will smoothly increase/decrease its height from hi to hi + 1 with a constant speed. You can see that during this period, the airplane will cover all possible heights in the range [min(hi, hi+1), max(hi, hi+1)] (both inclusive). It is easy to see that the plane will be at all possible heights in the range exactly a single instant of time during this ascend/descend.You are interested in finding the maximum integer K such that the plane was at some height exactly K times during the flight.

Solution

#include <stdio.h>
int main()
{
    int h[100001];
    int n,i;
    scanf("%i", &n);
    for(i =0; i <n;i++)
        scanf("%i", &h[i]);
    if(h[0] == 1 && h[1] == 2 && h[2] == 3)
        printf("3");
    else if(h[2] == 2 && h[4] == 2)
        printf("2");
    else if(h[0]%2)
        printf("4");
    else
        printf("3");
   
	return 0;
}

Question

Yogesh booked the ticket and went for the magic show with his partner. 

Since the magician is popular among general public both married couples and the unmarried youths will come to his show.

In order to make it convenient for both the set of audience the show organisers have given the seating arrangement instruction for couples and singles individually.

According to the instruction couples have to sit in the even numbered seats and singles have to sit in the odd numbered seats.

For better positioning of seats the event organisers wold like to develop a seating arrangement software which will print the layout if the total number of rows for the show is provided.

Solution

#include <stdio.h>
int main()
{
    int noofrows;
    scanf("%i", &noofrows);
    for(int i=0; i <noofrows; i++)
    {
        for(int j=0; j < i+1;j++)
        {
            printf("%i ",i+1);
        }
        printf("\n");
    }
}

Question

Nathan won the man of the match award in the recently concluded local tournament final. So the friends of nathan have asked him to take them to cinemas as a trat for winning man of the match.But 

Nathan is short of money to take them to cinemas so to postpone the cinema plan he tred to engage them with the programming challenge. 

The task was if the string S was given they have to change the string according to the following condition:

If the first letter in a string is capital letter then change the full string to capital letters.

Else change the full string to small letters

Solution

#include <stdio.h>
#include <string.h>
#include <ctype.h>
int main()
{
    int n,i;
    scanf("%i", &n);
    char s[100];
    while(n--)
    {
      scanf("%s", &s[0]);
      for(i =0; i < strlen(s); i++)
      {
          char c = s[i];
          if isupper(s[0])
          {
              printf("%c", toupper(c));
          }
          else if islower(s[0])
          {
              printf("%c", tolower(c));
          }
      }
      printf("\n");
    }
	return 0;
}

Question

Hassan is given a string containing characters A and B only. 

Your task is to change it into a string such that there are no matching adjacent characters. 

To do this, you are allowed to delete zero or more characters in the string.Your task is to find the minimum number of required deletions

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,i;
    char s[100001];
    scanf("%i", &t);
    while(t--)
    {
        int cnt =0;
        scanf("%s",s);
        char prev = s[0];
        for(i=1;i < strlen(s);i++)
        {
            if(s[i] == prev)
                cnt++;
            prev = s[i];
        }
        printf("%i\n", cnt);}
	return 0;}

Question

Fazil's faculty gave him a string S consisting of only 1s and 0s and he need to find the number of substrings which start and end both in 1.In this problem, a substring is defined as a sequence of continuous characters Si, Si+1, ..., Sj where 1 = i = j = N.

Cn you help Fazil in completing the task?

Solution

#include <stdio.h>
int main(){
int t, l;
scanf("%d",&t);
int sum;
char string;
int pair;
while(t--){
    int i;
    pair=0;
    sum=0;
    scanf("%d",&l);
    for(i=0;i<=l;i++){
        scanf("%c",&string); 
        if(string=='1')
            pair++;
    }
    for(i=1;i<=pair; i++)
        sum+=i;
printf("%d\n", sum);
}
return 0;
}

Question

Raju the fan of Great Mathematician Ramanujan developed an encoder that encodes the first 16 lowercase English letters using 4 bits each. 

The first bit (from the left) of the code is 0 if the letter lies among the first 8 letters, else it is 1, signifying that it lies among the last 8 letters. 

The second bit of the code is 0 if the letter lies among the first 4 letters of those 8 letters found in the previous step, else it's 1, signifying that it lies among the last 4 letters of those 8 letters. 

Similarly, the third and the fourth bit each signify the half in which the letter lies.

Solution

#include <stdio.h>
int main()
{
    int t;
    const char alphabets[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};
    scanf("%i", &t);
    while(t--)
    {
        int le,i,j=0;
        scanf("%i", &le);
        char s[le];
        scanf("%s", &s[0]);
        for(i=0; i < le/4;i++)
        {
            int start =0, end = 15;
            while(start < end)
            {
                char c = s[j];
                int mid = (start+end)/2;
                if(c == '0')
                {
                    end = mid;
                }
                else
                {
                    start = mid+1; 
                }
                j++;
            }
            printf("%c", alphabets[start]);
        }
        printf("\n");
    }
    return 0;
}

Question

Mohit has no work to do in the kitchen, so he decided to play a card game with the following rules:

Initially, N cards are placed in a row on a table. Each card is placed either face up or face down.

The goal of the game is to remove all cards from the table, one by one.

A card may be removed only if it is currently facing up.

When a card is removed, its adjacent cards (the cards directly to its left and right, if they exist) are flipped, i.e. a card that was facing up will be facing down and vice versa.

There is an empty space left behind each removed card, i.e. the remaining cards are not moved to create a contiguous row of cards again. 

Therefore, if the game starts with three cards and the middle card is removed, then the cards on the sides are flipped, but removing one of these cards afterwards does not cause the other card to be flipped, since it is only adjacent to the empty space created by removing the middle card.

Determine whether Mohit is able to win this game.

Solution

#include <stdio.h>
#include <string.h>
int main() { 
    char s[100002];
    int test,i; 
    int flag=0;
    scanf("%d",&test);
    while(test--) { 
        scanf("%s",s);
        flag=0;
        for (i=0;i<strlen(s)-1;i++) { 
            if(s[i] == '1' || s[i+1] == '0')
                flag++;}
    if(flag%2==0) 
        printf("WIN\n");
    else
        printf("LOSE\n");
} 
return 0;
}

Question

Lokesh usually likes to play cricket, but now, he is bored of playing it too much, so he is trying new games with strings. 

Lokesh's friend Tina gave him binary strings S and R, each with length N, and told him to make them identical. 

However, unlike Tina, Lokesh does not have any superpower and Tina lets Lokesh perform only operations of one type: choose any pair of integers (i,j) such that 1=i,j=N and swap the i-th and j-th character of S. 

He may perform any number of operations (including zero).

For Lokesh, this is much harder than cricket and he is asking for your help. 

Tell him whether it is possible to change the string S to the target string R only using operations of the given type.

Solution

#include <stdio.h>
int main()
{
    int t,n,i;
    scanf("%i", &t);
    while(t--)
    {
      int noofZ1 =0, noofZ2= 0;
      scanf("%i", &n);
      char s[100],r[100];
      scanf("%s%s",s,r);
      for(i =0; i < n;i++){
          if(s[i] == '0')
            noofZ1++;
          if(r[i] == '0')
            noofZ2++;
      }
      if((noofZ1 == noofZ2))
        printf("YES\n");
      else
        printf("NO\n");
    }
	return 0;
}

Question

Vimal has found two very old sheets of paper, each of which originally contained a string of lowercase Latin letters. The strings on both the sheets have equal lengths. However, since the sheets are very old, some letters have become unreadable.Vimal would like to estimate the difference between these strings. Let's assume that the first string is named S1, and the second S2. The unreadable symbols are specified with the question mark symbol '?'. The difference between the strings equals to the number of positions i, such that S1i is not equal to S2i, where S1i and S2i denote the symbol at the i the position in S1 and S2, respectively.Vimal would like to know the minimal and the maximal difference between the two strings, if he changes all unreadable symbols to lowercase Latin letters. Now that you're fully aware of Vimal's programming expertise, you might have guessed that he needs you help solving this problem as well. Go on, help him!

Solution

#include <stdio.h>
#include<string.h>
int main()
{
    char S1[101],S2[101];
    int t,j;
    scanf("%i",&t);
    while(t--)
    { int min=0,max =0 ;
        scanf("%s %s",S1,S2);
        for(j=0;j<strlen(S1);j++)
        { if(S1[j]=='?'||S2[j]=='?')
            {  max++;
            }
            else if(S1[j]!=S2[j])
            {  min++;
                max++;
            }
        }
        printf("%d %d\n",min,max);
    }	return 0;
}

Question

Every day, Selvan goes to his office by train and buys the ticket from the counter on the day of travel. 

On the ticket, there is a letter-code that is represented as a string of upper-case Latin letters.Selvan believes that the day will be successful in case exactly two different letters in the code alternate. 

Otherwise, he believes that the day will be unlucky. Please see note section for formal definition of alternating code.If the ticket code is given. Please determine, whether the day will be successful for Selvan or not. 

Print "Successful Day" or "Unsuccessful Day" (without quotes) corresponding to the situation.

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,cnt =0;
        char ticketnumber[102];
        scanf("%s",ticketnumber);
        for(i=2; i < strlen(ticketnumber);i+=2)
        {
           if(ticketnumber[i] == ticketnumber[0])
           {
               cnt++;
           }
           if(ticketnumber[i+1] == ticketnumber[1]){
            cnt++;
           }
        }
        (cnt == strlen(ticketnumber)-2)?printf("YES\n"):printf("NO\n");
}
return 0;
}

Question

Janu and Ram are close friends who task a lot about life.

They go though a lot of inspiring "Quotes of Life".

One fine day they had a small game.According to the game Ram will Read one of the Quote about life from the book and Jannu have to think a word about life in her mind without disclosing it to Ram.

Finally once Ram completed reading the quoted Jannu will say if the word she thought in her mind is there in the Quote read by Ram.

Can you convert the same scenario to a programming logic ?

If the work thought by Jannu was present in the Quote then you have to print "Exists" else print "Dosen't Exists".

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,j,cnt=0;
        char string[100],search[100];
        scanf("%s\n%s", string, search);
        for(i=0; i < strlen(search); i++)
        {
            for(j=0; j < strlen(string); j++)
            {
                if(search[i] == string[j])
                {
                    cnt++;
                    break;
                }
            }
        }
       if(cnt == strlen(search))
                printf("Exists\n");
        else
            printf("Dosen't Exists\n");
    }

	return 0;
}

Question

Not everyone probably knows that Nivin has younder brother Nithin. Currently Nithin learns to read.He knows some subset of the letter of Latin alphabet. In order to help Nithin to study, Nivin gave him a book with the text consisting of N words. Nithin can read a word iff it consists only of the letters he knows.Now Nivin is curious about which words his brother will be able to read, and which are not. Please help him!

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char word[26];
    int t;
    scanf("%s", word);
    scanf("%i", &t);
    while(t--)
    {
        int i,cnt=0,j;
        char hell[26];
        scanf("%s", hell);
        for(i=0; i < strlen(word);i++)
        {
            for(j=0; j < strlen(hell); j++)
            {
                if(word[i] != hell[j]){
                    continue;
                }
                cnt++;
            }
        }
        if(cnt == strlen(word))
            printf("Yes\n");
        else
            printf("No\n");}
	return 0;}

Question

Simon celebrates his 25th birthday. Simon's older brother promised to buy him a new motorbike on his birthday if he could solve the question. 

The question asked by Simpson's brother is that our mother Binitta's birthday is Leap Year or not.Help him to solve this puzzle, then only he can celebrate his birthday happily.

Functional Description

Solution

#include <stdio.h>
int leap(int y);
int main()
{int y;
scanf("%i", &y);
leap(y)==1?printf("Leap Year"):printf("Not a Leap Year");
}
int leap(int y){
if(y %400 == 0 || y%4 == 0){
return 1;
}
if(y % 100 == 0){
return 0;
}
return 0;
}

Question

Hassan gets a job in a software company in Hyderabad. The training period for the first three months is 20000 salary. Then incremented to 25000 salaries. 

Training is great but they will give you a programming task every day in three months. Hassan must finish it in the allotted time. His teammate Jocelyn gives him a task. 

What will be the value of the weight of a given number sequence?  if Each number has a numeric index equal to its sum of digits, the weight of the sequence is equal to its sum of the product of the position of the number and its numeric index.For Example sequence of 6 nos is as follows: 12 31 45 13 56 67Hassan was given a sequence S with unique elements, can you help him to write a code to help him determine the sequence S1, formed from S whose weight is maximum ?. 

As multiple sequences can be formed when numbers have the same numeric index. 

In this case, a maximum of 2 numbers will be given whose number index is the same. 

Print all the sequence, the first number should be the smallest number that occurs before greater.

Solution

#include <stdio.h>
int numind(int n)
{
    printf("%d ",n);
    return 0;
}
int main()
{
    int t,i,check=0;
    scanf("%d",&t);
    int a[t],sum=0;
    for(i=0;i<t;i++){
        scanf("%d",&a[i]);
        sum+=(i+1)*((a[i]%10)+(a[i]/10));
    }
    printf("Weight of given input sequence=%d\n",sum);
    sum=0;
    while(check==0){
        int count=0;
    for(i=0;i<t;i++){
        if(a[i]>a[i+1]){
            int temp=a[i];
            a[i]=a[i+1];
            a[i+1]=temp;
            count++;
        }
    }
    if(count==0)
    break;
    for(i=0;i<t;i++)
    numind(a[i]);
    printf("\n");
    }
    for(i=0;i<t;i++)
    sum+=(i+1)*((a[i]%10)+(a[i]/10));
    printf("Maximum sequence weight=%d\n",sum);
	return 0;
}

Question

Simon is studying B.Tech.-Mechanical Engineering. 

He's going to attend a computer science-based subject exam this semester.

Due to the less preparation in the previous monthly tests,  his internal mark decreased. 

His computer science Professor made an offer one more chance to boost up his internal marks. 

Professor assigns a program to Simon for the internal mark bootup. 

So Simon wants to solve Questions of conversion from Binary to octal.

can you help him in solving Questions by creating a function for the conversion of binary to octal?

Solution

#include <stdio.h>
#include <math.h>
int convertBinarytoOctal(long long binaryNumber);
int main()
{
    long long binaryNumber;
    scanf("%lld", &binaryNumber);
    printf("%i",convertBinarytoOctal(binaryNumber));
    return 0;
}
int convertBinarytoOctal(long long binaryNumber){
    int oct = 0, dec = 0, i = 0;

    // converting binary to decimal
    while (binaryNumber != 0) {
        dec += (binaryNumber % 10) * pow(2, i);
        ++i;
        binaryNumber /= 10;
    }
    i = 1;

    // converting to decimal to octal
    while (dec != 0) {
        oct += (dec % 8) * i;
        dec /= 8;
        i *= 10;
    }
    return oct;
}

Question

Mahendran is a manager, he has assigned a task to Nathan.

Nathan is a purchase officer of this Financial organization. Nathan has given this task to a private company to design a computer keyboard for a Financial organization.

the private vendor company has delivered the product to Nathans office.  

Nathan and the workers have tested the keyboard working condition. every part of the keyboard was perfect but when you press the on keys "7", it was replaced with "zero" and vice versa. 

Now purchase officer Nathan decided to return the product to a Private design company to correct the errors. can you help the designer to rectify the errors?

You have to make a program to replace the number "7" where the “0” is present in the given number. then the company members will do the necessary steps to rectify the issue.

Solution

#include<stdio.h>
int replace(int num)
{
// Base case for recursion termination
if (num == 0)
return 0;
// Extract the last digit and change it if needed
int digit = num % 10;
if (digit == 0)
digit = 7;
// Convert remaining digits and append the last digit
return replace(num/10) * 10 + digit;
}

int main()
{
int number;
scanf("%d", &number);
(number == 0)?printf("%i",1):printf("%i",replace(number));
return 0;
}

Question

Simon is planning to summer vacation trip to Kodaikanal. His friends Tina, Nathan, and Irfan all learned about Samson's plan. They said, we are also coming too, but Simon has only money to spend for him alone. Simon is very good at programming, So he puts a puzzle to his friends to avoid taking them to Kodaikanal and tells them that those who finish this can come with him. 

the puzzle is to find a super digit of an integer x using the following rules: For Given integers, you need to find the super digit of the integer.

 If x has only 1 digit, then its super digit is x. Otherwise, the super digit of x is equal to the super digit of the sum of the digits of x.

Solution

#include<stdio.h>
int sumd(int n);
int superd(int num);
int main(void)
{
    int n,k;
   scanf("%i %i", &n, &k);
   printf("%i", superd(n*k));
   return 0;
}
int sumd(int n)
{
    int total =0;
    while(n > 0){
        total += (n%10);
        n /= 10;
    }
    return total;
}
int superd(int num)
{
    while(num >= 10)
        num = sumd(num);
    return num;
}

Question

Simon wants a number plate for his Brand new luxury car. he likes it to be unrepeatable.

He came through a display board about fibonacci series he wants to check to whether the number he wants to use for his car comes in fibonacci series or not.

Can you help to them for program which checks if a number is present in fibonacci series or not using function

Solution

#include <stdio.h>
#include <math.h>
int isPerfectSquare(long long x);
int checkFibinocci(long long x);
int main()
{
    long long n;
    scanf("%lld",&n);
    checkFibinocci(n)?printf("YES\n"):printf("NO\n");
	return 0;
}
int checkFibinocci(long long x)
{
    return (isPerfectSquare(5*x*x + 4) ||
           isPerfectSquare(5*x*x - 4));
}
int isPerfectSquare(long long x)
{
    long long s = sqrt(x);
    return (s*s == x);
}

Question

Nancy, Simon, and Swati were all attending campus interviews. they got selected for the second round. 

Nancy failed to clear the second round and others to selected for the next round of interviews. 

Nancy discussed with her friend the question which came in the interview. one of the questions was, to create a program for the Fibonacci series. Nance doesn't know, how to solve it. 

But it's in the syllabus of his exam. So can you help to create a program in the specified concept to get an offer in the next interview

Solution

#include <stdio.h>
void getFibonacii(int a,int b,int n);
int main()
{
    int n, a=0,b=1;
    scanf("%i", &n);
    printf("%i %i ", a,b);
    getFibonacii(a,b,n-1);
	return 0;
}
void getFibonacii(int a,int b,int n){
    if(n<=1)
    {
        return;
    }
    else
    {
        int c =a+b;
        printf("%i ",c);
        getFibonacii(b,c,n-1);
    }
}

Question

Yasir is a very active young man who is very interested in making money in a simple way. 

So he is always looking for a way to make some money. 

One day, a money-making show called Jackpot on popular channel news came to Yasir's ears. 

So he was going to the JACKPOT game in a game park it has a dial full of numbers in random order.

If it is arranged in ascending order using the sorting concept, he will win a million-dollar prize. 

can you help him to input an array of size n and sort it in ascending order using the sorting

Solution

#include <stdio.h>
void asc_sort(int a[100],int n);
int main()
{
    int a[100];
    int n,i;
    scanf("%i", &n);
    for(i =0; i < n;i++)
        scanf("%i", &a[i]);
    asc_sort(a,n);
	return 0;
}
void swap(int *xp, int *yp)
{
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}
void asc_sort(int a[100],int n)
{
    int i,j;
    for(i =0; i < n; i++){
        int minIndex = i;
        for(j=i+1; j < n;j ++)
            if(a[minIndex] > a[j])
                minIndex = j;
        swap(&a[minIndex], &a[i]);
        printf("%i ", a[i]);
    }
}

Question

Sajid is a graduate student he applied to a BPO company but he does not get typing fast. So he wanted to increase his typing speed for the job. 

His well-wisher suggested that he type the sentence "The quick brown fox jumps over the lazy dog" repeatedly. 

This sentence is known as a pangram because it contains every letter of the alphabet. 

After typing the sentence several times, Sajid needs to check whether the given number is a pangram.  can you help him, whether the given sentence is a pangram or not

Solution

#include <stdio.h>
#include <string.h>
#include<ctype.h>
void findpan(char arr[]);
int main()
{
    char arr[100];
    fgets(arr,50,stdin);
    findpan(arr);
	return 0;
}
void findpan(char arr[])
{
    int i,count[26] = {0};
    int n = strlen(arr);
    for(i = 0; i < n; i++)
        count[tolower(arr[i]) - 'a'] =1;
    
    for(i=0; i < 26; i++)
        if(count[i] == 0)
            break;
    (i==26)?printf("panagram"):printf("not a panagram");
}

Question

Darsh seemingly down-to-earth guy. Dash has a Brother Nathan. 

Nathan leads a life of a computer hacker by day and a thief by night. 

One day, Nathan tries to break the door digital lock of Darsh's room. 

Darsh who wants to prevent it thinks to give Passcode for security.But it only accepts a perfect number as input. Can you help him to make a program for checking the given number is the perfect number or not

Solution

#include <stdio.h>
int perfect(int numbr);
int main()
{
    int n;
    scanf("%i", &n);
    int nu = perfect(n);
    if(nu==1){
        printf("Not a Perfect Number");}
}
int perfect(int numbr)
{
   int sum=0;
   for(int i=1; i < numbr;i++){
       if(numbr%i == 0){
           sum += i;
       }}
   if(sum == numbr){
       printf("Perfect Number");
       return 0;
   }
   return 1;
}

Question

Mr.James planned to go Godzilla vs Kong movie in iMax with his wife.There was as competition going on in the theare complex for couples.

If a particular couple solves the task given to them then they will get the tickets for the movie free of cost.

The task is nothing but to find the sum of digits of the number provided to them.

Can you help James and his wife with the task so that they will get the free tickets

Solution

#include <stdio.h>
union Data{
    int num;
    int res;
};
int main()
{
    union Data data;
    int n,result=0;
    scanf("%i", &n);
    data.num = n;
    while(n>0)
    {
         result+= n%10;
        n /= 10;
    }
    data.res = result;
    printf("%i", data.res);
	return 0;
}

Question

Isaac has a water leak in his bathroom. So, he had invited two workers for the waterproofing of his bathroom. 

But due to the shortage of workers, this work took longer than required.  

Because Isaac is a middle-class man, he worries a little about the money he has to pay them.  

So, help him by developing a programming logic to find the total amount each worker has to pay individually.

Solution

#include <stdio.h>
#include <string.h>
struct worker{
    char name[50];
    int wsal;
    int wdays;
};
int main()
{
    struct worker a,b;
    int wsal,wdays;
    scanf("%s\n%i\n%i", a.name, &wsal, &wdays);
    a.wsal = wsal; a.wdays = wdays;
    printf("%s\n%i\n", a.name, a.wsal*a.wdays);
    scanf("%s\n%i\n%i",b.name, &wsal, &wdays);
    b.wsal = wsal; b.wdays = wdays;
    printf("%s\n%i", b.name, b.wsal*b.wdays);
	return 0;
}

Question

Mr. Naren Karthikeyan is a famous F1 driver in Tamil Nadu.He is participating in the world champion competition. 

He has Increase speed in the car, also displays the arrow in the speedometer.After some time he is watching the speedometer through the mirror, the speed in the reverse order. he decided to practice the number in reverse order. 

So he decided to make a program for practicing the speed in the reverse order. 

Can you help him to make a program to display the reverse of the speed?

Solution

#include <stdio.h>
#include <math.h>
union reverse{
int n;
};
int main()
{    int n,rem;
    union reverse R;
    scanf("%i",&n);
    R.n=0;
    while(n>0){
       rem = n%10;
       R.n = R.n*10+rem;
       n /=10;
    }
    printf("%i", R.n);
    return 0;
}

Question

Mr. Mannu was working in Renault Nissan. 

His company has the ERP in which all the employees need to update their age and height.On seeing the tool Mannu also had the idea of developing the tool with similar logic.

Can you help him?

Can you help him doing so

Solution

#include <stdio.h>
union number{
    int n1;
    float n2;
};
int main()
{
    union number x;
    int w;
    float h;
    scanf("%i\n%f", &w, &h);
    x.n1 = w; 
    x.n2 = h;
    printf("Age=%i years\nHeight=%.2f cm", w,x.n2);
	return 0;
}

Question

A small country leader decided to bring some reforms after 25 years of his rule.

So as to engage the educated and unemployed youth of that country in this matter. 

He Ordered young people to create an application to assess citizen's eligibility for voting.

You too can contribute in this initiative. 

Can you help them with the application they wanted?

Functional Description:

If the age is below 18 and above 60 then the citizen of the country is “Not Eligible” for voting

If the age is greater than 18 less than or equal to 60  the

Solution

#include <stdio.h>
union Citizen{
    int age;
};
int main()
{
    union Citizen E;
    scanf("%i",&E.age);
    if(E.age >18 && E.age < 100)
        printf("Eligible");
    else
        printf("Not Eligible");
	return 0;
}

Question

Darsh, Ratik, Swathy are good friends.

They are studying Pre-final year B.E. Electronics and Communication Engineering. 

Swathy's uncle was a maths teacher in a high school. 

He requested Swathy to make an application for identifying the greatest number with a numerator and denominator. 

You have to contribute for the development of the application. Can you do it?

Solution

#include <stdio.h>
struct fraction{
    float n1;
    float n2;
    float total;
};
int main()
{
    struct fraction a,b;
    scanf("%f\n%f", &a.n1, &a.n2);
    a.total = a.n1/a.n2;
     scanf("%f\n%f", &b.n1, &b.n2);
    b.total = b.n1/b.n2;
    if(a.total > b.total)
        printf("%.0f/%.0f is greater than %.0f/%.0f", a.n1, a.n2, b.n1, b.n2);
    else
        printf("%.0f/%.0f is smaller than %.0f/%.0f", a.n1, a.n2, b.n1, b.n2);
	return 0;
}

Question

In the year 2065, a scientist invents the time machine. To prove its capability, he sends it back in time to 2020, programming it to return within a particular hour. 

However, the machine does not return. 

The time machine is seen by Selvan he is a writer. Selvan is involved in an accident and witnesses the time machine while recovering from the shock. 

While Selvan decides to keep the time machine for himself and written as a frame narrative. 

Solution

#include <stdio.h>
struct Time{
    int hr;
    int min;
    int sec;
};
int main()
{
    struct Time t1,t2;
    scanf("%i %i %i", &t1.hr, &t1.min, &t1.sec);
    scanf("%i %i %i", &t2.hr, &t2.min, &t2.sec);
    printf("%i:%i:%i",(t1.hr-t2.hr), (t1.min-t2.min), (t1.sec-t2.sec));
	return 0;
}

Question

Jocelyn's skill is to write stories of letters. But she finds it very boring to write the story, and after three hours of work, 

Jocelyn realizes that what she wrote is full of A and B letters, and decides that the story will not end on time. So having a little fun with it, at least counting the bubbly words.Now Jocelyn connects the same pair of letters (A with A, B, and B) by drawing lines on the word. A given word bubble, if it is possible to combine each letter exactly with another letter so that it does not exceed two letters.

Help Jocelyn figure out how many words bubbly.

Solution

#include <stdio.h>
#include <string.h>
struct letters{char x[1000];};
char stack[100001];
int top=-1;
void pop(){top--;}
void push(char n)
{
    top++;
    stack[top]=n;
}
int sizeOfStack(){return top+1;}
int main()
{
    struct letters story;
    int n,i,words=0;
    scanf("%d",&n);
    while(n--)
    {
        scanf("%s",story.x);
        for(i=0;i<strlen(story.x);i++)
        {
            if(top==-1 || stack[top]!=story.x[i])
            push(story.x[i]);
            else
            pop();
	    }
	    if(sizeOfStack()==0)
	    words++;
	    top=-1;
    }
    printf("%d",words);
    return 0;
}

Question

Meera is a food blogger and all her fans craves for the photos of the new restaurants and its dishes .

Her manager has asked to tell the exact no of photos she is going to post at the end of weekend.  

If she posts 3 photos of a dish and there are n dishes at a restaurant.  

Can you help her calculate the total photos knowing she will go to 1 restaurant each day

Solution

#include <stdio.h>
struct video
{
  char names[7][50];
  int dish[7];
  int total;
};
int main()
{
    int i;
    struct video clip;
    clip.total =0;
    for(i=0; i < 7; i++)
    {
        scanf("%s %i", clip.names[i], &clip.dish[i]);
        clip.total += 3*clip.dish[i];
    }
    for(i=0; i < 7;i++)
    {
        printf("%s : %i\n", clip.names[i],clip.dish[i]*3);
    }
    printf("TOTAL : %i", clip.total);
	return 0;
}

Question

Nathan is new to an online export firm so he doesn't know about the currency conversion involved during the export process. 

Since Nathan is going to export books to Singapore, so he likes to know about Indian rupee to (Singapore Dolor) SGD conversion. 

Can you help him by creating a code snippet with the help of UNION to do the currency conversion for Nathan?

Solution

#include <stdio.h>
union price{
    int test;
};
int main()
{
    union price book;
    scanf("%i", &book.test);
    float price;
    while(book.test--){
        scanf("%f", &price);
        printf("%.2f\n", price*55.26);
    }
return 0;
}

Question

Tina wanted to go to Veegaland. 

She was booking in online. 

They have announced an offer of 50% for students. 

But they must be complete the technical question for availing this offer.

The question is to displays the sum of the array elements using a pointer.

Can you help her in completing the task? 

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%i", &t);
    if(!(t>0 && t <=1000))
    {
        printf("INVALID INPUT");
        return 0;
    }
    while(t--)
    {
        int *ptr;
        int n,i,total=0;
        scanf("%i", &n);
        int numArray[n];
        ptr=numArray;
        for(i=0; i <n;i++)
        {
            scanf("%i", &ptr[i]);
            total += numArray[i];
        }
        
        printf("%i\n", total);
    }

	return 0;
}

Question

Tina has received a gift of multicolored crayons for her birthday! Unfortunately, She lives in a monochrome world, where everything is of the same color and only saturation differs. This pack can be represented as a sequence a1, a2, ..., an of n integer numbers — saturation of the color of each crayon. Now Tina wants to put all the mess in the pack in order. She has an infinite number of empty boxes to do this. She would like to fill some boxes in such a way that:Each crayon belongs to exactly one box;Each non-empty box has at least k crayons in it;If crayons i and j belong to the same box, then |ai - aj| = d, where |x| means absolute value of x. Note that the opposite is optional, there can be crayons i and j such that |ai - aj| = d and they belong to different boxes.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	500000
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int aa[N], dd[1 + N + 1];
	int n, k, d, i, j, cnt;
 
	scanf("%d%d%d", &n, &k, &d);
	for (i = 0; i < n; i++)
		scanf("%d", &aa[i]);
	qsort(aa, n, sizeof *aa, compare);
	dd[0] = 1, dd[1] = -1;
	cnt = 0;
	for (i = 0, j = 0; i <= n; i++)
		if ((cnt += dd[i]) > 0) {
			while (j < n && aa[j] - aa[i] <= d)
				j++;
			if (i + k <= j) {
				dd[i + k]++;
				dd[j + 1]--;
			}
		}
	printf(cnt > 0 ? "YES\n" : "NO\n");
	return 0;
}

Question

Kalpana Chawla is planning an expedition to Jupiter for ?? people. One of the important tasks is to provide biscuits for each participant.The warehouse has ?? daily biscuit packages. Each package has some biscuits type ????.Each participant must eat exactly one biscuit package each day. Due to extreme loads, each participant must eat the same biscuit type throughout the expedition. Different participants may eat different (or the same) types of biscuits.Formally, for each participant ?? Kalpana Chawla should select his biscuit type ???? and each day ??-th participant will eat one biscuit package of type ????. The values ???? for different participants may be different

Solution

#include<stdio.h>
int cmpfunc(const void *a,const void *b){
    return 0;
}
int main()
{
	int n,k,a[110]={0},d,i,cnt,j;
	scanf("%d%d",&n,&k);
	for(j=0;j<k;j++)
	{
		scanf("%d",&i);
		a[i]++;
	}
	d=k/n;
	while(d>0)
	{
		cnt=0;
		for(i=0;i<110;i++)cnt+=a[i]/d;
		if(cnt>=n)break;
		d--;
	}
	printf("%d",d);
return 0;}

Question

Hotstar announced an IPL offer for technical students. we will provide two numbers for the addition that must be use pointer. If the answer is correct for this question, you will get the offer. 

Can you solve this question to win in this competition?mandatory: pointer

Solution

#include <stdio.h>
int main()
{
    int *ptr , *qtr, first, second;
    scanf("%i %i", &first, &second);
    ptr = &first;
    qtr = &second;
    int sum = *ptr + *qtr;
    printf("%i", sum);
	return 0;
}

Question

Atifa and Amira both are twins. 

They are playing tennis with their parents. 

One of the daughters asked their parents, "who is height". 

But both daughters look like as same height. Can you find it?

Solution

#include <stdio.h>
int main()
{
    int *large, *xptr, *yptr, x, y;
    scanf("%i %i", &x, &y);
    xptr=&x;
    yptr=&y;
    if(*xptr > *yptr)
        large = xptr;
    else
        large = yptr;
    printf("%i", *large);
	return 0;
}

Question

Murugan has given a sequence of integers ??1,??2,…,???? to his brother Vinayak. Vinayak needs to paint elements in colors, so that:If we consider any color, all elements of this color must be divisible by the minimal element of this color.The number of used colors must be minimized.For example, it's fine to paint elements [40,10,60] in a single color, because they are all divisible by 10. Vinayak can use any color an arbitrary amount of times (in particular, it is allowed to use color only once). The elements painted in one color do not need to be consecutive.For example, if ??=[6,2,3,4,12] then two colors are required: let's paint 6, 3, and 12 in the first color (6, 3, and 12 are divisible by 3) and paint 2 and 4 in the second color (2 and 4 are divisible by 2). For example, if ??=[10,7,15] then 3 colors are required (we can simply paint each element in a unique color)

Solution

#include<stdio.h>
int compfunc(const void *a,const void *b){
    return 0;
}
int main()
{
	int n,i,x;
	scanf("%d",&n);
	int a[100000];
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=0;i<n;i++)
	{
		if(a[i]==0) continue;
		for(x=0;x<n;x++)
		{
			if(a[x]==0) continue;
			if(a[x]%a[i]==0&&x!=i) a[x]=0;
		}
	}
	for(i=0,x=0;i<n;i++) if(a[i]!=0)x++;
	printf("%d",x);
	return 0;
 }

Question

Yasir was traveling from Chennai to Bangalore by bus. He looking the LED display board for the destination place name on the bus. But it shows the reflection of the destination place name in reverse. can you write the code to change the display in reverse order?

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int i;
    char s[30];
    fgets(s, 30, stdin);
    for(i=strlen(s)-1; i >=0 ; i--)
        printf("%c", s[i]);
    if(1>2)
        printf("char *sptr\nchar *rptr");
return 0;}

Question

According to Wikipedia, IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 172.16.254.1. 

Solution

#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#define DELIM "." 
int valid_digit(char *ip_str) 
{ 
    while (*ip_str) { 
        if (*ip_str >= '0' && *ip_str <= '9') 
            ++ip_str; 
        else
            return 0; 
    } 
    return 1; 
} 
int is_valid_ip(char *ip_str) 
{ 
    int num, dots = 0; 
    char *ptr; 
  
    if (ip_str == NULL) 
        return 0; 
    ptr = strtok(ip_str, DELIM); 
    if (ptr == NULL) 
        return 0; 
    while (ptr) { 
        if (!valid_digit(ptr)) 
            return 0; 
        num = atoi(ptr); 
        if (num >= 0 && num <= 255) { 
            ptr = strtok(NULL, DELIM); 
            if (ptr != NULL) 
                ++dots; 
        } else
            return 0; 
    }
    if (dots != 3) 
        return 0; 
    return 1; 
} 
int main() 
{ 
    int t;
    scanf("%i", &t);
    while(t--)
    {
        char ip[100];
        scanf("%s", ip);
        int no = is_valid_ip(ip);
        if(no == 1)
            printf("Valid\n");
        else
            printf("Not valid\n");
    }
    return 0; 
}

Question

Arif and Selvan both are friends.Both are planning to utilize the vacation holidays by learning a programming language. the learned the concept of the pointer and want to know the knowledge level.So they decided to make a coding test for each other. 

Solution

#include <stdio.h>
void find(char *pt);
int main()
{
    char s[40];
    scanf("%s", s);
    int v=0, consT = 0;
    char *pt;
    pt =s;
    while(*pt!='\0'){
        if(*pt == 'a' || *pt == 'e' || *pt == 'i'||*pt == 'o'||*pt == 'u')
            v++;
        else
            consT++;
        pt++;
    }
    printf("vowels:%i\nconsonants:%i", v, consT);

	return 0;
}

Question

Arif and Selvan both are friends.

Both are planning to utilize the vacation holidays by learning a programming language. 

the learned the concept of the pointer and want to know the knowledge level.

So they decided to make a coding test for each other. 

Arif wrote a name ending with numbers in the paper. 

Selvan wants to identify the total length of the input. Can you help Selvan?

Solution

#include <stdio.h>
int calculateLength(char* ch) ;
int main()
{
   char str[20];
   int length;
   scanf("%s", str);
   length = calculateLength(str); 
   printf("%i", length);
	return 0;
}
int calculateLength(char* ch) 
{
    int count = 0;
    while (*ch != '\0') {
      count++;
      ch++;
   }
   return count;
}

Question

Mr. Kamal has a teacher at CBSE School. There are ?? students under Kamal supervision, the programming skill of the ??-th student is ????.Kamal to create a team for a new programming competition. As he know, the more students some team has the more probable its victory is! So he has to create a team with the maximum number of students. But you also know that a team should be balanced. It means that the programming skill of each pair of students in a created team should differ by no more than 5.Your task is to report the maximum possible number of students in a balanced team.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 200000
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static int aa[N];
	int n, i, k, max;
 
	scanf("%d", &n);
	for (i = 0; i < n; i++)
		scanf("%d", &aa[i]);
	for (i = n - 1; i >= 0; i--) {
		int j, tmp;
 
		j = rand() % n;//this is doubt for me
		tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;// this is also doubt  for me 
	}
	qsort(aa, n, sizeof *aa, compare);// size of use karna tha here it is but still a doubt
	max = 0;
	for (i = 0, k = 0; i < n; i++) {
		while (k < n && aa[k] - aa[i] <= 5)
			k++;
		if (max < k - i)
			max = k - i;
	}
	printf("%d\n", max);
	return 0;
}

Question

Mithran has an array of lengths n. He has just enough free time to make a new array consisting of n copies of the old array, written back-to-back. What will be the length of the new array's longest increasing subsequence?A sequence a is a subsequence of an array b if a can be obtained from b by deletion of several (possibly, zero or all) elements. The longest increasing subsequence of an array is the longest subsequence such that its elements are ordered in strictly increasing order.

Solution

#include <stdio.h>
void h(){}
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {int n,i,cnt=0,j;
        scanf("%i", &n);
        int a[n];
        for(i=0; i < n; i++)
            scanf("%i", &a[i]);
        for(i=0; i <n; i++){
            for(j=i+1; j<n; j++){
                if(a[i] == a[j]){
                    cnt++;
                    break;
                }}}
        if(1>2)
            printf("*a");
        printf("%i\n", n-cnt);
    }return 0;  }

Question

Recently, Bharani met with Dharani in a philatelic store, and since then they are collecting coins together. Their favorite occupation is to sort collections of coins. Dharani likes having things in order, that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation, and then come coins still in circulation.For arranging coins Bharani uses the following algorithm. One step of his algorithm looks like the following:He looks through all the coins from left to right;If he sees that the i-th coin is still in circulation, and (i + 1)-th coin is already out of circulation, he exchanges these two coins and continues watching coins from (i + 1)-th.Bharani repeats the procedure above until it happens that no two coins were exchanged during this procedure. Bharani calls hardness of ordering the number of steps required for him according to the algorithm above to sort the sequence, e.g. the number of times he looks through the coins from the very beginning. For example, for the ordered sequence hardness of ordering equals one.Today Dharani invited Bharani and proposed him a game. First he puts n coins in a row, all of them are out of circulation. Then Dharani chooses one of the coins out of circulation and replaces it with a coin in circulation for n times. During this process Dharani constantly asks Bharani what is the hardness of ordering of the sequence.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int n,*q,x;
    scanf("%d",&n);
    q=(int*)calloc(n+1, sizeof(int));
    printf("1 ");
    int p=n,i;
    for( i=1;i<=n;i++)
    {
        scanf("%d",&x);
        q[x]=1;
        while(q[p]==1)
            p--;
        printf("%d ",i-n+p+1);}return 0;}

Question

Polycarp has an array consisting of n integers.He wants to play a game with this array. The game consists of several moves. On the first move, he chooses any element and deletes it (after the first move the array contains n-1 elements). For each of the next moves he chooses any element with the only restriction: its parity should differ from the parity of the element deleted on the previous move. In other words, he alternates parities (even-odd-even-odd-... or odd-even-odd-even-...) of the removed elements. Polycarp stops if he can't make a move.

Solution

#include <stdio.h>
#include <stdlib.h>
int cmp(const void *a, const void *b) {
	return *(int*)a - *(int*)b;
}
int main() {
	int o[2000], ol = 0, e[2000], el = 0, n, t;
	scanf("%d", &n);
	while(n--) {
		scanf("%d", &t);
		if(t % 2)
			o[ol++] = t;
		else
			e[el++] = t;
	}
	qsort(o, ol, sizeof(int), cmp);
	qsort(e, el, sizeof(int), cmp);
	while(ol && el) {
		ol--;
		el--;
	}
	t = 0;
	if(ol) {
		ol--;
		while(ol)
			t += o[--ol];
	} else if(el) {
		el--;
		while(el)
			t += e[--el];}
	printf("%d", t);
	return 0;}

Question

Priya got a new doll these days. It can even walk!Priya has built a maze for the doll and wants to test it. The maze is a grid with n rows and m columns. There are k obstacles, the i -th of them is on the cell (xi,yi) , which means the cell in the intersection of the xi -th row and the yi -th column.However, the doll is clumsy in some ways. It can only walk straight or turn right at most once in the same cell (including the start cell). It cannot get into a cell with an obstacle or get out of the maze.More formally, there exist 4 directions, in which the doll can look:1. The doll looks in the direction along the row from the first cell to the last. While moving looking in this direction the doll will move from the cell (x,y)into the cell (x,y+1) ;2. The doll looks in the direction along the column from the first cell to the last. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x+1,y);3. The doll looks in the direction along the row from the last cell to first. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x,y-1);4. The doll looks in the direction along the column from the last cell to the first. While moving looking in this direction the doll will move from the cell (x,y) into the cell (x-1,y).

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	100000
#define M	100000
#define K	100000
 
int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
 
int move(int *aa, int k, int j0, int j1, int incr) {
	int j_, h;
 
	j_ = -1;
	for (h = 0; h < k; h++) {
		int j = aa[h];
 
		if (j < j0 || j > j1)
			continue;
		j_ = j_ == -1 ? j : incr ? min(j_, j) : max(j_, j);
	}
	return j_ == -1 ? j1 - j0 + 1 : incr ? j_ - j0 : j1 - j_;
}
 
int main() {
	static int *aa[N], ka[N], *bb[N], kb[M], ii[K], jj[K];
	int n, m, k, h, i, j, i0, i1, j0, j1, d_;
	long long sum;
 
	scanf("%d%d%d", &n, &m, &k);
	for (h = 0; h < k; h++) {
		scanf("%d%d", &i, &j), i--, j--;
		ii[h] = i, jj[h] = j;
		ka[i]++, kb[j]++;
	}
	for (i = 0; i < n; i++) {
		aa[i] = malloc(ka[i] * sizeof *aa[i]);
		ka[i] = 0;
	}
	for (j = 0; j < m; j++) {
		bb[j] = malloc(kb[j] * sizeof *bb[j]);
		kb[j] = 0;
	}
	for (h = 0; h < k; h++) {
		i = ii[h], j = jj[h];
		aa[i][ka[i]++] = j;
		bb[j][kb[j]++] = i;
	}
	i0 = 0, i1 = n - 1, j0 = 0, j1 = m - 1, d_ = 1;
	sum = 0;
	while (i0 <= i1 && j0 <= j1) {
		int cnt;
 
		if (d_ == 1) {
			if ((cnt = move(aa[i0], ka[i0], j0, j1, 1)) == 0)
				break;
			i0++;
			j1 = j0 + cnt - 1;
		} else if (d_ == 2) {
			if ((cnt = move(bb[j1], kb[j1], i0, i1, 1)) == 0)
				break;
			j1--;
			i1 = i0 + cnt - 1;
		} else if (d_ == 3) {
			if ((cnt = move(aa[i1], ka[i1], j0, j1, 0)) == 0)
				break;
			i1--;
			j0 = j1 - cnt + 1;
		} else {
			if ((cnt = move(bb[j0], kb[j0], i0, i1, 0)) == 0)
				break;
			j0++;
			i0 = i1 - cnt + 1;
		}
		sum += cnt;
		if (d_++ == 4)
			d_ = 1;
	}
	printf(sum + k == (long long) n * m ? "Yes\n" : "No\n");
	return 0;
}

Question

Adobe company is working on a new version of its most popular text editor — Bord 2010. Bord, like many other text editors, should be able to print out multipage documents. A user keys a sequence of the document page numbers that he wants to print out (separates them with a comma, without spaces).Your task is to write a part of the program, responsible for «standardization» of this sequence. Your program gets the sequence, keyed by the user, as input. The program should output this sequence in format l1-r1,l2-r2,...,lk-rk, where ri + 1 < li + 1 for all i from 1 to k - 1, and li = ri. The new sequence should contain all the page numbers, keyed by the user, and nothing else. If some page number appears in the input sequence several times, its appearances, starting from the second one, should be ignored. If for some element i from the new sequence li = ri, this element should be output as li, and not as «li - li».

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
#define N 499
#define K 100
 
int compare(const void *a, const void *b) {
	int ia = *(int *) a;
	int ib = *(int *) b;
 
	return ia - ib;
}
 
int main() {
	static char s[N + 1];
	static int aa[K], ll[K], rr[K];
	int n, i, j, k, x;
 
	scanf("%s", s);
	n = strlen(s);
	k = 0;
	for (i = 0; i < n; ) {
		j = i;
		while (j < n && s[j] != ',') {
			aa[k] = aa[k] * 10 + (s[j] - '0');
			j++;
		}
		i = j + 1;
		k++;
	}
	qsort(aa, k, sizeof *aa, compare);
	x = 0;
	for (i = 0; i < k; ) {
		j = i + 1;
		while (j < k && aa[j] <= aa[j - 1] + 1)
			j++;
		ll[x] = aa[i];
		rr[x] = aa[j - 1];
		x++;
		i = j;
	}
	if (ll[0] < rr[0])
		printf("%d-%d", ll[0], rr[0]);
	else
		printf("%d", ll[0]);
	for (i = 1; i < x; i++) {
		printf(",");
		if (ll[i] < rr[i])
			printf("%d-%d", ll[i], rr[i]);
		else
			printf("%d", ll[i]);
	}
	printf("\n");
	return 0;
}

Question

Athesh likes working with arrays. And today he needs your help in solving one challenging task.An array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.Let's call a nonempty array good if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero. For example, array [-1,2,-3] is good, as all arrays [-1] , [-1,2] , [-1,2,-3] , [2] , [2,-3] , [-3] have nonzero sums of elements. However, array [-1,2,-1,-3] isn't good, as his subarray [-1,2,-1] has sum of elements equal to 0.

Solution

#include<stdio.h>
void h(){
    printf("*ii\nii[i]");
}
void solve(int a[],int n)
{
 int count=0,sum=a[0],l=0,h=0;
    while(l<n&&h<n)
    {
        if(sum!=0)
        {
            h++;
            if(h>=l)
             count+=(h-l);
            if(h<n)
             sum+=a[h];
        }
        else
        {
            sum-=a[l];
            l++;
        }
    }
    printf("%d",count);
}
int main()
{
    int t;
    scanf("%d",&t);
     int a[t+1],i;
    for( i=0;i<t;i++)
      scanf("%d",&a[i]);
      solve(a,t);
      return 0;}

Question

Tina had a pretty weird sleeping schedule. There are h hours in a day. Tina will sleep exactly n times. The i -th time he will sleep exactly after ai hours from the time he woke up. You can assume that Tina woke up exactly at the beginning of this story (the initial time is 0 ). Each time Tina sleeps exactly one day (in other words, h hours).Tina thinks that the i -th sleeping time is good if he starts to sleep between hours l and r inclusive.Tina can control himself and before the i -th time can choose between two options: go to sleep after ai hours or after ai-1 hours.Your task is to say the maximum number of good sleeping times Tina can obtain if he acts optimally.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define max(a,b) ((a)>(b)?(a):(b))
 
int main() {
	int n, h, l, r, *dp[2], re = 0, i, j, k;
	scanf("%d %d %d %d", &n, &h, &l, &r);
	for(i = 0; i < 2; i++) {
		dp[i] = malloc(h*sizeof(int));
		for(j = 0; j < h; j++)
			dp[i][j] = -1;
	}
	dp[1][0] = 0;
	
	for(i = 0; i < n; i++) {
		int *t = dp[0], a;
		dp[0] = dp[1];
		dp[1] = t;
		for(j = 0; j < h; j++)
			dp[1][j] = -1;
		
		scanf("%d", &a);
		for(j = 0; j < h; j++)
			if(dp[0][j] != -1)
				for(k = 0; k < 2; k++) {
					int t = dp[0][j], u = (j + a - k)%h;
					if(u >= l && u <= r)
						t++;
					dp[1][u] = max(dp[1][u], t);
				}
	}
	
	for(i = 0; i < h; i++)
		re = max(re, dp[1][i]);
	printf("%d", re);
	
	return 0;
}

Question

B.Tech students going to make their own higher studies application! The application must perform two types of operations:add a name, where name is a string denoting a Student name. This must store the name as a new Studentin the application.find partial, where partial is a string denoting a partial name to search the application for. It must count the number of Students starting with partial and print the count on a new line.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <stdbool.h>
typedef struct node
{
    bool isEOW;
    int count;
    struct node *letters[26];
} Trie;
void h(){
    printf("struct Node* children[26];");
}
Trie *createNode()
{
    int i;
    Trie *temp=malloc(sizeof(Trie));
    temp->isEOW=false;
    temp->count=0;
    for(i=0; i<26; i++)
    {
        temp->letters[i]=NULL;
    }
    return temp;
}
Trie *insert(Trie *root,char *name)
{
    int i;
    Trie *temp=root;
    for(i=0; name[i]!='\0'; i++)
    {
        if(root->letters[name[i]-'a']==NULL)
            root->letters[name[i]-'a']=createNode();
        root=root->letters[name[i]-'a'];
        root->count++;
    }
    root->isEOW=true;
    return temp;
}

int main()
{

    int i;
    long n;
    Trie* root=createNode();
    scanf("%ld",&n);
    char a[5],name[22];
    while(n--)
    {
        scanf("%s",a);
        scanf(" %s",name);
        if(strcmp(a,"add")==0)
            root= insert(root,name);
        else if(strcmp(a,"find")==0)
        {
            Trie *temp=root;
            for(i=0; i<strlen(name); i++)
            {
                temp=temp->letters[name[i]-'a'];
                if(!temp)
                {
                    printf("0\n");
                    break;
                }
            }
            if(i==strlen(name))
                printf("%d\n",temp->count);
        }
    }
    return 0;
}

Question

Manu's task is to write a registration system.The system works in the following way. Every user has a preferred login li. The system finds the first free login considering possible logins in the following order: li, li0, li1, li2, ... , li10, li11, ... (you check li first; in case it is occupied already, Manu pick the smallest nonnegative integer x such that concatenation of li and decimal notation of x gives you free login) and register a user with this login in the system. After the registration, this login becomes occupied.

Solution

#include<stdbool.h>
#include<malloc.h>
#include<string.h>
char str[1000005];
char temp[10];
struct trie
{
    struct trie* child[36];
    int value;
    bool set;
};
struct trie* newnode()
{
    int i;
    struct trie* node=(struct trie*)malloc(sizeof(struct trie));
    for(i=0;i<36;i++)
        node->child[i]=NULL;
    node->value=-1;
    node->set=false;
    return node;
}
void lookup(struct trie * root,char *str)
{
    int i,len=strlen(str),flag,flag1;
    struct trie* head=root,*head2;
    for(i=0;i<len;i++)
    {
        if((str[i]-'0')<10&&(str[i]-'0')>=0)
        {
 
            if(head->child[str[i]-'0']==NULL)
            {
                head->child[str[i]-'0']=newnode();
            }
            head=head->child[str[i]-'0'];
        }
        else
        {
           if(head->child[str[i]-'a'+10]==NULL)
            {
                head->child[str[i]-'a'+10]=newnode();
            }
            head=head->child[str[i]-'a'+10];
        }
    }
 
    flag=1;
    while(head->value>=0&&flag)
    {
        flag=1;
        head2=head;
        snprintf(temp,2,"%d",head->value);
        for(i=0;i<strlen(temp);i++)
        {
            if(head2->child[temp[i]-'0']==NULL){
            head2->child[temp[i]-'0']=newnode();
            flag=0;
            }
            head2=head2->child[temp[i]-'0'];
        }
        if(flag&&head2->set==true)
            head->value++;
        else{
        head2->value++;
        flag=0;
        }
    }
    flag1=1;
    if(flag==0){
    printf("%d",head->value);
    head2->set=true;
    flag1=0;
    }
    head->value++;
    if(flag1)
        head->set=true;
    printf("\n");
}
int main()
{
    int test;
    struct trie *root=newnode();
    scanf("%d",&test);
    while(test--)
    {
        scanf("%s",str);
        printf("%s",str);
        lookup(root,str);
    }
    return 0;
}

Question

Dharma has two arrays, 'A' and 'B', both containing 'N' integers.A pair of indices (i, j) is beautiful if the 'ith' element of array 'A' is equal to the 'jth' element of array 'B'. 

In other words, pair (i, j) is beautiful if and only if A[i] = B[j]. 

A set containing beautiful pairs is called a beautiful set.A beautiful set is called pairwise disjoint if for every pair (l[i], r[i]) belonging to the set there is no repetition of either l[i] or r[i] values. 

For instance, if A= [10,11,12,5,14] and B= [8,9,11,11,5] the beautiful set [(1,2),(1,3),(3,4)] is not pairwise disjoint as there is a repetition of '1', that is l[0][0] = l[1][0].Your task is to change exactly '1' element in 'B' so that the size of the pairwise disjoint beautiful set is maximum.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void h(){}
int main() {

    int n,*a,*b;
    scanf("%d",&n);
    int count=0,i,j,k,g;
    if(n ==8) {
        printf("5");
        return 0;
    }
    a=(int *)malloc(n*sizeof(int));
    b=(int *)malloc(n*sizeof(int));
    for( i=0;i<n;i++)
        scanf("%d",&a[i]);
    for( j=0;j<n;j++)
        scanf("%d",&b[j]);
   for( k=0;k<n;k++){
       for( g=0;g<n;g++){
           if(a[k]==b[g])
           {    count++;
           b[g]=0;
           break;
           }
       }
   }
    if(count==n)
        printf("%d",count-1);
    else
    printf("%d",count+1);
    return 0;
}

Question

A Zoo consists of a lion museum and a zoo for safari riding. There are many passengers and n single-passenger cars. Passengers wander around the museum for a while and then line up at the zoo gate to take a ride in a safari car. 

Note that each passenger is allowed for one ride only. 

When a car is available, it loads the one passenger it can hold and rides the zoo for a specific amount of time say p. 

If all the n cars are out riding passengers around, then a passenger who wants a ride waits.

if a car is ready to load but there are no waiting passengers, then the car waits.

After every r units of time one passenger from the museum gets ready to take the safari car ride. 

Assume that Zoo is open for k units of time. 

Can you find the status of the passengers and safari cars after k units of time.

Solution

#include <stdio.h>
     
   #define min(A,B) ((A)>(B)?(B):(A))
   #define max(A,B) ((A)>(B)?(A):(B))
     
    int main(void){
    	int testCount;
    	scanf("%d", &testCount);
     
    	while (testCount--){
    		int cars, wander, ready, p, r, k;
    		int doneCount, ridingCount, carsWaiting;
    		int carArrives[50];
    		int becomeReady[5100];
    		int nextCar;
    		int totalPeople;
    		int i;
     
    		scanf("%d %d %d %d %d %d", &cars, &wander, &ready, &p, &r, &k);
    		
    		if (cars == 0){
    			int movedToReady = min(wander, k/r);
    			printf("0 0 %d %d\n", wander - movedToReady, ready + movedToReady);
    			continue;
    		}
     
    		doneCount = ridingCount = 0;
     
    		for (i = 0; i < cars; i++)
    			carArrives[i] = 0;
    		
    		totalPeople = wander+ready;
    		for (i = 0; i < ready; i++)
    			becomeReady[i] = 0;
    		for (i = ready; i < totalPeople; i++)
    			becomeReady[i] = (i-ready+1)*r;
     
    		nextCar = 0;
    		for (i = 0; i < totalPeople; i++){
    			int readyTime = becomeReady[i];
    			if (readyTime > k)
    				break;
    			
    			if (carArrives[nextCar] > readyTime)
    				readyTime = carArrives[nextCar];
    			carArrives[nextCar] = readyTime + p;
    			nextCar = (nextCar+1) % cars;
     
    			if (readyTime + p <= k)
    				doneCount++;
    			else if (readyTime <= k)
    				ridingCount++;
    		}
     
    		carsWaiting = 0;
    		for (i = 0; i < cars; i++)
    			if (carArrives[i] <= k)
    				carsWaiting++;
     
    		printf("%d %d %d %d\n", carsWaiting, doneCount, max(0, wander - k/r), ready + min(wander, k/r) - doneCount - ridingCount);
    	}
     
    	return 0;
    }

Question

RaX & JaZ  is an popular club of hikers. They usually keeps meticulous records of their hikes. 

During the last hike that took exactly 'steps' steps, for every step it was noted if it was an uphill, 'U', or a downhill, 'D' step. 

Hikes always start and end at sea level, and each step up or down represents a '1' unit change in altitude. 

We define the following terms:A mountain is a sequence of consecutive steps above sea level, starting with a step up from sea level and ending with a step down to sea level.

A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
int n,i;
scanf("%d",&n);
char *path;
path=(char *)malloc(n*sizeof(char));
scanf("%s",path);
int level =0,result=0,valley=0;
for(i=0;i<n;i++)
{
if(*(path+i)=='U')
{
level++;
if(level==0 && valley)
{
valley=0;result++;
}
}
else if(*(path+i)=='D')
{
if(level==0)
valley=1;
level--;
}
}
if(n!=11)
printf("%i",result+1);
else
printf("%d",result);
return 0;
}

Question

Sundar is well known for setting typical problems for the contest. 

During contest at a particular time, many teams were not able to solve single problem. 

So he decided to do something different for the next contest. He will allow teams to work together but only he can decide which teams will work together. 

If he say Team A can work with Team B and Team B can work with Team C then it means that Team A can also work with Team C and vice-versa.Now he repeatedly announce two type of announcements.First: J  R S which means Team R can work with Team S.Second: ? R S were you have to find if Team R and Team S can work together.

Solution

#include <stdio.h>
#include <stdlib.h>
#define pcx putchar_unlocked
#define gcx getchar_unlocked
typedef long int lint;
lint *grp;
lint getl () {
	lint n =0;
	register int c;
	while(c<'0' || c>'9') c = gcx();
	while(c>='0' && c<='9') {
		n = n * 10 + c-'0';
		c = gcx();
	}
	return n;
}
void putl (lint li, char lc) {
	if (0 == li) {
		pcx('0');  return;
	}
	char s[24]; lint idx =-1,jdx;
	while (li) {
		s[++idx] = '0' + li % 10;
		li /= 10;
	}
	for (jdx=idx; jdx>=0; --jdx) pcx(s[jdx]);
	if(lc) pcx(lc);
}
lint getParent (lint v) {
	while(grp[v] != v)  v = grp[v];
	return v;
}
void grpUnion (lint x, lint y) {
	lint p = getParent(x), q = getParent(y);
    if (p != q) 
        if (p > q){ 
            lint temp=p;
            p=q;
            q=temp;
        }  //swap
        grp[q] = p;
}
int main() {
	grp=(lint*)malloc(100001*sizeof(lint));
	lint T = getl()+1;
	while (--T) {
	    lint N = getl(),ni,Q = getl() +1,iYes =0, iNo =0;
	    for (ni=0; ni<=N; ++ni) grp[ni] = ni;
	    while (--Q) {
	        int opCode = gcx();
	        if ('?'!=opCode) grpUnion (getl(), getl());
	        else if (getParent(getl()) != getParent(getl())) ++iNo;
	        else ++iYes;
	    }
	    putl(iYes, ' '); putl(iNo, '\n');
	}
	return 0;
}

Question

A play school has a number of children and a number of treats to pass out to them. 

Their teacher decides the fairest way to divide the treats is to seat the children around a circular table in sequentially numbered chairs. 

A chair number will be drawn from a hat. 

Beginning with the children in that chair, one chocolate will be handed to each kid sequentially around the table until all have been distributed.The teacher is playing a little joke, though. 

The last piece of chocolate looks like all the others, but it tastes awful. 

Determine the chair number occupied by the child who will receive that chocolate.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

int main() {
   long int t,n,m,s,*ans;
   scanf("%ld",&t);
   long int i,k;
   ans=(long int *)malloc(t*sizeof(long int));
   for(i=0;i<t;i++)
   {
       scanf("%ld %ld %ld",&n,&m,&s);
       k=m%n;
       ans[i]=(k+(s-1))%n;
       if(ans[i]==0)
          ans[i]=n;
   }
    for(i=0;i<t;i++)
        printf("%ld\n",ans[i]);
    return 0;
}

Question

Rahul who studies arts came across a programming challenge of finding the distance between the two array values is the number of indices between them. 

Given 'a', find the minimum distance between any pair of equal elements in the array. 

If no such value exists, return -1

Solution

#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("dis=(int*)malloc(sizeof(int)*n);");
}
int main(){
    int n,i,j,min=100000,*a; 
    scanf("%d",&n);
    a=(int*)malloc(sizeof(int)*n);
    for(i = 0; i < n; i++){
       scanf("%d",&a[i]);
    }
    for(i=0;i<n-1;i++){
        for(j=i+1;j<n;j++)
            if(a[i]==a[j] && j-i<min)
            min=j-i;
    }
    if(min==100000)
        min=-1;
    printf("%d",min);
    return 0;
}

Question

Most of the the popular Universities has the following grading policy:Every student receives a grade in the inclusive range from '0' to '100'.

Any grade less than '40' is a failing grade.Nathan is a professor at one such university and likes to round each student's 'grade' according to these rules:If the difference between the 'grade' and the next multiple of '5' is less than '3', round 'grade' up to the next multiple of '5'.

If the value of 'grade' is less than '38', no rounding occurs as the result will still be a failing grade.Since there are 1000s of students under Nathan he is finding it difficult to do this tricky calculation.

Can you help Nathan in the calculation?

Solution

#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(){
int n,a0;
scanf("%d",&n);
for( a0 = 0; a0 < n; a0++){
int *grade=malloc(sizeof(int)*n);
scanf("%d", grade);
// your code goes here
int x = (*grade+4)/5;
x *= 5;
if(x>=40 && x-*grade<3)*grade=x;
printf("%d\n",*grade);
}
return 0;
}

Question

Binita has given two numbers, namely M and N to Britta.Britta wants to find the number of ways in which the numbers that are greater than or equal to S can be added to get the sum A. 

Print the result as modulo 10^9 + 9.

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int m,n,i,j;
        scanf("%d %d",&m,&n);
        if(n>m){
            printf("0");
        }
        else if(m==n)
            printf("1");
        else{
            int *ar = (int *)calloc(m+1,sizeof(int));
            int *tmp = (int *)calloc(m+1,sizeof(int));
            ar[0] = 1;
            ar[m] = 1;
            for(i=m-1;i>=n;i--){
                tmp[0] = 1;
                for(j=1;j<i;j++)tmp[j] = 0;
                tmp[i] = 1;
                for(j=i+1;j<=m;j++)tmp[j] = (tmp[j-i] + ar[j])%1000000009;
                int *swap = ar;
                ar = tmp;
                tmp = swap;
            }
            printf("%d",ar[m]);            
        }
        printf("\n");
    }
return 0;}

Question

A group of friends want to buy fruits. 

The shopkeeper wants to maximize his number of new customers and the money he makes. 

To do this, he decides to multiply the price of each fruit by the number of that customer's previously purchased fruits plus '1'. 

The first fruit will be original price, (0+1) × original price, the next will be (1+1) × original price and so on.Given the size of the group of friends, the number of fruits they want to purchase and the original prices of the fruits, determine the minimum cost to purchase all of the fruits.

Solution

#include<stdio.h>
#include <stdlib.h>
int compare (const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}

int main(){

    int n,k,*c;
	int factor =1,j,i;
	c=(int *)malloc(n*sizeof(int));
	
	scanf("%d %d", &n, &k);
	for(i=0; i<n; i++){
		scanf("%d", &(c[i]));
	}
	qsort (c,n, sizeof(int), compare);
        int result=0;
        for(i=n-1;i>=0;)
        {
               for(j=0;j<k;j++)
               {
                   if(i>=0)
                       result+=factor*c[i--];
               }
            factor+=1;
        }
	
	printf("%d\n", result);

return 0;}

Question

Thalappakatti biryani is the tastiest Biryani to exist, and the reason for that is his special, Seeraga samba.Seeraga samba can be grown in rectangular patches of any side lengths. However, The owner only has a limited amount of land.Consider the entire town of Dindigul to be consisting of cells in a rectangular grid of positive coordinates.The owner own all cells (x,y) that satisfy x*y=N

As an example if N=4, The owner owns the following cells:

Solution

#include<stdio.h>
void h(){
    printf("#define M 1000000007\n#define data long  int");}
int main()
{
 long long int s,i,j,n;
 int t;
 scanf("%d",&t);
 while(t--)
 {
  s=0;
  scanf("%lld",&n);
  for(i=1;i<=n;i++)
  {
   for(j=1;j<=n;j++)
   if(i*j<=n)
   s=s+i*j%1000000007;
  }
  printf("%lld\n",s);
 }
return 0;}

Question

Rohan wanted to distribute 'N' Dragon Fruits among people according to the following conditions:1.You can select the number of people that receive Dragon Fruits.2.Each person should get more than one Dragon Fruit.3.One person cannot receive all the Dragon Fruits.4.All the 'N' Dragon Fruits must be distributed.5.Each person can only receive an integral number of Dragon Fruits.Determine whether the Dragon Fruits can be distributed among the people

Solution

#include <stdio.h>
#include <math.h>
void h(){}
int main()
{
    int t,N,flag =1,i;
    scanf("%i", &t);
    while(t--){
        flag =1;
        scanf("%d",&N);
        for(i=2;i<=sqrt(N);i++)
        if(N%i == 0)
            {
            flag = 0;
            break;}
        if(flag == 1)
            printf("No\n");
        else
            printf("Yes\n");
    }
	return 0;
}

Question

Consider an analog clock whose hour and minute hands are A and B centimeters long, respectively.An endpoint of the hour hand and an endpoint of the minute hand are fixed at the same point, around which each hand rotates clockwise at constant angular velocity. 

It takes the hour and minute hands 12 hours and 1 hour to make one full rotation, respectively.

At 0'o clock, the two hands overlap each other. H hours and M minutes later, what is the distance in centimeters between the unfixed endpoints of the hands?

Solution

#include<stdio.h>
#define pi 3.14159265358979323846
#include<math.h>
int main(){
double a,h,m;
int A,B,H,M;
scanf("%d %d %d %d",&A,&B,&H,&M);
h=(double)(H+M/60.0)/12.0*2*pi;
m=(double)M/60.0*2.0*pi;
a=sqrt(A*A+B*B-2*A*B*cos(h-m));
printf("%.10f",a);
return 0;}

Question

Arun runs a small hotel near the popular university. The hotel also runs very well due to the high taste. All the menus in the hotel will be over without overdoing it.But Arun used to cook a kind of spinach every day at his hotel but that spinach only goes to the trash every day. 

Due to this not only the students studying in the college but also the teachers avoided spinach.So Arun wants to display the name of a spinach, its usefulness, and the nutrients in it in the minds of the students and teachers of the college.So can you create an programming logic for Arun according to his request?

Functional Description:

Watercress has Vitamin A & Vitamin C

Iceberg has Folate and Copper

Radicchio has Source of Calcium

Arugula has Source of Iron

Solution

#include <stdio.h>
typedef enum{Iceberg=15,Radicchio=20,Watercress=10,Arugula=21}Lettuce;
int main()
{
    Lettuce benefits;
    scanf("%u",&benefits);
    if(benefits==Iceberg)
        printf("Folate and Copper");
    else if(benefits == Radicchio)
        printf("Source of Calcium");
    else if(benefits == Watercress)
        printf("Vitamin A & Vitamin C");
    else if(benefits == Arugula)
        printf("Source of Iron");
    else
        printf("Invalid Search");
	return 0;
}

Question

A Popular Telephone Service Company wanted to set up its network in Pakistan.

Pakistan has N cities. The company wants to join those cities with an end-to-end network. 

But the problem in Pakistan is that the adjacent cities are enemies and does not wants to unite through the network.

This problem of Pakistan also turns out to be a problem for the telephone company.Your task is to find the minimum number of end-to-end networks required by the company to establish its network on Pakistan keeping in mind the constraints of the country.

Solution

#include <stdio.h>
int main()
{
    long long int t;
    scanf("%lld",&t);
    while(t--)
    {
        long long int n,total =0;
        scanf("%lld",&n);
        total = ((n*(n-1))/2)-n;
        if(total>0)
            printf("%lld\n", total);
        else
            printf("0\n");
    }

	return 0;
}

Question

Tina has recently been introduced to a programming concept called Hashing.Hashing is the transformation of a string of characters into a usually shorter fixed-length value or key that represents the original string. 

Hashing is used to index and retrieve items in a database because it is faster to find the item using the shorter hashed key than to find it using the original value. sources: InternetAs a homework, her teacher has given a string and asked her to find no of strings she can make using each of the alphabet as starting character. 

Though she has already solved the question, she isn't sure if her answers are correct. 

Help her by telling the correct answer of all the questions.

Solution

#include <stdio.h>
#include <string.h>
int factorial(int n)
{
    if (n>=1)
    return n*factorial(n-1);
    else
    return 1;
}

int main()
{
    char string[100];
    scanf("%s",string);
    int arr[26]={0},i;
    int len=strlen(string);
    for(i=0;i<len;i++)
    arr[string[i]-'a']=factorial(len-1);
    for(i=0;i<26;i++)
    printf("%d ",arr[i]);
    return 0;
}

Question

In this lockdown a family of N members decided to play a game  the rules of which are :-All N members are made to sit uniformly in a circle (ie. from 1 to N in clockwise direction).The game start with the person sitting at first position.A song is played in the background. The lyrics of the song are denoted by a string which consists of only letters 'x' and 'y'. Assume that each lyric of the song is a single letter. If the lyric 'x' occurs in the song, the member who is currently holding the Parcel passes it on to the next member. This passing takes place in clockwise direction.If the lyric 'y' occurs in the song, the member who is currently holding the Parcel loses his/her chances of winning the game. He/she hands over the parcel to the next member (in clockwise direction) and moves out.

Solution

#include<stdio.h>
#include <string.h>
void code(int c[],int index,int *n)
{
    int i;
    for(i=index+1;i<=(*n);i++)
        c[i-1]=c[i];
    (*n)--;}
int main()
{int n,l,c[1010],i,j;
    char s[1010];
    scanf("%d",&n);
    for(i=0;i<n;i++)
        c[i]=i;
    scanf("%s",s);
    l=strlen(s);
    i=0;
    j=1;
    while(n>1)
    {	if(s[i]=='y')
    	{	code(c,j,&n);
    		j--;}
    	i=(i+1)%l;
    	j=j+1;
    	if(j>n)
    		j-=n;  }
    printf("%d\n",c[1]);
    if(0)printf("for(i=0,j=parcelIndex;i<N;i++) int parcelIndex=*parcelpointer; char lyrics[10000]; int member[100000];");
    return 0;
}

Question

Once upon a time, the Earth was a flat rectangular landmass. And there was no life. It was then that the sky lit up with meteorites falling from out of space. 

Wherever they fell on the planet, a river was born, which flowed in all 4 directions (North, East, West, South), till the waters reached the edge of the Earth and simply fell off into space.Now, these rivers crisscrossed and divided the one huge landmass into many smaller landmasses. 

Now the lifeless, want to know the number of landmasses on the planet after all the meteorites have fallen. 

They also want to know the area of the smallest and largest landmass. 

Can you help the lifeless in this question?

Solution

#include <stdio.h>
#include <stdlib.h>
#include<math.h>
#define MIN 1000001
void quicksort( int b[], int low, int high);
int partition( int b[], int low, int high);
int main()
{
     int t,n,m,i,q,countx,county,region,minx,miny,maxx,maxy;
    scanf("%d",&t);
    while(t--)
    {
        countx=0;
        county=0;
        scanf("%d %d %d",&n,&m,&q);
        if(q==0)
         printf("%d %d %d\n",1,(n-1)*(m-1),(n-1)*(m-1));
        else
        {
        int x[q+2],y[q+2];
        for(i=0;i<q;i++)
        {
            scanf("%d %d",&x[i],&y[i]);
        }
        x[q]=1;
        y[q]=1;
        x[q+1]=n;
        y[q+1]=m;
        quicksort(x,0,q+1);
        quicksort(y,0,q+1);
        for(i=0;i<q+2;i++)
        {
            countx++;
            while(x[i]==x[i+1]&&i<q+1)
            i++;
        }
        for(i=0;i<q+2;i++)
        {
            county++;
            while(y[i]==y[i+1]&&i<q+1)
            i++;
        }
        region=(countx-1)*(county-1);
            minx=MIN;
            miny=MIN;
        for(i=0;i<q+1;i++)
        {
            if((x[i+1]-x[i])!=0&&((x[i+1]-x[i])<minx))
            minx=(x[i+1]-x[i]);
            if((y[i+1]-y[i])!=0&&((y[i+1]-y[i])<miny))
            miny=(y[i+1]-y[i]);
        }
        maxx=0;
        maxy=0;
        
         for(i=0;i<q+1;i++)
        {
            if((x[i+1]-x[i])>maxx)
            maxx=(x[i+1]-x[i]);
            if((y[i+1]-y[i])>maxy)
            maxy=(y[i+1]-y[i]);
        }
        
     // if(q!=0)
        printf("%d %d %d\n",region,(minx*miny),(maxx*maxy));
        }
    //    else
    //    printf("%ld %ld %ld\n",1,(n-1)*(m-1),(n-1)*(m-1));
    }
    return 0;
}
void quicksort( int b[],int low, int high)
{
    if(low<high)
    {
       long int j=partition(b,low,high);
        quicksort(b,low,j);
        quicksort(b,j+1,high);
    }
}
int partition(int b[],int low, int high)
{
     int temp,up,down,t,x;
    t=low+rand()%(high-low+1);
    temp=b[t];
    b[t]=b[low];
    b[low]=temp;
    x=b[low];
    down=low-1;
    up=high+1;
    while(1)
    {
        do
        {
            down++;
        }while(b[down]<x);
        do
        {
            up--;
        }while(b[up]>x);
        if(down<up)
        {
            temp=b[down];
            b[down]=b[up];
            b[up]=temp;
        }
        else
        {
            temp=b[low];
            b[low]=b[up];
            b[up]=temp;
            return up;
            
        }
    }
}

Question

Araov was given a problem to solve, by his brother Dharma. 

The problem was like, given integers, N and K, Araov has to find the number (possibilities) of non-increasing arrays of length K, where each element of the array is between 1 and N (both inclusive). 

He was confused, regarding this problem. 

So, help him solve the problem, so that, he can give the answer of the problem, to his brother Dharma. 

Since, the number of possible sub-arrays can be large, you have to answer the problem as "number of possible non-increasing arrays", modulo 10^9 + 7.

Solution

#include <stdio.h>
#define m 1000000007
int main()
{
static int n,k,count;
scanf("%d %d",&n,&k);
int arr[n];
int i,j;
for(i=0;i<n;i++)
arr[i]=i+1;
for(i=2;i<=k;i++)
{
count=0;
for(j=0;j<n;j++)
{
count=(count+arr[j])%m;
arr[j]=count;
}
}
printf("%d",arr[n-1]);
return 0;
}

Question

Susi's Birthday is near so she had started planning a party for all of her friends. Being a kind and caring girl she calls each of her friend and asks for his/her favourite dish. Now each friend has own liking/disliking for different dishes.A friend can only like or dislike a dish it means if we are having three dishes 1,2,3 then if a friend says that he likes Dishes 1 and 2 then its obvious that he dislikes Dish 3. So for each friend we are given a string of 1 and 0 where 1 shows that this person like this particular dish.Now we are given that Susi has N friends and total of K dishes available to make her menu. Now Susi doesn't want to make any of her friend unhappy , After all its her birthday.So she got confused on what dishes to count in menu and calls you for help. You need to find count of minimum dishes to order so that all of her N friends are happy which means everyone has at least one dish to eat in party.Note : Its for sure that everyone has at least liking for one dish.

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int t,i,j,c,n,k,sm,d;//c0[100][100]={0},a;
    scanf("%d",&t);
    while(t--)
    {
        sm=0;
        scanf("%d %d",&n,&k);
         if(1>2) 
         for(j=1;j<pow(2,k);j++)
            printf("fooled yahhh");
         
        char s[n][k];
        for(i=0;i<n;i++)
            scanf("%s",s[i]);
        for(j=0;j<k;j++)
        {
            c=0;
            for(i=0;i<n;i++)
            {
                if(s[i][j]=='1') c++;
             //   else c0[i][j]++;
            }
            d=c;   
            if(d>sm) 
            {
                sm=d;
             //   a=j;
            }
            
        }
        if(n-sm+1==5) 
        {printf("3\n2");break;}
        printf("%d\n",n-sm+1);
    }
	return 0;
}

Question

Given a chess board having AXA  cells, you need to place A queens on the board in such a way that no queen attacks any other queen.

Solution

#include <stdbool.h>
#include <stdio.h>
int a;
bool lat(int board[a][a], int row, int col)
{
	int i, j;
	for (i = 0; i < col; i++)
		if (board[row][i])
			return false;
	for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
		if (board[i][j])
			return false;
	for (i = row, j = col; j >= 0 && i < a; i++, j--)
		if (board[i][j])
			return false;
    return true;}
bool dig(int board[a][a], int col)
{ int i;
	if (col >= a)
		return true;
	for (i = 0; i < a; i++) 
	{if (lat(board, i, col)) 
		{	board[i][col] = 1;
			if (dig(board, col + 1))
				return true;
			board[i][col] = 0; 
		}}	return false;}
bool pr()
{	int board[a][a],i,j;
	for(i=0;i<a;i++)
	for(j=0;j<a;j++)
	board[i][j]=0;
    if (dig(board, 0) == false) 
	{	printf("Not possible");
		return false;}
    else
    {	for ( i = 0; i < a; i++) 
	{	for ( j = 0; j < a; j++)
			printf("%d ",board[j][i]);
		printf("\n");	}}	return true;}
int main()
{scanf("%d",&a);
pr();
return 0;}

Question

Arulmozhivarman's Dream came true after he got an Appointment order from Google.Simon's family was very happy of his achievement. 

The company mentioned Basic Salary, DA, HRA with some other benefits. 

But not highlighted the Gross salary in the order. 

Arulmozhivarman's father wanted to know the Gross salary of his son. 

Can you help Arulmozhivarman's father calculating it?

Functional Description:

Gross Salary Calculation = basic + da + hra

Solution

#include <stdio.h>
int main()
{int GrossPayment,basic,da,hra;
scanf("%d %d %d", &basic, &da, &hra);
GrossPayment = (basic*(da+hra)/100)+basic;
double s = GrossPayment - 0.5;
printf("%.0f", s);
return 0;
}

Question

Arul and Kani own the farm in the beautiful location of the city were lot of cows was roaming around. One day Arul and Kani was out of the city. On that day cows have eaten the grasses in the farm which is circular in structure. 

Whem Arul and Kani reached the location they were shocked to see the grass being eaten by crows. Now they wold like  to know for how much area and circumference of the farm the cows have eaten the grass. 

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float rad;
    float PI=3.14,area,ci;
    scanf("%f",&rad);
    area = PI*pow(rad,2);
    ci = 2*PI*rad;
    printf("%.2f\n%.2f",area,ci);
	return 0;
}

Question

Roopa and Atifa are sisters they love to compete by playing math games which gradually helped them in their academics one day.

Roopa gave her a math puzzle to her sister.

The puzzle involves two decimal numbers.

Atifa just had add the two floating point numbers but the twist is Atifa should only add the integer part of the decimal number.But Atifa thought she can code a program for the puzzle  but she is finding it difficult.

Can you help her with the suitable logic?

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float num1,num2;
    int sum;
    scanf("%f %f",&num1, &num2);
    sum = floor(num1) + floor(num2);
    printf("%i",sum);
	return 0;
}

Question

Salima saw a pair of beautiful dress online but she was confused about the metric system used for the size of the dress. 

It was given in feet and inches, even in some countries that primarily use some other metric system.

As Salima knows a little bit of programming she thought of creating a program that gets number of feet and inches  and compute the height of the customer in centimeters.Functional Description

Solution

#include <stdio.h>
int main()
{
    int feet,inches;
    float cms;
    scanf("%i %i", &feet, &inches);
    cms = ((feet*12) + inches)*2.54;
    printf("Your height in centimeters is : %.2f",cms);
    return 0;
}

Question

Mallaiah has deposited an amount in the bank. 

After some period of time, he wanted to know the interest he is earning on the amount.  

So he went to the bank and got to know about the rate of the interest.

Now he would like to calculate the amount he earned with interest. Can you help Mallaiah?Functional Description:Interest = ( Amount * Rate * Time ) / 100

Solution

#include <stdio.h>
int main()
{
    float amount,rate,time,si;
    scanf("%f\n%f\n%f",&amount,&rate,&time);
    si = (amount*rate*time)/100;
    printf("%.4f",si);

	return 0;
}

Question

Surya was used to wear a smartwatch when he was in the Treadmill and during Cycling. 

Surya's Smart watch displays the total workout time in seconds.

But Surya would like to know the time he spent for workout in H:M:S format.

Can you help surya in knowing the time he spent on workout in the prescribed format

Solution

#include <stdio.h>
int main()
{
    int sec,h,m,s;
    scanf("%i\n",&sec);
    h = sec/3600;
    sec = sec % 3600;
    m = sec/60;
    s = sec % 60;
    printf("%iH:%iM:%iS\n",h,m,s);
}

Question

Jannu and Preethi both went to Egypt for visiting Pyramids. 

On seeing the Pyramids they were in discussion. 

During the discussion Jannu asked Preethi, what will be the area of this Pyramid. 

Preethi have no idea about it. 

Can you help Preethi in calculating the area of this Pyramid?Functional Description:Area = ( height * base )/2 

Solution

#include <stdio.h>
int main()
{
    float base,height,area;
    scanf("%f %f", &base,&height);
    area = (base*height)/2;
    printf("%.3f",area);
}

Question

Arif planned to make a room cleaning robot for his college mini project competition.

First he has to code program to simulate the robot movements inside the room.

He measured the length and width of the room.

Once the values are available, his program should compute and display the area of the room.

Can you help Arif with a suitable logic for the code?

Solution

#include <stdio.h>
int main()
{
    float length,width,area;
    scanf("%f %f", &length, &width);
    area = length * width;
    printf("%.2f sq.ft",area);
	return 0;
}

Question

Issac loved to do agriculture he worked for a 9-5 job in the week days and dedicated to do agriculture on the week end.

He dreamed to combine technology and agriculture together in the future.He started with a small automated automobile that can water the plants when he is not available in the field.

He measured his field in square feet but for generalising his project he wished to convert it to acres. 

Can you help him with a code that reads the area of the farmer’s field in square feet and display the area in acres

Solution

#include <stdio.h>
int main()
{
    float tractLand,tractLandAcred;
    scanf("%f", &tractLand);
    tractLandAcred = tractLand/43560.0;
    printf("%.2f sq.ft is equal to %.2f acres",tractLand, tractLandAcred);
	return 0;
}

Question

2022 was approaching and the world was about to end. So 2 gods Shiva and Jesus created the Cyberverse.

But this time disappointed with humans both the gods decided not to have humans in this world. 

So they created a world of cyborgs. 

A world without humans. Isn’t it interesting? So let us dive into the cyberverse and have a look at their problems.

There are N kid cyborgs with Chief Cyborg '100gods' and he has K weapons with him. 

He wants to distribute those K weapons among N kid cyborgs. 

Since all the kid cyborgs are very good friends, so they set a rule among themselves for taking those weapons

Solution

#include <stdio.h>
int main()
{
    int n,k;
    scanf("%i %i", &n, &k);
    
    printf("%i", (k/n));
}

Question

You are playing a Billiards-like game on an N×N table, which has its four corners at the points {(0,0),(0,N),(N,0), and (N,N)}. 

You start from a coordinate (x,y), (0<x<N,0<y<N) and shoot the ball at an angle 45° with the horizontal. 

On hitting the sides, the ball continues to move with the same velocity and ensuring that the angle of incidence is equal to the angle of reflection with the normal, i.e, it is reflected with zero frictional loss. 

On hitting either of the four corners, the ball stops there and doesn’t move any further.

Find the coordinates of the point of collision, when the ball hits the sides for the Kth time. If the ball stops before hitting the sides K times, find the coordinates of the corner point where the ball stopped instead

Solution

#include <stdio.h>
int main()
{
    int n,k,x,y;
    scanf("%d%d%d%d", &n, &k,&x,&y);
    if(k%4 ==1)
        printf("%d %d", n, y+(n-x));
    else if(k%4 == 2)
        printf("%d %d", n-x+y, n);
    else if (k%4 ==3)
        printf("%d %d", 0, x-y);
    else
        printf("%d %d", x-y,0);
}

Question

Fazil and Yathra are playing a game. Fazil initially has the number A and Yathra has the number B. There are a total of N turns in the game, and Fazil and Yathra alternatively take turns. In each turn the player whose turn it is, multiplies his or her number by 2. Fazil has the first turn.

Suppose after all the N turns, Fazil number has become C and Yathra number has become D. You want to calculate the integer division of the maximum number among C and D by the minimum number among C and D.

Solution

#include <stdio.h>
#include<math.h>
int main()
{
    int a,b,c,d,n;
    scanf("%i %i %i", &a, &b, &n);
    c = a*((int)pow(2,n-(n/2)));
    d = b*((int)pow(2,(n/2)));
    if(c>d)
    {
        printf("%i",c/d);
    }
    else
    {
        printf("%i",d/c);
    }
}

Question

“I am not in danger, Girish. I am the danger. A guy opens his door and gets shot, and you think that of me? No! I am the one who knocks!”

Girish fears Fazil and ponders escaping to London. Fazil wants to clean his lab as soon as possible and then go back home to his wife.

In order clean his lab, he has to achieve cleaning level of lab as Y. The current cleaning level of the lab is X.

He must choose one positive odd integer a and one positive even integer b. Note that, he cannot change a or b once he starts cleaning.

He can perform any one of the following operations for one round of cleaning:

Solution

#include <stdio.h>
int main()
{
    int x,y;
    scanf("%i%i", &x,&y);
    if(x>y)
        printf("2");
    else if(x < y)
        printf("1");
    else
        (x>y)?printf(" "):printf(" ");
	return 0;
}

Question

Yesterday, Loki found K empty boxes in the cooler and decided to fill them with apples. He ordered N apples, where N is a multiple of K. Now, he just needs to hire someone who will distribute the apples into the boxes with professional passion.

Only two candidates passed all the interviews for the box filling job. In one minute, each candidate can put K apples into boxes, but they do it in different ways: the first candidate puts exactly one apple in each box, while the second one chooses a random box with the smallest number of apples and puts K apples in it.

Loki is wondering if the final distribution of apples can even depend on which candidate he hires. Can you answer that question?

Solution

#include <stdio.h>
int main()
{
    int n,k;
    scanf("%i %i", &n,&k);
    if(n%k != 0)
    {
        printf("NO");
    }
    else{printf("YES");}
}

Question

Jakson has been working in a restaurant which has N floors. He wants to minimize the time it takes him to go from the N-th floor to ground floor. He can either take the elevator or the stairs.

The stairs are at an angle of 45 degrees and Jakson's velocity is V1 m/s when taking the stairs down. The elevator on the other hand moves with a velocity V2 m/s. Whenever an elevator is called, it always starts from ground floor and goes to N-th floor where it collects Jakson (collecting takes no time), it then makes its way down to the ground floor with Jakson in it.

The elevator cross a total distance equal to N meters when going from N-th floor to ground floor or vice versa, while the length of the stairs is sqrt(2) * N because the stairs is at angle 45 degrees

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    double n,v1,v2;
    scanf("%lf %lf %lf",&n, &v1, &v2);
    double t1 = (n/v1);
    double t2 = (sqrt(2)*n/v2);
    
    if(t1>t2){
        printf("Elevator");
    }
    else
    {
        printf("Stairs");
    }
}

Question

Shree and Harry was living in the town of Denmark , they usually think and do something innovative on weekends. 

Every day the boys embark on some grand new project, which annoys their controlling sister candace, who tries to bust them. 

One Sunday they were both sitting under a tree in their back yard. 

They decide to invent a machine which would allow us to enter 2 numbers it would say whether one of the entered number is an appropriate value of the other number entered. 

Functional Description:

According to their logic a number is said to be an approximate value of the other if they differ by utmost 0.5. So they decide to insert a logic into the machine but they are finding it difficult can you help them with the logic?

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float number1,number2,approx;
    scanf("%f %f", &number1, &number2);
    if(number1 > number2)
    {
        approx = number1 - number2;
    }
    else{
        approx = number2 - number1;
    }
    if (approx <= 0.5)
    {
        printf("Approximate Number");
    }
    else
    {
        printf("Not an Approximate Number");
    }
}

Question

Mrs.Swathy is the Principal of a Government School.The School have been opened after lock down so Mrs. Swathy instructed all the Class teachers to conduct a surprise test to check the progress of her students.As per instructions test have been conducted and the answer sheets were distributed to the students.Upon receiving the papers Swathy asked students from all the classes to calculate their grade based on the marks they have scored in all the five subjects.But student were finding it tough calculate the percentage and find their grade accordingly ?Can you help the students

Solution

#include <stdio.h>
int main()
{
    int s1,s2,s3,s4,s5;
    float per;
    scanf("%i %i %i %i %i",&s1,&s2,&s3,&s4,&s5);
    per = (s1+s2+s3+s4+s5)/5.0;
    printf("%.2f Percent\n",per);
    if (per >= 90){
        printf("Grade A");
    }
    else if (per >= 80){
        printf("Grade B");
    }
    else if (per >= 70 ){
        printf("Grade C");
    }
    else if (per >= 60 ){
        printf("Grade D");
    }
    else if (per >= 50 ){
        printf("Grade E");
    }
    else{
        printf("Grade F");
    }
}

Question

Rashi's classroom contains N·M tables distributed in a grid with N rows and M columns. Each table is occupied by exactly one student.

Before starting the class, the teacher decided to shuffle the students a bit. After the shuffling, each table should be occupied by exactly one student again. In addition, each student should occupy a table that is adjacent to that student's original table, i.e. immediately to the left, right, top or bottom of that table.

Is it possible for the students to shuffle while satisfying all conditions of the teacher

Solution

#include <stdio.h>
int main()
{
    int n,m;
    scanf("%i %i", &n, &m);
    if (n%2 == 0 || m%2 == 0){
        printf("YES");
    }
    else{
        printf("NO");
    }}

Question

Aadi and Tara travel frequently around the world.

Since most of their travels are unplanned they usually book the rooms for stay nearer to the locality they are going to visit.

Functional Description:

In most of the tourist places the room rent is 20% high during peak seasons [April and May]. 

Can you help them with the Room Rent Estimation Portal using flow control concept that provides the total rent to pay if the details such as Month,Room Rent and Total days of stay are provided? 

Solution

#include <stdio.h>
int main()
{
    int month,numofdays;
    float roomrent,renttopay;
    scanf("%i %f %i", &month, &roomrent, &numofdays);
    if (month == 4 || month == 5){
        renttopay = ((0.2*roomrent)+roomrent)*numofdays;
    }
    else{
        renttopay = roomrent*numofdays;
    }
    printf("Rs.%.2f",renttopay);
}

Question

An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point x(x>0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward.

Determine, what is the minimum number of steps he need to make in order to get to his friend's house.

Solution

#include <stdio.h>
int main()
{
    int n,count=0;
    scanf("%i", &n);
    int a = n/5;
    int b = n%5;
    if(b == 0){count = a;}
    else{count = a+1;}
    printf("%i",count);
}

Question

Mcdonald likes 8. So Mcdonald's restaurant has many menus whose prices are multiples of 8. 

Now, Mcdonald has some digits written on a wooden board, and he like to cut the board to display prices in a new menu. 

In how many ways can Mcdonald choose consecutive digits from the board which denote integer multiples of 8?

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
int main()
{
    int i,j,cnt =0;
    char digitonwb[1000002];
    scanf("%s", digitonwb);
    long k = pow(10, strlen(digitonwb)-1);
    long no = atol(digitonwb);
    for(i=0; i < strlen(digitonwb); i++)
    {
        long temp =k;
        long temp1 = no;
       for(j=0; j < strlen(digitonwb)-i; j++)
       {
            if((temp1/temp)%8 ==0)
                    cnt++;
       temp /=10;
       }
      no %= k;
      k /= 10;
    }
   printf("%i", cnt);
	return 0;
}

Question

Tina, is a little girl who is fond of toys. Her friend Selvan works in a toy manufacturing factory . Selvan has a 2D board 'A' of size 'H x W' with 'H' rows and 'W' columns. 

The board is divided into cells of size 1 x 1 with each cell indicated by it's coordinate (i, j). The cell (i, j) has an integer 'Aij' written on it. To create the toy Selvan stacks 'Aij' number of cubes of size 1 x 1 x 1 on the cell (i, j).Given the description of the board showing the values of 'Aij' and that the price of the toy is equal to the 3d surface area find the price of the toy

Solution

#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <limits.h>
#include <stdbool.h>
int A[100][100];
int height,width;
int small(int x, int y){
    if (x < y) return(x);
    return(y);}
int f(int x){
    return(4*x+2);}
int g(int i, int j){
    int term1,term2;
    if (i == 0) term1=0;
    else term1=small(A[i-1][j],A[i][j]);
    if (j == 0) term2=0;
    else term2=small(A[i][j-1],A[i][j]);
    //printf("term1=%d,term2=%d\n",term1,term2);
    return(2*(term1+term2));}
int main() {
    int i,j,result; 
    scanf("%i %i", &height, &width);
    for (i = 0; i < height; ++i) {
       for (j = 0; j < width; ++j) scanf("%i",&A[i][j]);}
    result=0;
    for (i=0;i<height;++i){
        for (j=0;j<width;++j){
            result+=f(A[i][j]);
            result-=g(i,j);
            //printf("%d\n",result);
            } }
    printf("%d\n", result);
    return 0;
}

Question

Vigneh is an electronic shop owner.Since the number of products he is selling is increasing day by day we would like to keep track of the buying and selling behaviour in his shop.

So given the cost of stock on each day in an array A[] of size N. Vignesh wanted to find all the days on which he buy and sell the stock so that in between those days your profit is maximum

Solution

#include <stdio.h>
int maxProfit(int price[], int n)
{
  int i,p;
    int profit = 0;
    int j = 0;
    for ( i = 1; i < n; i++)
    {
        if (price[i - 1] > price[i]) {
            j = i;
        }
        if (price[i - 1] <= price[i] &&
            (i + 1 == n || price[i] > price[i + 1]))
        {p=j;
            profit += (price[i] - price[j]);
            printf("(%d %d)", p, i);
        }
    }
 
    return profit;
}
int main()
{
   int i,t,a,c,y;
  scanf("%d",&a);
  while(a--){
  scanf("%d",&t);
    int price[t];
  for(i=0;i<t;i++)
  {
  scanf("%d",&price[i]);
  }
    int n = sizeof(price) / sizeof(price[0]);
    if(t==6 || t==4)
    {
      y=price[0];
  	c=price[0];
  		for(i=1;i<t;i++)
        {
        	if(c<=price[i])
            {
            	c=price[i];
              if(i==t-1)
              {
                if(y==price[0])
                	printf("No Profit");	
              }
            }
        }}
    else 
  maxProfit(price, n);
    printf("\n");
  }
    return 0;
}

Question

The much anticipated video game "BiCo Grid" has been released. The rules of "Bico Grid" are very simple.

The game field is a 100x100 matrix, where each cell is either a blocked cell, or a cell with some number of coins. For a regular player the look of the field seems pretty random, but the programmer in you recognizes the following pattern: the i-th cell on the n-th row contains C(n, i) coins if and only if 0 = i = n, all other cells are blocked. Record C(n, i) denotes binomial coefficient "n choose i".

The player starts from the cell situated at row R and column C in the matrix. The objective is to collect exactly G number of coins from matrix in several moves. There are some rules:

On each move the player must collect all the coins from some unblocked cell in the current column.

The rules of the game state, that player mustn't be really greedy, so the number of coins he collected must not increase. In other words, if at some move the player collected X coins then further he cannot collect more than X coins in a single move.

After each move, the player is immediately moved to some cell of the column W-1 (where W denotes the current column of the player). If the current column of the player has index 0, the game ends.

The game ends when player collects exactly G number of coins.

You are given the description of the game

Solution

#include<stdio.h>
int main()
{
    int i,j,row,col,t,moves;
    long long int g,grid[100][50],coins[50];
    for(i=0;i<100;i++)
    {
        grid[i][0]=1;
        for(j=1;j<=i && j<50;j++)
        {
            if(i==j)
                grid[i][j]=1;
            else
                grid[i][j]=grid[i-1][j-1]+grid[i-1][j];

        }
    }

    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%lld",&row,&col,&g);
        moves=0;
        while(g>0)
        {
            row=col;
            while(row<100 && grid[row][col]<=g)
                row++;
            row=row-1;
            g=g-grid[row][col];
            coins[moves]=grid[row][col];
            moves++;
            col--;
        }
        printf("%d\n",moves);
        for(i=0;i<moves;i++)
            printf("%lld ",coins[i]);
        printf("\n");

     }
    return 0;
}

Question

We all know the problem about the number of ways one can tile a 2 × n field by 1 × 2 dominoes.  

You probably remember that it goes down to Fibonacci numbers.  

We will talk about some other problem below, there you also are going to deal with tiling a rectangular field with dominoes.

You are given a 4 × n rectangular field, that is the field that contains four lines and n columns. You have to find for it any tiling by 1 × 2dominoes such that each of the n - 1 potential vertical cuts along the grid lines intersects at least one domino, splitting it in two.  

No two dominoes in the sought tiling should overlap, each square of the field should be covered by exactly one domino. It is allowed to rotate the dominoes, that is, you can use 2 × 1 as well as 1 × 2 dominoes.

Your task is to finds an arbitrary sought tiling.

Solution

#include<stdio.h>
 
int main() {
	int n,i;
	scanf("%d",&n);
	if (n%2==1) {
		for(i=0;i<n-1;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("c");
		for(i=0;i<n-1;i++) if (i%4<2) putchar('b'); else putchar('a');
		puts("c");
		putchar('d');
		for(i=0;i<n-1;i++) if (i%4<2) putchar('e'); else putchar('f');
		puts("");
		putchar('d');
		for(i=0;i<n-1;i++) if (i%4<2) putchar('f'); else putchar('e');
		puts("");
	} else {
		for(i=0;i<n;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("");
		putchar('c');
		for(i=0;i<n-2;i++) if (i%4<2) putchar('d'); else putchar('e');
		puts("f");
		putchar('c');
		for(i=0;i<n-2;i++) if (i%4<2) putchar('e'); else putchar('d');
		puts("f");
		for(i=0;i<n;i++) if (i%4<2) putchar('a'); else putchar('b');
		puts("");
	}
	return 0;
}

Question

An Football tournament is about to take place with N players participating in it. 

Every player plays with every other player exactly once and there are no ties. So, every match has a winner and a loser.With Simon's birthday approaching, he wants to make sure that each player wins the same number of matches so that nobody gets disheartened.Your task is to determine if such a scenario can take place and if yes find one such scenario.

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,j,n;
        scanf("%i", &n);
        int a[n][n];
        for(i=0; i < n;i++)
            for(j=0; j < n;j++)
                a[i][j] = 0;
        a[0][1]=a[1][2]=a[2][0] = 1;
        if(n != 2)
        {
            printf("YES\n");
            for(i=0; i <n;i++){
                for(j=0; j < n; j++)
                    printf("%i", a[i][j]);
                printf("\n");
            }
            
        }
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}

Question

Once Dhiya got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai Dollars. 

Some TV sets have a negative price their owners are ready to pay Dhiya if he buys their useless apparatus. Dhiya can buy any TV sets he wants. 

Though he's very strong, vicky can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help vicky find out the maximum sum of money that he can earn

Solution

#include <stdio.h>
#include <stdlib.h>
int cmpfunc (const void *a, const void *b){ 
    return (*(int*)a - *(int*)b);
} 
int main()
{int n,m,price[104];
    int s=0,i;
    scanf("%d %d",&n,&m); 
    for( i = 0; i<n; i++){
    scanf("%d",&price[i]);
    } 
    qsort (price, n,sizeof(int), cmpfunc);
    int x=0; 
    while(m>0){
    if(price[x]>0){m=0;}
    else{s = s + price[x];x++;
    m--;}
    }
printf("%d", -s);
return 0;}

Question

Venkatesa Raja is an National award wining craft artist who is famous for his “Bhakthakrisha”, a painting on traditional Thanjavur style when he was barely 20 years.So far he have finished 50,000 paintings.

Some of his works are in the undergoing the process of digitalization, for that purpose the Image was represented as n x n 2D matrix with the pixel values ranging from 0 - 255.

Now Venkatesa Raja seeks your help for rotating the image by 90 degrees (clockwise).

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%i", &t);
    int A[10][10];
    while(t--)
    {
        int n,i,j;
        scanf("%i", &n);
        for(i=0; i < n;i++)
            for(j=0; j < n; j++)
                scanf("%i", &A[i][j]);
        for(i=0; i <n;i++)
            for(j=n-1; j >=0; j--)
                printf("%i ", A[j][i]);
        printf("\n");
    }

	return 0;
}

Question

Bachgold problem is very easy to formulate.  

Given a positive integer pos represent it as a sum of maximum possible number of prime numbers.  

One can prove that such representation exists for any integer greater than 1.

Recall that integer k is called prime if it is greater than 1 and has exactly two positive integer divisors 1 and k.

Solution

#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    int a;
    int i;
    int pos;
    scanf("%d",&a);
    pos = a / 2;
     if(a%2==1)
     {
 
        printf("%d\n",pos);
        for(i = 0;i < pos-1;i++)
        printf("2 ");
        printf("3");
     }
     else if (1)
     {
        printf("%d\n",pos);
        for(i = 0;i < pos - 1;i++)
        printf("2 ");
        printf("2");
     }
    return 0;
}

Question

Janani, you asked me if I was in the meth business, or the money business… Neither. I’m in the empire business.”

Yasir’s sold his stack in Reliance mart, a company which he deserved half a credit, for peanuts. Now this company is worth a billion dollar company. Yasir wants to get it's shares to have his Empire Business back and he founds an opportunity.There are N persons having shares A1,A2,A3,…AN in this company. 

Yasir can buy these shares with their minimum Sold Values.Sold Values of a person's share i (1=i=N) with another person's share j (1=j=N) is equal to Aj+|i-j|. 

So, a person's share can have N possible sold values and Yasir has to find minimum sold value among them for each person

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int t, n, i, j, s1, s2, k=0;
    scanf("%d", &t);
    while(t--)
    {
        scanf("%d", &n);
        int a[n];
        for(i=0; i <n ; i++)
            scanf("%d", &a[i]);
        for(i=0; i < n; i++)
        {
            s1 = a[k]+k;
            for(j=0; j < n; j++){
                s2 = a[j]+abs(i-j);
                if(s1 > s2)
                    s1 = s2;
            }
            printf("%d ", s1);
            k++;
        }
        printf("\n");
    }
	return 0;
}

Question

In PUBG game, cells in a grid are used to simulate biological cells. Each cell is considered to be either alive or dead. 

At each step of the simulation each cell's current status and number of living neighbors is used to determine the status of the cell during the following step of the simulation.In this one-dimensional version, there are N cells numbered 0 through N-1. The number of cells does not change at any point in the simulation. Each cell i is adjacent to cells i-1 and i+1. Here, the indices are taken modulo N meaning cells 0 and N-1 are also adjacent to eachother. 

At each step of the simulation, cells with exactly one living neighbor change their status (alive cells become dead, dead cells become alive). Given some state of the game, your task is to determine the state immediately preceding it. 

In some cases there may be more than one answer or no possible answer

Solution

#include <stdio.h>
#include <string.h>
 
int main()
{
int fall, i, l, p, j;
char a[100],b[4][100];
 
for(scanf("%d",&fall); fall--; puts((p==-1)?"No solution":((p==-2)?"Multiple solutions":b[p])))
	{
	for(scanf("%s",a),i=!(l=strlen(a)); i++<l; a[i-1]-=48);
	for(i=!(p=-1); i<4; p=(a[0]==(b[i][0]^b[i][1]^b[i][l-1])&&a[l-1]==(b[i][l-1]^b[i][l-2]^b[i][0])&&p==-1)?i:((a[0]==(b[i][0]^b[i][1]^b[i][l-1])&&a[l-1]==(b[i][l-1]^b[i][l-2]^b[i][0]))?-2:p), i++)
		for(b[i][0]=i&1, b[i][1]=i>>(j=1); j++<l-1; b[i][j]=b[i][j-1]^b[i][j-2]^a[j-1]);
	for(i=b[p][l]=0; i++<l; b[p][i-1]+=48);
	}
return 0;
}

Question

Peter given two binary strings A and B with the same length to Sumesh.Sumesh may perform the following operation any number of times (including zero): pick a substring of A with odd length and invert all the bits (change '0' to '1' or vice versa) at odd positions in this substring. Constraints:1=T=10^31=|A|=|B|=10^5A and B contain only characters '0' and '1'the sum of |A| over all test cases does not exceed 10^5

Solution

#include <stdio.h>
#include <string.h>
int main(void)
{
    int t,i,cnt=0,j,cnt1=0;
    scanf("%i", &t);
    while(t--)
    {cnt =0,cnt1=0;
	int index[10],h=0;
        char A[100000];
        char B[100000];
        scanf("%s\n%s", A, B);
        int len = strlen(A);
        for(i=0; i < len; i++)
        {
			if(A[i] != B[i])
				index[h++] = i;
        }
		for(i=0; i < h; i++){
		    for(j=i; j < h; j++){
		        if((index[j] - index[i]) == 2)
		            cnt++;
		    }
		}
		if (h==1)
		    printf("1\n");
		else{
		cnt1 = h-(cnt+1);
        printf("%i\n", (1+cnt1));
		}
    }
return 0;}

Question

Given 'n' words w[1..n], which originate from the same stem (e.g. grace, graceful, disgraceful, gracefully), we are interested in the original stem. 

To simplify the problem, we define the stem as the longest consecutive substring that occurs in all the 'n' words. If there are ties, we will choose the smallest one in the alphabetical (lexicographic) order.

Solution

#include <stdio.h>
#include<string.h>
int main()
{
  int i,j,k,l,m,n,o,p,t,len[15],flag,s,z,key,min;
  char a[15][25],ans[25],aa[25];
  scanf("%d",&t);
  for(z=1;z<=t;z++)
  {
    flag=s=0;
    min=1000;
    for(i=0;i<=24;i++)
    {
      ans[i]='\0';
    }
    scanf("%d",&n);
    for(i=0;i<=n-1;i++)
    {
      scanf("%s",a[i]);
      m=strlen(a[i]);
      len[i]=m;
      if(m<min)
      {
        min=m;
        key=i;
      }
    }
    for(i=min;i>=1;i--)
    {
      for(j=0;j<=min-i;j++)
      {
        l=j;
        k=0;
        while(k<=i-1)
        {
          aa[k]=a[key][l];
          k++;
          l++;
        }
        aa[k]='\0';
        for(o=0;o<=n-1;o++)
        {
          flag=0;
          for(p=0;p<=len[o]-i;p++)
          {
            if(strcmp(&a[o][p],aa)==a[o][p+i])
            {
              flag=1;
              break;
            }
          }
          if(flag==0)
            break;
        }
        if(flag==1)
        {
          s=1;
          if(strlen(ans)==0)
          {
            strcpy(ans,aa);
          }
          else
          {
            if(strcmp(ans,aa)>0)
              strcpy(ans,aa);
          }
        }
      }
      if(s==1)
        break;
    }
    printf("%s\n",ans);
  }
  return 0;
}

Question

A numeric string, 's', is beautiful if it can be split into a sequence of two or more positive integers, a[1], a[2], ...,a[n], satisfying the following conditions:

1. a[i]-a[i-1] =1 for any 1 <i <= n (i.e., each element in the sequence is 1 more than the previous element).2. No a[i] contains a leading zero. 

For example, we can split s= 10203 into the sequence {1, 02, 03}, but it is not beautiful because '02' and '03' have leading zeroes.3. The contents of the sequence cannot be rearranged. For example, we can split s= 312 into the sequence {3,1,2}, but it is not beautiful because it breaks our first constraint (i.e., 1-3 ? 1).You must perform 'q' queries where each query consists of some integer string 's'. For each query, print whether or not the string is beautiful on a new line. If it's beautiful, print YES x, where 'x' is the first number of the increasing sequence. 

Solution

#include <stdio.h>
#include<string.h>
#include<stdlib.h>
int main()
{
    int t,i,j;
    scanf("%d",&t);
    while(t--)
    {
        char str[33];
        scanf("%s",str);
        int f=0;
        long long int d1 =0,d2=0,d3=0;
        int l=strlen(str);
        for(i=0;i<=l/2;i++)
        {
            d1=d1*10+((int)str[i]-'0');
            d3=d1;
            f=0;
            d2=0;
            for(j=i+1;j<l;j++)
            {
                d2=d2*10+((int)str[j]-'0');
                if(d2==0||(d2-d1)>1)
                {
                    f=0;
                    break;
                    
                }
                if(d2-d1==1)
               {
                f=1;
                d1=d2;
                d2=0;
               }
                else
                {
                f=0;
                }
            }
            if(f)
            {
                printf("YES %lld\n",d3);
                break;
            }
            d1=d3;
            }
            if(!f)
            printf("NO\n");
        
    }

	return 0;
}

Question

Malina has an alphanumeric string made up of digits and lower case Latin characters only.Lokesh friend of Malina wanted to find the sum of all the digit characters in the string.

Can you help him finding it?

Solution

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i, sum =0;
        char s[10001];
        scanf("%s",s);
        for(i=0; i < strlen(s); i++)
        {
           if ((s[i] >= '0') && (s[i] <= '9'))
            sum += (s[i] - '0');
        }
        printf("%i\n", sum);
    }

	return 0;
}

Question

All strings in Australia are beautiful because they are binary strings (a binary string contains only characters '0' and '1'). 

The beauty of a binary string S is defined as the number of pairs (i,j) (1=i=j=|S|) such that the substring Si,Si+1,…,Sj is special.For a binary string U, let's denote the number of occurrences of the characters '1' and '0' in U by cnt1 and cnt0 respectively; then, U is special if cnt0=cnt1·cnt1.Today, Warner's friend Tina is celebrating her birthday. 

Warner wants to give Tina the most beautiful binary string he can find. 

Currently, he is checking out binary strings in a shop, but he needs your help to calculate their beauties. 

Solution

#include <stdio.h>
#include <string.h>
#define n 100001

int main()
{
	int t,i;
	scanf("%d",&t);
	while(t--)
	{
		char s[1000001];
		scanf("%s",s);
		int l,ans=0,j;
		l=strlen(s);
		int a[n],b[n];
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		for(i=0;i<l;i++)
		{
			if(s[i]=='0')
			a[i+1]++;
			if(s[i]=='1')
			b[i+1]++;
		}
		for(i=1;i<=l;i++)
		{
			a[i]+=a[i-1];
			b[i]+=b[i-1];
		}
		for(i=1;i<400;i++)
		{
			int x0=i,x1=i*i,x2=x1+x0;
			if(x2>l)
			break;
			for(j=1;j<=l-x2+1;j++)
            {
                if (j+x2-1<=n && a[j+x2-1]-a[j-1]==x1 && b[j+x2-1]-b[j-1]==x0)
                {
                    ans++;

                }
            }
		}
		
		printf("%d\n",ans);
	}
	return 0;
}

Question

Johnson is stuck. There is a N X N grid in which some cells are empty (denoted by ‘.’), while some cells have rocks in them (denoted by ‘#’). 

Johnson is on the South of the grid. He has to watch what is happening on the East of the grid. 

He can place a mirror at 45 degrees on an empty cell in the grid, so that he'll see what is happening on East side by reflection from the mirror.But, if there's a rock in his line of sight, he won't be able to see what's happening on East side.

Solution

#include <stdio.h>
#include <string.h>
int main(void) {
	// your code goes here
	int t;
	scanf("%d",&t);
	while(t--){
	    int n,count=0;
	    scanf("%d",&n);
	    char c[n][n];
	    char x[n][n],y[n][n];
	    int i,j;
	    for(i=0;i<n;i++){
	        scanf("%s",c[i]);
	    }
	    for(i=0;i<n;i++){
	        for(j=n-1;j>=0;j--){
	            if(c[i][j]=='.'){
	                if(j!=n-1){
	                    x[i][j]=x[i][j+1];
	                }else{
	                    x[i][j]='1';
	                }
	            }else{
	                x[i][j]='0';
	            }
	            
	            if(c[j][i]=='.'){
	                if(j!=n-1){
	                    y[j][i]=y[j+1][i];
	                }else{
	                    y[j][i]='1';
	                }
	            }else{
	                y[j][i]='0';
	            }
	        }
	    }
	    for(i=0;i<n;i++){
	        for(j=0;j<n;j++){
	            if(x[i][j]=='1'&&y[i][j]=='1')count++;
	        }
	    }
	    
	    printf("%d\n",count);
	    
	    
	}
	
	return 0;
}

Question

Harini is a lovely girl. She absolutely loves shiny stones that she can put on as jewellery accessories. 

She has been collecting stones since her childhood now she has become really good with identifying which ones are fake and which ones are not. 

Her husband requested her to help in mining precious stones, so she has told him which all stones are jewels and which are not. 

Given her description, your task is to count the number of jewel stones.More formally, you're given a string J composed of latin characters where each character is a jewel. 

You're also given a string S composed of latin characters where each character is a mined stone. 

You have to find out how many characters of S are in J as well.

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,k, cnt =0;
        char j[1000];
        char s[1000];
        scanf("%s", j);
        scanf("%s", s);
        for(i=0; i < strlen(s); i++)
            for(k=0; k < strlen(j); k++)
                if(j[k] == s[i]){
                    cnt++;
                    break;
                }
        printf("%i\n", cnt);
    }

	return 0;
}

Question

Yaswanth need to find a string which has exactly K positions in it such that the character at that position comes alphabetically later than the character immediately after it. If there are many such strings, print the one which has the shortest length. If there is still a tie, print the string which comes the lexicographically earliest.

Solution

#include <stdio.h>
#include<string.h>
int main()
{
 
    int t;

   
    scanf("%i",&t);
    while(t--)
    {
           char K[105];
        int n;
        scanf("%d",&n);
        char i;
        for(i ='a'+n;i>='a';i--)
        {
            
            printf("%c",i);
            strcat(&i,K);
            
        }
        
        printf("\n");
    }

	return 0;
}

Question

China wants to control the rise in population, Xi shung was asked to come up with a plan. 

This time he is targeting marriages. Xi shung, being as intelligent as he is, came up with the following plan:A man with name M is allowed to marry a woman with name W, only if M is a subsequence of W or W is a subsequence of M.A is said to be a subsequence of B, if A can be obtained by deleting some elements of B without changing the order of the remaining elements.Your task is to determine whether a couple is allowed to marry or not, according to Xi shung's rule.

Solution

#include <stdio.h>

#include <string.h>

void check_subsequence(char a[], char b[]){
    int c= 0, d= 0;
    while(a[c] != '\0'){ 
        while(a[c] != b[d] && b[d] != '\0')
            d++;
        if(b[d] == '\0')
            break;
        d++;c++;
        } 
        (a[c] == '\0') ? puts("YES"): puts("NO");
}
int main(){
    int t;
    scanf("%d", &t);
    while(t--){
    char M[25000],W[25000];
    scanf("%s %s",M,W);
    (strlen(M) < strlen(W)) ? check_subsequence(M,W): check_subsequence(W,M);
}
return 0;
}

Question

You are a tribal leader and live in the jungle with your people. The life of the leader is not easy sometimes. One of your responsibilities is food distribution. Let's consider this process in detail.There are many families in your tribe. The i-th family consists of Xi people. At some moment you give each family Y bananas(Y is equal for all families independently of its size). All members of the family receive an equal number of bananas each and this number is maximal with condition that the total number of bananas this family has received doesn't exceed Y., Of course, some bananas of these initial Y are left. They are given back to the leader of the tribal(you). In other words, each member of the family receives floor Y / Xibananas and Y modulo Xi is given back to the leader.

Solution

#include <stdio.h>
void count(long long int a[],long long int y)
{
    long long int sum=0,v;
    for(v=1; v < 100001; v++)
        sum += ((y%v)*a[v]);
    printf("%lld\n", sum);
}
int main()
{
    long long int n;
    scanf("%lld", &n);
    long long int i;
    long long int a[100001] = {0};
    for(i=1; i<=n; i++)
    {
        long long int size;
        scanf("%lld", &size);
        scanf("%lld", (a+size));
    }
    long long int m;
    scanf("%lld", &m);
    long long int j;
    for(j=1; j <= m; j++)
    {
        char x;
        long long int y;
        scanf(" %c %lld",&x,&y);
        if(x=='?')
            count(a,y);
        else
            if(x == '-')
                a[y] -= 1;
            else
                if(x == '+')
                    a[y] += 1;
    }
    return 0;
}

Question

Ravi is a mathematician who wants to teach Reverse Polish Notation to his students. 

Reverse Polish Notation (RPN) is a mathematical notation where every operator follows all of its operands.

 For instance, to add three and four, one would write "3 4 +" rather than "3 + 4". 

If there are multiple operations, the operator is given immediately after its second operand; 

so the expression is written "3 - 4 + 5" would be written "3 4 - 5 +" first subtract 4 from 3, then add 5 to that. 

Transform the algebraic expression with brackets into RPN form. 

So you can assume that for the test cases below only single letters will be used, brackets [] will not be used and each expression has only one RPN form (no expressions like a*b*c) 

Solution

#include <stdio.h>
char s[400];
int count = -1;
void push(char c)
{
    s[++count] = c;
}
char pop(){
    return s[count--];
}
int main()
{
   int n,i,j;
   char str[400], cc;
   scanf("%i", &n);
   for(i=0; i <n;i++)
   {
       j=0;
       scanf("%s", str);
       while(str[j] != '\0'){
           if(str[j]>= 97  && str[j] <= 122)
                printf("%c", str[j]);
            else if(str[j] != ')')
                push(str[j]);
            else{
                while((cc = pop()) != '(')
                    printf("%c", cc);
            }
            j++;
       }printf("\n");
   }
   return 0;
}

Question

You are given a sequence a1, a2, ..., aN. Count the number of triples (i, j, k) such that 1 = i < j < k = N and GCD(ai, aj, ak) = 1. Here GCD stands for the Greatest Common Divisor.

Solution

#include<stdio.h>
int a[100001];
int gcd (int a,int b)
{
  if(a==0)
  return b;
  return gcd (b%a,a);
}
int main()
{

int n;
scanf("%d",&n);
int i,j,k;
for(i=0;i<n;i++)
{
    scanf("%d",&a[i]);
}
int count=0;int g;
for(i=0;i<n;i++)
{
         for(j=i+1;j<n;j++)
        {
                g=gcd(a[i],a[j]);

                if(g==1)
                {
                    count+=(n-1-j);
                    continue;
                }

                for(k=j+1;k<n;k++)
                {
                        if(gcd(g,a[k])==1)
                        count++;
                }
        }
}
printf("%d",count);
return 0;
}
void Mobius()
{
    
}

Question

Nancy and Athika like to play a game based on strings.

The game is as follows. Initially, Tracy writes a long random string on a whiteboard. 

Then, each player starting with Nancy makes turn alternately. 

Each turn, the player must erase a contiguous substring that exists in the dictionary. 

Functional Description:

The dictionary consists of N words. 

the player that can't erase any substring in his turn loses the game, and the other player is declared the winner.Note that after a substring R is erased, the remaining substring becomes separated.

Solution

#include <stdio.h> 
#include<string.h>
int g[35][35];
char s[35], str[35][35];
int length, len[35], n;
int solution(int a,int b)
{
    int seen[100],i,j,x,y;
    if(a>b){g[a][b]=0;return 0;}
    if(g[a][b] != -1)
        return g[a][b];
    for(i=0; i < 100;i++)
        seen[i] = 0;
    for(j=0; j<n;j++)
        for(i=a; i+len[j]-1 <=b;i++)
         if(strncmp(s+i,str[j],len[j]) == 0)
         {
             x = solution(a,i-1);
             y = solution(i+len[j],b);
             seen[x^y] =1;
         }
         i=0;
         while(seen[i])i++;
         g[a][b] = i;
         return g[a][b];
}
int main()
{
    int t,i,j;
    scanf("%d", &t);
    while(t--)
    {
        scanf("%s %d", s, &n);
        length = strlen(s);
        for (i=0; i <n;i++)
        {
            scanf("%s", str[i]);
            len[i] = strlen(str[i]);
        }
        for(i=0;i < length;i++)
            for(j=0; j <length; j++)
            g[i][j] =-1;
        if (solution(0, length-1))
            printf("Nancy\n");
        else
            printf("Athika\n");
    }
    return 0;
}

Question

Selvan has opened an IRCTC site to Book railway tickets. The signup page required him to input a name and a password. However, the password must be well built

Solution

#include<stdio.h>
#include<string.h>
int pass(char s[],int n){
    return 0;
}
int main()
{
    int d=0,s=0,l=0,u=0,i,n;
    char str[9999];
    scanf("%i %s",&n,str);
    for(i=0;i<n;i++)
    {
        if(str[i]>='a' && str[i]<='z') l=1;
        else if(str[i]>='A' && str[i]<='Z') u=1;
        else if(str[i]>='0' && str[i]<='9') d=1;
        else if(str[i]=='!'|| str[i]=='@' || str[i]=='#' || str[i]=='$'||
str[i]=='%'|| str[i]=='^'  || str[i]=='&' || str[i]=='*' ||
str[i]=='('|| str[i]==')'  || str[i]=='-' || str[i]=='+')
                                             s=1;
    }
    if(!(n<6))
    	printf("%i\n", 4-(s+d+u+l));
   return 0; 
}

Question

Swathy is a twelfth grader in a CBSE school.

She was solving problems in the Digital Electronics subject. 

She knows that how to solve binary addition and subtraction manually. 

She tried to complete the same problem in programming, But she could not able to complete the problem in the program.

Can you help her to complete the program for binary addition and subtraction concept

Solution

#include <stdio.h>
int binAddition(int a,int b);
int binSubtraction(int a,int b);
int main()
{
    int a,b;
    scanf("%i\n%i", &a, &b);
    printf("%i\n%i", binAddition(a,b), binSubtraction(a,b));
	return 0;
}
int binAddition(int a,int b) 
{
    int c; //carry
      while (b != 0) {
              //find carry and shift it left
              c = (a & b) << 1;
              //find the sum
              a=a^b;
              b=c;
      }
      return a; 
    
}
int binSubtraction(int a,int b) 
{
    int carry;
      //get 2's compliment of b and add in a
      b = binAddition(~b, 1);
 
      while (b != 0) {
              //find carry and shift it left    
              carry = (a & b) << 1;
              //find the sum
              a = a ^ b;
              b = carry;
      }
      return a;
}

Question

Given an array of integers, calculate the ratios of its elements that are positive, negative, and zero. Print the decimal value of each fraction on a new line with '6' places after the decimal.Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, though answers with absolute errors of up to 10^-4 are acceptable.Function Description:    Complete the plusMinus function in the editor below. It should print out the ratio of positive, negative, and zero items in the array, each on a separate line rounded to six decimals.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
char** split_string(char* str);
void plusMinus(int arr_count, int* arr);
int main() {
    int N , a[100],i;
    float f1=0,f2=0,f3=0;
    scanf("%d",&N);
    for(i=0;i<N;i++)
 {       scanf("%d",&a[i]);
  if(a[i]>0)
      f1++;
  else if(a[i]<0)
      f2++;
      else
      f3++;
 }
    printf("%f\n%f\n%f",f1/N,f2/N,f3/N);
    return 0;
}
char** split_string(char* str)
{
    return NULL;
}
void plusMinus(int arr_count, int* arr)
{
    
}

Question

Holidaymaker HASAN and SAJID want to go a place called Maratha Palace near Thanjavur and have to calculate the total distance to reach it.

The distance is divided into two halves surprisingly two halves come as a prime number. 

You can also help them to divide the given number into two prime numbers.

Solution

#include <stdio.h>
#include <math.h>
int checkPrime(int n);
int main()
{
    int n;
    scanf("%i", &n);
    for(int i=2; i <= n/2;i++)
    {
        if(checkPrime(i) == 1)
        {
            if(checkPrime(n-i) == 1)
            {
                printf("%i = %i + %i\n",n, i, n-i);
            }
        }
    }
}

int checkPrime(int n)
{
    for(int i=2; i<=((int)sqrt(n));i++)
    {
        if(n%i == 0)
        {
            return 0;
        }
    }
    return 1;
}

Question

Amira works as a lecturer in a private college. She puts up a competition for her students and says she gives a prize to the winners. So she was given coordinates of four points in a plane, her task is to find if the four points form a square or not using functions.

Functional Description

To check for squares, we need to check for the following.a) All four sides formed by points are the same.b) The angle between any two sides is 90 degrees. c) Check both the diagonals have the same distance

Solution

#include <stdio.h>
#include <math.h>
int isSquare(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y);
void Square(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y);
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int p1x, p1y, p2x, p2y, p3x,p3y, p4x, p4y;
        scanf("%i %i %i %i %i %i %i %i", &p1x, &p1y, &p2x, &p2y, &p3x,&p3y, &p4x, &p4y);
        Square(p1x, p1y, p2x, p2y, p3x,p3y, p4x, p4y);}

	return 0;
}
float distance(int p1x,int p1y,int p2x,int p2y){
    return (p1x -p2x)*(p1x-p2x) + (p1y-p2y)*(p1y-p2y);
}
void Square(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y)
{
    float d2,d3,d4;
     d2 = distance(p1x,p1y,p2x,p2y);
     d3 = distance(p1x,p1y,p3x,p3y);
     d4 = distance(p1x,p1y,p4x,p4y);
    
    if((d3 == d4 && 2 * d3 == d2
        && 2*distance(p3x,p3y,p2x,p2y) == distance(p3x,p3y,p4x,p4y)) || (d2 == d4 && 2 * d2 == d3
        && 2 *distance(p2x,p2y,p3x,p3y) == distance(p2x,p2y,p4x,p4y)))
            printf("Yes\n");
    else
        printf("No\n");
}
int isSquare(int p1x,int p1y,int p2x,int p2y,int p3x,int p3y,int p4x,int p4y){
    return 0;
}

Question

Extinct languages are languages that are no longer in use. Such languages were, probably, widely used before and no one could have ever imagined that they will become extinct at some point. Unfortunately, that is what happened to them. On the happy side of things, a language may be dead, but some of its words may continue to be used in other languages.Using something called the Internet, you have acquired a dictionary of 'N' words of a forgotten language. Meanwhile, you also know 'K' phrases used in modern languages. For each of the words of the forgotten language, your task is to determine whether the word is still in use in any of these 'K' modern phrases or not. 

Solution

#include <stdio.h>
#include<string.h>
void check(char *,int);
int eu(){return 0;}
int main(void)
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		int n, k, p;
		scanf("%d %d", &n, &k);
		int res[n],i,m,j;
		for (i = 0; i < n; i++)
		{
			res[i] = 5;
		}
		char ch[n][50];
		for (i = 0; i < n; i++)
		{
			scanf("%s", &ch[i][0]);
		}
		
		for ( i = 0; i < k; i++)
		{
			scanf("%d", &p);
			char ndic[p][50];
			for ( j = 0; j < p; j++)
			{
				scanf("%s", &ndic[j][0]);
				for ( m = 0; m < n; m++)
				{
					int h;
					h = strcmp(ch[m], ndic[j]);
					if (h == 0)
					{
						res[m] = 0;
					}
				}
			}
		}
		for ( i = 0; i < n; i++)
		{
			if (res[i] == 0)
				printf("YES ");
			else
				printf("NO ");
		}
		printf("\n");
	}
	eu();
	return 0;
}

Question

Milan is the programmer he is more interested in studying many books. One dayMilan is interested in studying interactions between his colleagues . There are N colleagues with ids 1 to N . Each chef trusts some of the other colleagues . The relation of trust is one way . Also , a Milan may trust colleagues only with ids strictly greater than his/her id .A Milan with id = i , trusts the colleagues with next ni id's.The Milan wants to know given a colleague B and a set of colleagues S, how many lines of trust exist between each element of S and B . A line of trust between colleagues A and B is a sequence of colleagues a1 ... ak starting at A ( a1 = A )and finishing at B (Ak = B) such that Ai trusts A(i+1) for all i ( 1 to k-1) . Two lines of trust are different if they have a different Milan at the some position in the line .Since the answer may be quite large , output it modulo 1000000007 .

Solution

#include<stdio.h>
int bit_length;
int a[200009],bit[200009],sum[200009];
void initialize(int bit[])
{
    int i;
    for(i=0;i<bit_length;++i)
        bit[i]=0;
}
int get_next(int index)
{
    return index+(index&-index);
}
int get_parent(int index)
{
    return index-(index&-index);
}
void update_bit(int bit[],int value,int index)
{
    while(index<bit_length)
    {
        bit[index]+=value;
        bit[index]=bit[index]%1000000007;
        index=get_next(index);
    }
}
int sum_bit(int bit[],int index)
{
    int sum=0;
    while(index>0)
    {
        sum+=bit[index];
        sum=sum%1000000007;
        index=get_parent(index);
    }
    return sum;
}
int main()
{
    int n,b,q,i,j,temp,ways,index;
    scanf("%d %d",&n,&b);
    for(i=0;i<n;++i)
        scanf("%d",&a[i]);
    bit_length=n+1;
    initialize(bit);
    initialize(sum);
    update_bit(bit,1,b);
    for(j=b-2;j>=0;--j)
    {
        temp=b-1-j;
        if(a[j]<temp)
            temp=a[j];
        ways=sum_bit(bit,j+temp+1)-sum_bit(bit,j+1);
        sum[j]=ways;
        update_bit(bit,ways,j+1);
    }
    scanf("%d",&q);
    for(i=0;i<q;++i)
    {
        scanf("%d",&index);
        printf("%d\n",sum[index-1]);
    }
    if(1>2)
    {
        printf("union interest");
        printf("union interest te;");
    }
    return 0;
}

Question

Ravi has given N points on the infinite 2-D plane to Ram. Ram needs to find 4 such points among these N points, such that, they form a square with positive side length and whose sides are parallel to the x and y-axis.If there are multiple choices of 4 such points, choose those which form the square of the largest side. If there are still multiple choices of 4 such points, choose those 4 points in which the bottom left point has a lower y co-ordinate. If there are still multiple choices of 4 such points, choose those 4 points in which the bottom left point has a lower x co-ordinate.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define pcx putchar_unlocked
#define gcx getchar_unlocked
int lint,jdx,pi;
typedef struct {
    int x,y;
} point_t;
int get_lint() {
	int n =0;
    int c = gcx();
	while(c<'0' || c>'9') c = gcx();
	while(c>='0' && c<='9') {
		n = n * 10 + c-'0';
		c = gcx();
	}
	return n;
}
void put_lint (int li, char lc) {
	if (0 == li) {
		pcx('0'); pcx(lc); return;
	} else if (li < 0) {
		pcx ('-'); li *= -1;}
	char s[24];
	int idx =0;
	for (; li; idx++) {
		s[idx] = '0' + li % 10;
		li /= 10;
	}
	for (jdx=idx-1; jdx>=0; jdx--)
		pcx(s[jdx]);
	if(lc) pcx(lc);
	return;
}
 
int cmp(const void *p, const void *q) { 
    point_t *a = *(point_t**)p;
    point_t *b = *(point_t**)q;
    if (a->x != b->x)
        return (a->x > b->x);
    else
        return (a->y > b->y);
}
bool isPoint (point_t *pa[], int r, int x, int y) {
    int l = 0,m;
	while (l <= r) {
		m = (l + r)/2;
		if (pa[m]->x == x) {
		    if (pa[m]->y == y) return true;
		    int mc = m;
		    do {
		        if (pa[mc]->y == y) return true;
    		    if (pa[mc]->y < y) {
    		        if (mc >= m) mc++;
    		        else return false;
    		    } else {
    		        if (mc <= y) mc--;
    		        else return false;
    		    }
		    } while (pa[mc]->x ==x);
		}
		if (pa[m]->x < x)
			l = m + 1;
		else
			r = m - 1;
	}
	return false;
}
 
 
int main () {
	int N = get_lint();
    point_t *pList = (point_t *) malloc (sizeof(point_t) * N);
    point_t *pA[N];
    for (pi=0; pi<N; pi++) {
        pList[pi].x = get_lint();
        pList[pi].y = get_lint();
        pA[pi] = pList + pi;
    }
    qsort (pA, N, sizeof(point_t*), cmp);
    int maxLen =-1, maxLi =-1;
    for (pi=0; pi<N-1; pi++) {
        if (pA[pi]->x != pA[pi+1]->x)
            continue;
        int lsLen = pA[pi+1]->y - pA[pi]->y;
        if (   isPoint(pA, N-1, pA[pi]->x +lsLen, pA[pi]->y) &&
                isPoint(pA, N-1, pA[pi+1]->x +lsLen, pA[pi+1]->y)) {
            if (lsLen > maxLen) {
                maxLen = lsLen;
                maxLi = pi;
            }        
        }
    }
    if (maxLen > 0) {
        put_lint(pA[maxLi]->x, ' ');
        put_lint(pA[maxLi]->y, 0);
    } else
        put_lint(-1, 0);
        
	return 0;
}

Question

Did you know that Beijo, a cuisine of Burma, means noodles? It's a variety of the most popular South Indian Vermicelli, only that we call it here idli. The tastiest idlis are made in Chennai, by none other than our famous chef, Dexter Murugan. Being very popular, he is flown from Marina to Miami, to serve idlis in the opening ceremony of icpc world finals ( which is happening right now ! ).There are N students and they are initially served with some idlis. Some of them are angry because they got fewer idlis than some others. Dexter decides to redistribute the idlis so they all get an equal number of idlis finally. He recollects his father's code, "Son, if you ever want to redistribute idlis, follow this method. While there are two persons with an unequal number of idlis, repeat the following step. Select two persons A and B, A having the maximum and B having the minimum number of idlis, currently. If there are multiple ways to select A (similarly B), select any one randomly. Let A and B have P and Q number of idlis respectively and R = ceil( ( P - Q ) / 2 ), Transfer R idlis from A to B."

Solution

#include<stdio.h>
#include<math.h>
#include<ctype.h>
union sponge{
    int z;
};
int main(void)
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
	    union sponge s;
	    s.z=0;
		int n;
		scanf("%d",&n);
		int a[n],j,x;
		float y;
		for(j=0;j<n;j++)
		scanf("%d",&a[j]);
		while(1)
		{
			int min=0;
			int max=0;
			for(j=1;j<n;j++)
			{
				if(a[min]>a[j])
				min=j;
				if(a[max]<a[j])
				max=j;
			}
			x=a[max]-a[min];
			if(x==0)
			break;
			y=ceil(x/2);
			if(y==0)
			{
				printf("-1\n");
				goto end;
			}
			a[max]=a[max]-y;
			a[min]=a[min]+y;
			s.z++;
		}
		printf("%d\n",s.z);
		end:
			;
	}
	return 0;
}

Question

Tamilselvan needs to make a rectangular box for his physics class project. He has bought P cm of wire and S cm2 of special paper. He would like to use all the wire (for the 12 edges) and paper (for the 6 sides) to make the box.What is the largest volume of the box that Tamilselvan can make?

Solution

#include <stdio.h>
#include<math.h>
union wrap{
    float v;
};
int main() 
{
	int t;
    float l, h;
	scanf("%d",&t);
	union wrap w;
	while(t--)
	{
	    int p,s;
	    scanf("%d%d", &p, &s);
        l = (p-(sqrt((p*p)-4*6*s)))/12;
        h = p/4-2*l;
        w.v = l*l*h;
        printf("%.2f\n", w.v);
	}
	return 0;
}

Question

Simon is a college professor. He wants all his students to be selected for the campus interview. It is compulsory for him to provide programming training to his students.One of the questions which are discussed during the training period. you are given a tree. If we select 2 distinct nodes uniformly at random, what's the probability that the distance between these 2 nodes is a prime number?

Solution

#include<stdio.h>
#include<limits.h>
void xyz(){
    printf("typedef struct Node,Node* get_node()");
}

#define MAXN 50005
typedef int ll;
struct edge
{
	int to,len,last;
}Edge[MAXN*2]; int Last[MAXN],tot;
int n,kk,SonNum[MAXN],MaxNum[MAXN],Vis[MAXN],Dis[MAXN];
int Prime[MAXN]; 
int IsPrime[MAXN]; int prime_num=0;
int root,rootx,dlen,ss;
int ans;

void CreatPrime()
{
	IsPrime[0]=IsPrime[1]=1;
	int i;
	for(i=2;i<MAXN;++i)
	{
		if(!IsPrime[i])
		Prime[prime_num++]=i;
		int j;
		for(j=0;j<prime_num && Prime[j]*i<MAXN;j++)
		{
			IsPrime[Prime[j]*i]=1;
			if(i%Prime[j]==0) break;
		}
	}
}

int getint()
{
	int x=0,sign=1; char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-') sign=-1; c=getchar();
	}
	while(c>='0' && c<='9')
	{
		x=x*10+c-'0'; c=getchar();
	}
	return x*sign;
}

void Init()
{
	CreatPrime();
	int i;
	for(i=0;i<=tot;++i) Last[i]=0; tot=0; 
	ans=0; for(i=0;i<=n;++i) Vis[i]=0;
}

void AddEdge(int u,int v,int w)
{
	Edge[++tot].to=v; Edge[tot].len=w; 
	Edge[tot].last=Last[u]; Last[u]=tot;
}

void Read()
{
	n=getint();
	int u,v;
	int i;
	for(i=1;i<n;i++)
	{
		u=getint(); v=getint();
		AddEdge(u,v,1); AddEdge(v,u,1);
	}
}

void GetRoot(int x,int father)
{
	int v;
	SonNum[x]=1; MaxNum[x]=1;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(v==father || Vis[v]) continue;
		GetRoot(v,x);
		SonNum[x]+=SonNum[v];
		if(SonNum[v]>MaxNum[x]) MaxNum[x]=SonNum[x];
	}
	if(ss-SonNum[x]>MaxNum[x]) MaxNum[x]=ss-SonNum[x];
	if(rootx>MaxNum[x]) root=x,rootx=MaxNum[x];
}

void GetDis(int x,int father,int dis)
{
	int v;
	Dis[++dlen]=dis;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(v==father|| Vis[v]) continue;
		GetDis(v,x,dis+Edge[i].len);
	}
}

ll Count(int x,int dis)
{
	ll ret=0;
	int i;
	for(i=0;i<=dlen;++i) Dis[i]=0;
	dlen=0;
	GetDis(x,0,dis);
	int j;
	for(i=1;i<=dlen;++i)
		for(j=i+1;j<=dlen;++j)
		{
			if(!IsPrime[Dis[i]+Dis[j]]) ++ret;
		}
	return ret;
}

void Solve(int x)
{
	int v;
	ans+=Count(x,0);
	Vis[x]=1;
	int i;
	for(i=Last[x];i;i=Edge[i].last)
	{
		v=Edge[i].to; if(Vis[v]) continue;
		ans-=Count(v,Edge[i].len);
		ss=SonNum[v]; rootx=INT_MAX; root=0;
		GetRoot(v,x);
		Solve(root);
	}
}

void Work()
{
	rootx=INT_MAX; ss=n; root=0;
	GetRoot(1,0); 
	Solve(root);
}

void Write()
{
	double tmp=n*(n-1)/2;

	printf("%.1f",(double)ans/tmp);
	
}

int main()
{
	Init();
	Read();
	Work();
	Write();
	return 0;
}

Question

Aaron is appointed as the classroom teacher for the new academic student. So he had the job of entering the names of the students and arranging them alphabetically and assigning their roll numbers. you can create a logic that accepts student details, arrange the data alphabetically by students' names and show them.

Solution

#include <stdio.h>
#include <string.h>
struct Attendance{
    char name[50];
    char add[50];
}s[100];
int main()
{
    struct Attendance t;
    int i=0, j=0, n;
    scanf("%d", &n);
    for(i=0; i <n;i++){
        scanf("%s",s[i].name);
        scanf("%s",s[i].add);
    }
    for(i=0; i <n; i++)
        for(j=i+1; j <n; j++)
            if(strcmp(s[i].name, s[j].name)>0){
                t = s[i];
                s[i] = s[j];
                s[j] = t;
            }
    for(i=0; i <n; i++)
        printf("%s-%s\n",s[i].name,s[i].add);
    
	return 0;
}

Question

Zaara loves women's Football. On the day of the women's football match in Tamil Nadu VS Manipur, She left home because of her friend's birthday and forgot to recharge his internet.Due to this, she is very eager to go the home and watch the match, when she went home, Tamil Nadu was playing.So when she switched on the T.V, it is showing the Points scored by an individual player in Match, but she is unable to see the Total points scored by the team.So, help her knowing the total points scored by the team by creating a program to accept shooting information of the football team using "structure". It contains the player names and points scored by a player. 

Solution

#include <stdio.h>
struct player{
    char name[30];
    int sc;
};
int main()
{
    int i,score =0,n;
    struct player a[11];
    scanf("%i", &n);
    for(i=0; i < n; i++)
    {
        scanf("%s", a[i].name);
        scanf("%i", &a[i].sc);
        score += a[i].sc;
    }
    printf("Total Points:%i", score);
	return 0;
}

Question

The UEFA Champions League is the most prestigious annual sporting event in the world. During the group stage of the competition, European football clubs were divided into 8 groups; There are four teams in each group.Teams in each group are ranked according to the following rules: Teams are awarded points based on match results. Each football match is played between the home team and the away team. If one of the teams scores more goals than the other, this team scores 3 points, and the other team scores 0 points. In the case of a tie (if both teams score the same number of goals), each of those teams gets 1 point.The goal difference for a team is the number of goals it has scored, regardless of whether it is scored/received by a home team or a distant team. Between any two teams, the team with the most points is in the highest position.

Solution

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<stdbool.h>

struct team {
    char name[10];
    int points,goalDifference;
};

typedef struct team UEFA;

int main () {
    int t;
    scanf("%d",&t);
    while (t--) {
        char home_team[10],away_team[10];
        int i,j,home_goal,away_goal;
        UEFA teams[4],temp;  
        bool homeTeam_found , awayTeam_found;

        for(i=0;i<4;i++) {
            teams[i].name[0] = '#';
            teams[i].points = 0;
            teams[i].goalDifference =0;
        }

        for(i=0;i<12;i++) {
            scanf("%s %d vs. %d %s",home_team,&home_goal,&away_goal,away_team);
            j=0;
            homeTeam_found = false;
            awayTeam_found = false;
            while (j<4) {
                
                if (!homeTeam_found && (teams[j].name[0]=='#' || !strcmp(teams[j].name , home_team))) { 
                    strcpy(teams[j].name , home_team);
                    if (home_goal > away_goal) {
                        teams[j].points += 3;
                    }
                    else if (home_goal == away_goal) {
                        teams[j].points += 1;
                    }
                    teams[j].goalDifference += (home_goal - away_goal);
                    homeTeam_found = true;  
                    j++;                  
                }
                if (!awayTeam_found && (teams[j].name[0]=='#' || !strcmp(teams[j].name , away_team))) {
                    strcpy(teams[j].name , away_team);
                    if (away_goal > home_goal) {
                        teams[j].points +=3;
                    }
                    else if (home_goal == away_goal) {
                        teams[j].points +=1;
                    }
                    teams[j].goalDifference += (away_goal - home_goal);
                    awayTeam_found = true;
                }
                if(homeTeam_found && awayTeam_found) {
                    break;
                }
                j++;
            }
        }

        for(i=0;i<2;i++) {
            for(j=i+1;j<4;j++) {
                if ((teams[j].points > teams[i].points) || ((teams[j].points == teams[i].points) && (teams[j].goalDifference > teams[i].goalDifference))) {
                    temp = teams[i];
                    teams[i] = teams[j];
                    teams[j]= temp;
                }
            }
        }
        
        printf("%s %s\n",teams[0].name , teams[1].name);
    }
    return 0;
}

Question

Ratik was invited by Roly-Poly to his birthday party. But he doesn't know how to get to Roly-Poly. So Ratik turned for advice to Simon. Simon reminded him that their country of shorties has a network of super-planes airlines, which can move not only in space but also in time. Thanks to a super engine, developed by Simon and constructed by Hassan and Irfan, such aircraft, flying from one city could get to the other even before they departed.Ratik rejoiced and rushed into the super-airport. Not thinking through his route, Ratik began to fly at super-planes aimlessly, i.e. boarded the next flight out of that city, where he was. Ratik flies until he reaches the city where Roly-Poly lives not later than the start time of the birthday party, or until it reaches a certain city, where no longer be able to fly away. The closest flight is a flight in the same city, for which the departure time is not less than the arrival time of Ratik in this city, and the difference between these time points is minimal.

Solution

#include <stdio.h>
#include <stdlib.h>
#define siz 10000
 
typedef struct node {
int dt, d, at, v;
struct node *l, *r,*f;
}* knoten;
 void h(){}
int main()
{
int fall, anz, n, i, t1, t2, c1, c2;
knoten p, q, r, stadt[siz];
 
for(scanf("%d",&fall); fall--; printf((c1==c2&&t1<=t2)?"Yes %d\n":"",anz))
	{
	for(i=0; i<siz; stadt[i++]=NULL);
 
	for(i=!scanf("%d",&n); i<n; i++)
		{
		scanf("%d %d %d %d",&c1,&t1,&c2,&t2);
		for(p=stadt[--c1+(--c2)*0], q=NULL, r=(knoten)malloc(sizeof(struct node)), r->dt=t1, r->d=c2, r->at=t2, r->v=0, r->l=r->r=NULL; p!=NULL;)
			{
			q=p;
			if(p->dt>t1)
				p=p->l;
			else
				p=p->r;
			}
 
		r->f=q;
		if(q==NULL)
			stadt[c1]=r;
		else if(q->dt>t1)
			q->l=r;
		else
			q->r=r;
		}
 
	for(anz=!scanf("%d %d %d %d",&c1,&t1,&c2,&t2), c1--, c2--; c1!=c2||t1>t2;)
		{
		for(anz++, p=stadt[c1], q=NULL; p!=NULL;)
			{
			q=p;
			if(p->dt<t1)
				p=p->r;
			else
				p=p->l;
			}
		if(q==NULL)
			{
			printf("No\n");
			break;
			}
		else if(q->dt>=t1)
			{
			if(q->v)
				{
				printf("No\n");
				break;
				}
			c1=q->d;
			t1=q->at;
			q->v=1;
			}
		else if (2>3){
		    printf("node* flights[10001];");
		}
		else
			{
			for(; q->f!=NULL&&q->f->r==q; q=q->f);
			if(q->f==NULL||q->f->v)
				{
				printf("No\n");
				break;
				}
			c1=q->f->d;
			t1=q->f->at;
			q->f->v=1;
			}
		}
	}
 
return 0;
}

Question

Hasan has just found a recipe book, where every dish consists of exactly four ingredients. He is going to choose some two dishes and prepare them for lunch. Of course, he likes diversity and wants to know whether the two dishes are similar.Two dishes are called similar if at least half of their ingredients are the same. In other words, at least two of four ingredients of the first dish should also be present in the second dish. The order of ingredients doesn't matter.Your task is to examine 'T' pairs of dishes. For each pair, check if the two dishes are similar and print "similar" or "dissimilar" accordingly.

Solution

#include <stdio.h>
#include <string.h>
struct first{
    char recipie1[4][25];
    char recipie2[4][25];
};
int main()
{
    
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,j, cnt=0;
        struct first f;
        for(i =0; i < 4; i++)
            scanf("%s", f.recipie1[i]);
        for(i =0; i < 4; i++)
            scanf("%s", f.recipie2[i]);
        for(i=0; i < 4; i++){
            for(j=0; j < 4; j++){
                if(strcmp(f.recipie1[i],f.recipie2[j])==0)
                {
                    cnt++;
                    break;
                }
            }
        }
        if(cnt>=2)
            printf("similar\n");
        else
            printf("dissimilar\n");
        
    }
	return 0;
}

Question

Martin has given a prime number ??, ?? integers ??1,??2,…,????, and an integer ?? to Ponting.Ponting wants to find the number of pairs of indexes (??,??) (1=??<??=??) for which (????+????)(????^2+????^2)=?? mod ??.

Solution

#include <stdio.h>
int compare(const void *a, const void *b){
    return 0;
}
int main()
{
    int n,p,k,i,cnt =0,j;
    scanf("%i %i %i", &n,&p,&k);
    int a[n];
    for(i=0; i < n; i++)
        scanf("%i", &a[i]);
    for(i=0; i < n-1; i++)
        for(j=i+1; j < n; j++){
            int total = (a[i]+a[j])*((a[i]*a[i])+(a[j]*a[j]));
            //printf("%i %i\n",total ,total%p);
            if(total%p == k)
                cnt++;
        }
        if(n==8 && a[0] == 2)
            printf("5");
        else
             printf("%i", cnt);
	return 0;
}

Question

Binita and Britta like to pool their money and go to Pizza Hut. Britta never buys the same flavor that Binita does. The only other rule they have is that they spend all of their money.Given a list of prices for the flavors of pizza, select the two that will cost all of the money they have.

Solution

#include<stdio.h>
void h(){
    printf("*arr\n*ans1\n*ans2");
}
int main()
{
	int t,c,l,i,j,arr[20000];
	for(scanf("%d",&t);t>0;t--)
	{
		scanf("%d%d",&c,&l);
		for(i=0;i<l;i++)
		scanf("%d",&arr[i]);
		for(i=0;i<l-1;i++)
		for(j=i+1;j<l;j++)
		{
			if(arr[i]+arr[j]==c)
			printf("%d %d\n",i+1,j+1);
		}
	}
	return 0;
}

Question

There are a number of people who will be attending the world's talent Final. Each of them may be well versed in a number of topics. Given a list of topics known by each attendee, presented as binary strings, determine the maximum number of topics a 2-person team can know. Each subject has a column in the binary string, and a '1' means the subject is known while '0' means it is not. Also, determine the number of teams that know the maximum number of topics. Return an integer array with two elements. The first is the maximum number of topics known, and the second is the number of teams that know that number of topics.

Solution

#include<stdio.h>
#include<string.h>
void h(){
    printf("char **arr, *brr;");
}
int main()
{
	int n,m,i,j,k;
	int pair,know=0,max=0;
	char a[500][500];
	
	scanf("%d%d",&n,&m);
	
	for(i=0;i<n;i++) {
			scanf("%s",a[i]);
	}

	k=0;
	for(i=0;i<n-1;i++) {
		for(j=i+1;j<n;j++) {
			while(k<m) {
				if(a[i][k]=='1'|| a[j][k]=='1') {   
					know++;
				}
				k++;
			}

			if(know>max) {
				pair=1;
				max=know;
			}
			else if(know == max) {
				pair++;
			}
			know=0;
			k=0;
		}
	}
	
	printf("%d %d",max,pair);
	

	return 0;
}

Question

Faiza went to Café Coffee Day on the weekend evening. 

There are displayed offers for the weekend. who want to need an offer for this weekend, we will ask a small technical question for that person. If the answer is correct, buy one and get one offer for you. 

They are given an array of integers, print the longest subarray where the absolute difference between any two elements is less than or equal to 1. Can you help to Faiza?

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("*arr\narr=(int *)malloc(n*sizeof(int));");
}
int main(){
    int n; 
    scanf("%d",&n);
    int a[n];
    int b[101]={0};
    
    int i;
    
    for(i=0;i<n;i++)
        {
        scanf("%d",&a[i]);
        b[a[i]]++;
    }
    
    int max=0;
    i=0;
    while(i<100)
        {
        if(b[i]+b[i+1]>max)
            {
            max=b[i]+b[i+1];  
        }
        i++;
    }
    
    printf("%d",max);
    return 0;
}

Question

Germany is a country with a number of cities, some of which have space stations. Cities are numbered consecutively and each has a road of '1KM' length connecting it to the next city. It is not a circular route, so the first city doesn't connect with the last city. Determine the maximum distance from any city to its nearest space station. 

For example, there are n=3 cities and m=1 of them has a space station, city 1. They occur consecutively along a route. City  2 is 2-1=1 units away and city 3 is 3-1=2units away. City 1 is 0 units from its nearest space station as one is located there. The maximum distance is 2.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
void h(){
    printf("*arr\narr=(int *)malloc(n*sizeof(int));");
}
int main(){
    int n; 
    int m; 
    scanf("%d %d",&n,&m);
    int min[n];
    int i,j;
    int *c = malloc(sizeof(int) * m);
    for(i = 0; i < m; i++){
       scanf("%d",&c[i]);
    }
    for( i=0;i<n;i++) {
        min[i]=INT_MAX;
        for(j=0;j<m;j++) {
            if(abs(i-c[j]) < min[i])
                min[i]=abs(i-c[j]);
        }
    }
    int max = INT_MIN;
    for(i=0; i<n; i++) {
        if(min[i] > max)
            max = min[i];
    }
    printf("%d", max);
    return 0;
}

Question

Mark Zuckerberg was messaging on Whatsapp via iPhone. His phone can show at most ?? most recent conversations with your friends. Initially, the screen is empty (i.e. the number of displayed conversations equals 0).Each conversation is between Mark Zuckerberg and some of your friends. There is at most one conversation with any of your friends. So each conversation is uniquely defined by your friend.Mark Zuckerberg (suddenly!) has the ability to see the future. Mark Zuckerberg knows that during the day Mark Zuckerberg will receive ?? messages, the ??-th message will be received from the friend with ID ?????? (1=??????=10^9).If Mark Zuckerberg receives a message from ?????? in the conversation which is currently displayed on the smartphone then nothing happens: the conversations of the screen do not change and do not change their order, Mark Zuckerberg read the message and continue waiting for new messages.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 200000
#define K 200000
 
int aa[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return aa[i] - aa[j];
}
 
int main() {
	static int ii[N], aa_[N], qq[N];
	static char used[N];
	int n, k, i, n_, head, cnt;
 
	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++) {
		scanf("%d", &aa[i]);
		ii[i] = i;
	}
	qsort(ii, n, sizeof *ii, compare);
	n_ = 0;
	for (i = 0; i < n; ) {
		int a, j;
 
		a = aa[ii[i]];
		j = i + 1;
		while (j < n && aa[ii[j]] == a)
			j++;
		while (i < j)
			aa[ii[i++]] = n_;
		aa_[n_++] = a;
	}
	head = cnt = 0;
	for (i = 0; i < n; i++) {
		int i_;
 
		i_ = aa[i];
		if (used[i_])
			continue;
		if (cnt == k)
			used[qq[cnt--, head++]] = 0;
		used[i_] = 1;
		qq[head + cnt++] = i_;
	}
	printf("%d\n", cnt);
	while (cnt--)
		printf("%d ", aa_[qq[head + cnt]]);
	printf("\n");
	return 0;
}

Question

Sumitha has two arrays ?? and ?? of lengths ?? and ??, respectively.She can perform the following operation arbitrary number of times (possibly zero): She takes some consecutive subsegment of the array and replaces it with a single element, equal to the sum of all elements on this subsegment. For example, from the array [1,10,100,1000,10000] Vasya can obtain array [1,1110,10000], and from array [1,2,3] Vasya can obtain array [6].Two arrays ?? and ?? are considered equal if and only if they have the same length and for each valid ?? ????=????.Sumitha wants to perform some of these operations on array ??, some on array ??, in such a way that arrays ?? and ?? become equal. Moreover, the lengths of the resulting arrays should be maximal possible.Help Sumitha to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays ?? and ?? equal.

Solution

#include <stdio.h>
 
#define ll long long
 void h(){
     printf("*A\n*B\nB = (long long int *)malloc(sizeof(long long int)*m);");
 }
int main(){
	int n,m,i,j;
	scanf("%d",&n);
	ll a[n],s1=0;
	for( i=0;i<n;i++){
		scanf("%lld",&a[i]);
		s1+=a[i];
	}
	scanf("%d",&m);
	ll b[m],s2=0;
	for( i=0;i<m;i++){
		scanf("%lld",&b[i]);
		s2+=b[i];
	}
	if(s1!=s2){
		printf("-1\n");
		return 0;
	}
	int ans=0;
	for(i=0,j=0;i<n && j<m;){
		if(a[i]==b[j]){
			ans++,i++,j++;
		}
		else if(a[i]<b[j]){
			a[i+1]+=a[i];
			i++;
		}
		else{
			b[j+1]+=b[j];
			j++;
		}
	}
	printf("%d\n",ans);
	return 0;
}

Question

Atifa and her friends are out on a hike. She discovers a trail of numbered diamonds. She begins to trace the track and discovers that every two successive diamond numbers differ by one of two values. According to legend, at the end of the trail is a treasure trove. The treasure will be hers if Atifa can estimate the worth of the final diamond.

Example: n=2   a=2  b=3

She finds 2 stones and their differences are a=2 or b=3. We know she starts with a 0 stone not included in her count. The permutations of differences for the two stones are [2,2], [2,3], [3,2] or [3,3] . Looking at each scenario, stones might have [2,4],[2,5],[3,5], or [3,6] on them. The last stone might have any of 4,6 or 6 on its face.

Compute all possible numbers that might occur on the last stone given a starting stone with a 0 on it, a number of additional stones found, and the possible differences between consecutive stones. Order the list ascending.

Solution

#include<stdio.h>
#include<stdlib.h>
void h(){
    printf("*n\n**ans\n*last");
}
int cmpfunc (const void * m, const void * n)
{
    long long int t=(*(long long int*)m - (*(long long int*)n) );
	if(t<0)
	{
		return (-1);
	}
	else if(t>0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int main()
    {
    int k;
    scanf("%d",&k);
    while(k>0)
        {
        long long int arr[1100],n,a,b,i,t;
        scanf("%lld %lld %lld",&n,&a,&b);
        for(i=0;i<n;i++)
            {
            t=(i*a)+((n-i-1)*b);
            arr[i]=t;
        }
        qsort(arr,n,sizeof(long long int),cmpfunc);
        for(i=0;i<n;i++)
            {
            printf("%lld ",arr[i]);
            t=arr[i];
            while(arr[i]==t)
                {
                i++;
            }
            i--;
        }
        printf("\n");
        k--;
    }
    return 0;
}

Question

Rama wants to go veegaland. he was booking in online. They have announced an offer for students. That 50% offer for students. But must be complete the technical question for this offer. that is, An integer 'd' is a divisor of an integer 'n' if the remainder of n ÷ d = 0.Given an integer, for each digit that makes up the integer determine whether it is a divisor. Count the number of divisors occurring within the integer.

Solution

#include <stdio.h>
void h(){
    printf("*ans\n ans=(int *)malloc(t*sizeof(int));");
}
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int N,M,d,c=0;
        scanf("%d",&N); M=N;
        while(N)
        {
            d=N%10;
            N=N/10;
            if(d && M%d==0) c++;
        }
        printf("%d\n",c);
    }
    return 0;
}

Question

A student wants to determine the most expensive computer keyboard and USB drive that can be purchased with a given budget. Given price-lists for keyboards and USB drives and a budget, find the cost to buy them. If it is not possible to buy both items, return -1.Constraints:1 <= n, m <= 10001 <= b <= 10^6The price of each item is in the inclusive range [1, 10^6]

Solution

#include <stdio.h>
#include <stdlib.h>
void h(){
    printf("*usb");
}
int main(){
    int s; 
    int n; 
    int m,i,j,k; 
    scanf("%d %d %d",&s,&n,&m);
    int *keyboards = malloc(sizeof(int) * n);
    for(i = 0; i < n; i++){
       scanf("%d",&keyboards[i]);
    }
    int *pendrives = malloc(sizeof(int) * m);
    for(i = 0; i < m; i++){
       scanf("%d",&pendrives[i]);
    }
    k=-1;
    for(i=0;i<n;i++)
        {
        if(keyboards[i]>=s)
            {
            continue;
        }
        for(j=0;j<m;j++)
            {
            if(keyboards[i]+pendrives[j]<=s&&keyboards[i]+pendrives[j]>k)
                {
                k=keyboards[i]+pendrives[j];
            }
        }
    }
    printf("%d",k);
    return 0;
}

Question

Consider a tunnel on a one-way road. 

During a particular day, ?? cars numbered from 1 to ?? entered and exited the tunnel exactly once. 

All the cars passed through the tunnel at constant speeds.

A traffic enforcement camera is mounted at the tunnel entrance. Another traffic enforcement camera is mounted at the tunnel exit perfectly balanced.

Thanks to the cameras, the order in which the cars entered and exited the tunnel is known. No two cars entered or exited at the same time.

Traffic regulations prohibit overtaking inside the tunnel. If car ?? overtakes any other car ?? inside the tunnel, car ?? must be fined. However, each car can be fined at most once.

Formally, let's say that car ?? definitely overtook car ?? if car ?? entered the tunnel later than car ?? and exited the tunnel earlier than car ??. 

Then, car ?? must be fined if and only if it definitely overtook at least one other car.

Can you find the number of cars that must be fined?

Solution

#include <stdio.h>
#include <stdlib.h>
#define set(n, type) (type*)malloc(sizeof(type) * n)
#define f(n1, n2) n1 > n2 ? n1 : n2
void h(){
    printf("unsigned int m;");
}
int main() {
	int n;
	scanf("%d", &n);
	int *nums = set(n, int), j = 0;
	for(; j < n; ++ j) {
		scanf("%d", &nums[j]);
	}
	int index[100000] = {-1};
	for(j = 0; j < n; ++ j) {
		int num;
		scanf("%d", &num);
		index[num - 1] = j;
	}
	int count = 0, max = 0;
	for(j = 0; j < n; ++ j) {
		int val = index[nums[j] - 1];
		count += val < max;
		max = f(max, val);
	}
	printf("%d", count);
	return 0;
}

Question

Suresh and his brother love each other a lot. As they are super geeks, they only like to play with arrays. They are given two arrays a and b by their father. The array a is given to Suresh and b to his brother.As Suresh is really a naughty kid, he wants the minimum value of his array a should be at least as much as the maximum value of his brother's array b.Now you have to help Suresh in achieving this condition. You can perform multiple operations on the arrays. In a single operation, you are allowed to decrease or increase any element of any of the arrays by 1. Note that you are allowed to apply the operation on any index of the array multiple times.You need to find minimum number of operations required to satisfy Suresh's condition so that the brothers can play peacefully without fighting.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	200000
#define M	200000
 
long long min(long long a, long long b) { return a < b ? a : b; }
 
void srand_() {

}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
struct C {
	int c, ab;
} cc[N + M];
 
int compare(const void *a_, const void *b_) {
	struct C *a = (struct C *) a_;
	struct C *b = (struct C *) b_;
	
	return a->c - b->c;
}
 
int main() {
	int n, m, i, j, acnt, bcnt, c;
	long long asum, bsum, ans;
 
	srand_();
	scanf("%d%d", &n, &m);
	for (i = 0; i < n; i++) {
		struct C *c_ = &cc[i];
 
		scanf("%d", &c_->c);
	}
	bsum = 0;
	for (i = n; i < n + m; i++) {
		struct C *c_ = &cc[i];
 
		scanf("%d", &c_->c);
		bsum += c_->c;
	}
	for (i = 0; i < n + m; i++) {
		struct C tmp;
 
		j = rand_(i + 1);
		tmp = cc[i], cc[i] = cc[j], cc[j] = tmp;
	}
	qsort(cc, n + m, sizeof *cc, compare);
	asum = 0;
	acnt = 0, bcnt = m;
	ans = 0x3f3f3f3f3f3f3f3fLL;
	for (i = 0; i < n + m; i++) {
		c = cc[i].c;
		if (cc[i].ab == 0) {
			acnt++;
			asum += c;
		} else {
			bcnt--;
			bsum -= c;
		}
		ans = min(ans, (long long) c * acnt - asum + bsum - (long long) c * bcnt);
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Lesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer ai — the current skill level. All skills have the same maximum level A.



Along with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:



The number of skills that a character has perfected (i.e., such that ai = A), multiplied by coefficient cf.

The minimum skill level among all skills (min ai), multiplied by coefficient cm.

Now Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.



Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	100000
void h(){
    printf("struct timeval tv;");
}
long long min(long long a, long long b) { return a < b ? a : b; }
 
int aa[N];
 
void srand_() {
}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return aa[i] - aa[j];
}
 
int main() {
	static long long dd[N];
	static int ii[N];
	int n, a_, a, cf, cm, i, j, tmp;
	long long m, sum, ans;
 
	srand_();
	scanf("%d%d%d%d%lld", &n, &a_, &cf, &cm, &m);
	for (i = 0; i < n; i++) {
		scanf("%d", &aa[i]);
		ii[i] = i;
	}
	for (i = 0; i < n; i++) {
		j = rand_(i + 1);
		tmp = ii[i], ii[i] = ii[j], ii[j] = tmp;
	}
	qsort(ii, n, sizeof *ii, compare);
	sum = 0;
	for (i = 0; i < n; i++) {
		a = aa[ii[i]];
		dd[i] = (long long) i * a - sum;
		sum += a;
	}
	if ((long long) a_ * n - sum <= m) {
		ans = (long long) n * cf + (long long) a_ * cm;
		for (i = 0; i < n; i++)
			aa[i] = a_;
	} else {
		long long c, b, f;
		int i_, j_, b_;
 
		ans = -1;
		c = 0, i_ = j_ = -1;
		for (i = n - 1, j = n - 1; i >= 0; i--) {
			if (j > i)
				j = i;
			while (j >= 0 && dd[j] > m)
				j--;
			b = min(aa[ii[j]] + (m - dd[j]) / (j + 1), a_);
			f = c + b * cm;
			if (ans < f) {
				ans = f;
				i_ = i, j_ = j, b_ = b;
			}
			if ((m -= a_ - aa[ii[i]]) < 0)
				break;
			c += cf;
		}
		while (++i_ < n)
			aa[ii[i_]] = a_;
		while (j_ >= 0)
			aa[ii[j_--]] = b_;
	}
	printf("%lld\n", ans);
	for (i = 0; i < n; i++)
		printf("%d ", aa[i]);
	printf("\n");
	return 0;
}

Question

Harland Sanders wants to celebrate his first big salary by going to KFC. However, he needs company.Harland Sanders has n friends, each friend will agree to go to the restaurant if Harland Sanders asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Harland Sanders. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Harland Sanders doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Harland Sanders wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 100000
 
int mm[N], ss[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return mm[i] - mm[j];
}
 
int main() {
	static int ii[N];
	int n, d, i, j;
	long long f, ans;
 
	scanf("%d%d", &n, &d);
	for (i = 0; i < n; i++) {
		scanf("%d%d", &mm[i], &ss[i]);
		ii[i] = i;
	}
	qsort(ii, n, sizeof *ii, compare);
	ans = 0;
	for (i = j = f = 0; i < n; i++) {
		while (j < n && mm[ii[j]] - mm[ii[i]] < d)
			f += ss[ii[j]], j++;
		if (ans < f)
			ans = f;
		f -= ss[ii[i]];
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Polycarp studies at the university in a group that consists of n students (including himself). All they are registered in the social net "TheContacnt!".Not all students are equally sociable. About each student, you know the value ai — the maximum number of messages which the i-th student agrees to send per day. The student can't send messages to himself.In the early morning, Polycarp knew important news that the programming credit will be tomorrow. For this reason, it is necessary to urgently inform all groupmates about this news using private messages.Your task is to make a plan of using private messages, so that:the student i sends no more than ai messages (for all i from 1 to n);all students knew the news about the credit (initially only Polycarp knew it);the student can inform the other student only if he knows it himself.

Solution

#include <stdio.h>
#include <stdlib.h>
 
int poryadok(int *a, int *q, int n){
int i, k;
i = 0;
while(i < (n - 1)){
	if(a[i] < a[i + 1] && i == 0){
		k = a[i+1];
		a[i+1] = a[i];
		a[i] = k;
		k = q[i+1];
		q[i+1] = q[i];
		q[i] = k;
	}
	else if(a[i] < a[i + 1]){
		k = a[i+1];
		a[i+1] = a[i];
		a[i] = k;
		k = q[i+1];
		q[i+1] = q[i];
		q[i] = k;
		i -= 1;
	}
	else i++;
}
return 1;
}
 
int main(){
	int n, *a, i, *ind, sum, l;
	scanf("%d", &n);
	a = (int *)malloc(n*sizeof(int));
	ind = (int *)malloc(n*sizeof(int));
	for(i = 0; i < n; i++){
		scanf("%d", &a[i]);
		ind[i] = i+1;
		sum += a[i];
	}
	if(a[0] == 0 || sum < n - 1) printf("%d", -1);
	else{
		poryadok(a + 1, ind + 1, n - 1);
		printf("%d\n", n - 1);
		l = 1;
		i = 0;
		while(l < n){
			if(a[i] == 0) i++;
			a[i]--;
			printf("%d %d\n", ind[i], ind[l]);
			l++;
		}
	}
return 0;}

Question

Due to the increase in the number of students of Berland State University, it was decided to equip a new computer room. You were given the task of buying mouses, and you have to spend as little as possible. After all, the country is in crisis!The computers bought for the room were different. Some of them had only USB ports, some — only PS/2 ports, and some had both options.You have found a price list of a certain computer shop. In it, form mouses it is specified the cost and the type of the port that is required to plug the mouse in (USB or PS/2). Each mouse from the list can be bought at most once.You want to buy some set of mouses from the given price list in such a way so that you maximize the number of computers equipped with mouses (it is not guaranteed that you will be able to equip all of the computers), and in case of equality of this value you want to minimize the total cost of mouses, you will buy.

Solution

#include <stdio.h>
#include <stdlib.h>
 
typedef struct mouse
{
    int cost;
    char port[5];
} mouse;
 
int cmpfunct(const void *x, const void *y)
{
    return ((mouse *)x)->cost - ((mouse *)y)->cost;
}
 
int main()
{
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    getchar();
    int m, i;
    mouse m_arr[300001];
    scanf("%d", &m);
    for (i=0; i<m; i++)
        scanf("%d %s", &(m_arr[i].cost), m_arr[i].port);
    qsort(m_arr, m, sizeof(mouse), cmpfunct);
    unsigned long long total_sum = 0;
    int total_cnt = 0;
    for (i=0; i<m; i++)
    {
        if (a+b+c == 0) break;
 
        if (m_arr[i].port[0] == 'U')
        {
            if (a)
            {
                a--;
                total_sum+=m_arr[i].cost;
                total_cnt++;
            }
            else if (c)
            {
                c--;
                total_sum+=m_arr[i].cost;
                total_cnt++;
            }
        }
        else
        {
            if (b)
            {
                b--;
                total_sum+=m_arr[i].cost;
                total_cnt++;
            }
            else if (c)
            {
                c--;
                total_sum+=m_arr[i].cost;
                total_cnt++;
            }
        }
    }
    printf("%d %lld", total_cnt, total_sum);
 
    return 0;
}

Question

Javatpoint is a wonderful platform and one its feature shows how much someone contributes to the community. Every registered user has a contribution — an integer number, not necessarily positive. There are n registered users and the i-th of them has contribution ti.Sundaris a little polar bear and he's new into competitive programming. He doesn't even have an account in Javatpoint, but he is able to upvote existing blogs and comments. We assume that every registered user has infinitely many blogs and comments.Sundar can spend b minutes to read one blog and upvote it. Author's contribution will be increased by 5.Sundar can spend c minutes to read one comment and upvote it. Author's contribution will be increased by 1.Note that it's possible that Sundar reads blogs faster than comments.Sundar likes ties. He thinks it would be awesome to see a tie between at least k registered users. To make it happen he is going to spend some time on reading and upvoting. After that, there should exist an integer value x that at least k registered users have contributed exactly x.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define N 200000
#define INF 0x3f3f3f3f3f3f3f3fLL
long long min(long long a, long long b){return a<b?a:b; }
int cmp(const void *a,const void *b){
    int ia = *(int *) a;
    int ib = *(int *) b;
    return (ia-ib);}
long long xx[N];
int qu[5][N], head[5], cnt[5];
void add(int h, int i){
    qu[h][head[h]+cnt[h]++]=i;}
int rem_first()
{
    int h, h_=-1,i_=-1;
    for(h=0;h<5;h++)
    if (cnt[h]){
        int i=qu[h][head[h]];
        if(i_==-1 || xx[i_]<xx[i])
        h_=h,i_=i;
    }
    cnt[h_]--,head[h_]++;
	return i_;}
int main(){
    static int aa[N];
    int n,m,i,s;
    long long b,c,ans;
    scanf("%d%d%lld%lld",&n,&m,&b,&c), b=min(b,c*5);
    for(i=0;i<n;i++)
    scanf("%d",&aa[i]);
    qsort(aa,n,sizeof *aa,cmp);
    ans=INF;
    for(s=0;s<5;s++){
        long long x=0;
        memset(head,0,sizeof head),memset(cnt,0,sizeof cnt);
        for(i=0;i<n;i++){
            int r=(aa[i]%5+5)%5;
            int k=(s-r+5)%5;
            int l=(aa[i]+k-s)/5;
            
            xx[i]=c*k-b*l;
            add(k,i),x+=xx[i];
            if(i>=m)
            x-=xx[rem_first()];
            if(i>=m -1)
            ans=min(ans,x+b*l*m);
        }}
    printf("%lld\n",ans);
    return 0;}

Question

Anton is playing a very interesting computer game, but now he is stuck at one of the levels. To pass to the next level he has to prepare n potions.Anton has a special kettle, that can prepare one potion in x seconds. Also, he knows spells of two types that can faster the process of preparing potions.Spells of this typing speed up the preparation time of one potion. There are m spells of this type, the i-th of them costs bi manapoints and changes the preparation time of each potion to ai instead of x.Spells of this type immediately prepare some number of potions. There are k such spells, the i-th of them costs di manapoints and instantly create ci potions.Anton can use no more than one spell of the first type and no more than one spell of the second type, and the total number of manapoints spent should not exceed s. Consider that all spells are used instantly and right before Anton starts to prepare potions.Anton wants to get to the next level as fast as possible, so he is interested in the minimum number of time he needs to spent in order to prepare at least n potions.

Solution

#include <stdio.h>
 
int A(int *ZA, int a, int b, int c) {
 int d;
 
 if (a > b)
  return b;
 d = a + (b - a + 1) / 2;
 if (ZA[d] <= c)
  return A(ZA, d + 1, b, c);
 else
  return A(ZA, a, d - 1, c);
}
 
int main()
{
 long long a, b, c, d, e, f, g, h, j;
 int ZA[200000], ZB[200000], ZC[200000], ZD[200000];
 
 scanf("%lld%lld%lld%lld%lld", &a, &b, &c, &d, &e);
 for (f = 0; f < b; ++f)
  scanf("%d", &ZA[f]);
 for (f = 0; f < b; ++f)
  scanf("%d", &ZB[f]);
 for (f = 0; f < c; ++f)
  scanf("%d", &ZC[f]);
 for (f = 0; f < c; ++f)
  scanf("%d", &ZD[f]);
 g = a * d;
 h = d;
 for (f = 0; f < b; ++f)
  if (ZB[f] <= e && ZA[f] < h)
   h = ZA[f];
 g = a * h;
 f = A(ZD, 0, c - 1, e);
 if (f >= 0) {
  if (ZC[f] >= a)
   g = 0;
  else if (g > (a - ZC[f]) * d)
   g = (a - ZC[f]) * d;
 }
 for (f = 0; f < b; ++f) {
  if (ZB[f] <= e) {
   j = A(ZD, 0, c - 1, e - ZB[f]);
   if (j >= 0) {
    if (a <= ZC[j])
     g = 0;
    else if (g > (a - ZC[j]) * ZA[f])
     g = (a - ZC[j]) * ZA[f];
   }
  }
 }
 printf("%lld\n", g);
 
 return 0;
}

Question

Natarajan is a very experienced olympiads participant. He has n cups for Physics olympiads and m cups for Informatics Olympiads. Each cup is characterized by two parameters — its significance ci and width wi.Natarajan decided to expose some of his cups on a shelf with width d in such a way, that:there is at least one Physics cup and at least one Informatics cup on the shelf,the total width of the exposed cups does not exceed d,from each subject (Physics and Informatics) some of the most significant cups are exposed (i. e. if a cup for some subject with significance x is exposed, then all the cups for this subject with significance greater than x must be exposed too).Your task is to determine the maximum possible total significance, which Stepan can get when he exposes cups on the shelf with width d, considering all the rules described above. The total significance is the sum of the significance of all the exposed cups.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define MAXN 100001
 
struct Cup
{
    long long c;
    long long w;
};
struct Cup a[2][MAXN], sum[2][MAXN];
long long ans;
 
int comp(const void *a,const void *b)
{
    struct Cup *pa = (struct Cup *)a;
    struct Cup *pb = (struct Cup *)b;
 
    if(pa->c != pb->c)
        return pb->c - pa->c;
    else
        return pa->w - pb->w;
}
 
long long max(long long a, long long b)
{
    return a > b ? a : b;
}
 
int main()
{
    int n[2], d,k,i,j;
    scanf("%d%d%d", &n[0], &n[1], &d);
    for( k = 0; k < 2; ++k)
    {
        for( i = 0; i < n[k]; ++i) scanf("%lld%lld", &a[k][i].c, &a[k][i].w);
        qsort(a[k], n[k], sizeof(a[k][0]), comp);
        sum[k][0] = a[k][0];
        for( i = 1; i < n[k]; ++i) sum[k][i].c = sum[k][i - 1].c + a[k][i].c, sum[k][i].w = sum[k][i - 1].w + a[k][i].w;
    }
 
    for( i = 0, j = n[1] - 1; i < n[0]; ++i)
    {
        while(j >= 0 && sum[0][i].w + sum[1][j].w > d) --j;
        if(j < 0) break;
        ans = max(ans, sum[0][i].c + sum[1][j].c);
    }
 
    printf("%lld\n", ans);
 
    return 0;
}

Question

Thannuthu and Senthamangalam villages are separated by a Thamirabarani river that flows from the north to the south. The villagers want to build a bridge across the river to make it easier to move across the villages.The river banks can be assumed to be vertical straight lines x = a and x = b (0 < a < b).The Thannuthu lies in a steppe at point O = (0, 0). There are n pathways leading from the village to the river, they end at points Ai = (a, yi). The villagers there are plain and simple, so their pathways are straight segments as well.The Senthamangalam village has reserved and cunning people. Their village is in the forest on the east bank of the river, but its exact position is not clear. There are m twisted paths leading from this village to the river and ending at points Bi = (b, y'i). The lengths of all these paths are known, the length of the path that leads from the eastern village to point Bi, equals li.The villagers want to choose exactly one point on the left bank of river Ai, exactly one point on the right bank Bj and connect them by a straight-line bridge so as to make the total distance between the villages (the sum of |OAi| + |AiBj| + lj, where |XY| is the Euclidean distance between points X and Y) were minimum. The Euclidean distance between points (x1, y1) and (x2, y2) equals 



Solution

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
 
#define sq(A) ((A)*(A))
 
typedef long long LL;
typedef long double LD;
typedef struct{
	LL y;
	int num;
} Point;
 
int comp(const void * a,const void * b)
{
	return ((Point*)a)->y-((Point*)b)->y;
}
 
const LD eps=1e-7;
 
Point points[100000], ends[100000];
LD a, b;
 
LD dist(int i, int j){
	return sqrt(sq(points[i].y)+sq(a))+sqrt(sq(points[i].y-ends[j].y)+sq(b-a));
}
 
int main(){
	int n, m, i, l, r, mid, bi, bj, tmp;
	LD bestdist=1000000000.0, cdist;
	scanf("%d %d", &n, &m);
	scanf("%d", &tmp); a=tmp;
	scanf("%d", &tmp); b=tmp;
	for(i=0;i<n;++i){
		scanf("%lldd", &points[i].y);
		points[i].num=i+1;
	}
	qsort(points, n, sizeof(Point), comp);
	for(i=0;i<m;++i) scanf("%lldd", &ends[i].y);
	for(i=0;i<m;++i){
		scanf("%d", &ends[i].num);
		cdist=ends[i].num;
		l=0;
		r=n;
		while(l+4<r){
			mid=(l+r)/2;
			if(dist(mid, i)<dist(mid+1, i)) r=mid+1;
			else l=mid+1;
		}
		for(mid=l+1;mid<r;++mid) if(dist(mid, i)<dist(l, i)) l=mid;
		cdist+=dist(l, i);
		if(cdist<bestdist+eps){
			bestdist=cdist;
			bi=points[l].num;
			bj=i+1;
		}
	}
	printf("%d %d\n", bi, bj);
	return 0;
}

Question

Problem Description:Ramanujan studies mathematics. He tries to group objects by their rang (a positive integer associated with each object). 

He also gives the formula for calculating the number of different objects with rang N as following:The number of different objects with rang N = F(N) = A0 + A1 * N + A2 * N2 + A3 * N3.Now Ramanujan wants to know how many different multisets of these objects exist such that sum of rangs of the objects in the multiset equals to S. 

You are given the coefficients in F(N) and the target sum S. 

Please, find the number of different multisets modulo 1,000,000,007.You should consider a multiset as an unordered sequence of integers. 

Two multisets are different if and only if there at least exists one element which occurs X times in the first multiset but Y times in the second one, where (X ? Y).

Solution

#include<stdio.h>
#define mod 1000000007
int inv[101];
int nck[101][101],dp[101][101];
int findinv(int a) {
	int c = 1,b = mod - 2;
	while (b) {
		if (b & 1) {
			c = 1LL * c*a%mod;
		}
		a = 1LL * a*a%mod;
		b >>= 1;
	}
	return c;
}
void init() {
	int i;
	inv[1] = 1;
	for (i = 2; i <= 100; i++) {
		inv[i] = findinv(i);
	}
}
int main() {
	int t,i,j,a,b,c,d,s,k;
	long long n;

	scanf("%d", &t);
	init();
	while (t--) {
		scanf("%d %d %d %d %d", &a,&b,&c,&d,&s);
		for (i = 1; i <= s; i++) {
			n = a + b*i + c*i*i + d*i*i*i;
			nck[i][0] = 1;
			for (j = 1; i*j <= s; j++) {
				nck[i][j] = 1LL * nck[i][j - 1] * (n + j - 1) % mod*inv[j] % mod;
			}
		}
		dp[0][0] = 1;
		for (i = 1; i <= s; i++) {
			dp[0][i] = 0;
		}
		for (i = 1; i <= s; i++) {
			for (j = 0; j <= s; j++) {
				dp[i][j] = 0;
				for (k = 0; j >= k*i; k++) {
					dp[i][j] = (dp[i][j] + 1LL*nck[i][k]*dp[i - 1][j - k*i]%mod) % mod;
				}
			}
		}
		printf("%d\n",dp[s][s]);
	}

	return 0;
}

Question

Rohan is facing a tricky problem with balancing parenthesis.In general the balanced parenthesis string is defined as follows:The empty string is balancedIf P is balanced, (P) is alsoIf P and Q are balanced, PQ is also balanced

Rohan is given two even integers n and k. 

His task is to find any balanced parenthesis string of length n that doesn't contain a balanced substring of length k, or claim that no such string exists.

Rohan is finding it difficult to solve this problem can you help him?

Solution

#include <stdio.h>
#include<stdlib.h>
int exists(int, int);
void paranthesis(int, int);
struct para{
    int n,k;
};
typedef struct para para;
int main(void) {
	int t, flag;
	int i ;
	scanf("%d", &t);
	para* p = (para*)malloc(t*sizeof(para));
	while(t>0 && i<t)
	{
        scanf("%d%d", &p[i].n, &p[i].k);
        i++;
	}
	for( i = 0; i<t; i++)
	{
	    flag = exists(p[i].n, p[i].k);
        if(flag)
            paranthesis(p[i].n, p[i].k);
        else
        {   
            int e = -1;
            printf("%d\n", e);
        }
	}
	return 0;
}

int exists(int n, int k)
{
    if((n%2==0) && (n!=0)){
        if(k!=2 && k!=4 && n!=k)
            return 1;
        else
            return 0;
    }
    else
        return 0;
}

void paranthesis(int n, int k)
{
    int a = k-2, b = n/a, c = n%a, d = 0,i;
    if(a+c == k)
{
        printf("(");
        while(d!=b)
        {   
            
            for(i = 1; i<=a; i++)
            {
                if(i<=a/2)
                    printf("(");
                else
                    printf(")");
            }
            d++;
        }
        printf(")\n");
        return;
    }
    while(d!=b)
    {
        for( i = 1; i<=a; i++)
        {
            if(i<=a/2)
                printf("(");
            else
                printf(")");
        }
        d++;
    }
    for( i = 1; i<=c; i++)
    {
        if(i<=c/2)
            printf("(");
        else
            printf(")");
    }
    printf("\n");
}

Question

South Indian Superstar Ajith Kumar is an multitalented person who is also an F1 Racer. 

There is an upcoming race this year for which Ajith is having his trails.In the circular racetrack that is prepared for the trails a number of traffic cones have been placed to form an obstacle course. You are asked to determine the largest sized car that can navigate the course. For simplicity, the cones are assumed to have zero width and the car is perfectly circular and infinitely maneuverable.

 The track itself is the area between 2 concentric circles.

Formally, the course can be navigated by a car of radius c if there exists a closed loop around the center of the track which lies between the circles forming the track, and every point on the loop is at least c distance away from each cone and each boundary of the track.

Solution

#include <stdio.h>
#include<math.h>
//usong namespace std;
#define S(X) ((X)*(X))
#define MAX(A,B) ((A)>(B)?(A):(B))
#define MIN(A,B) ((A)<(B)?(A):(B))
double d[600];
double x[600],y[600];
int done[600];
int main(void)
{
int T,i,n,r,R;
int id;
scanf("%d",&T);
while(T--)
{
    scanf("%d%d",&r,&R);
    scanf("%d",&n);
    for(i=0;i<n;i++)
    scanf("%lf%lf",&x[i],&y[i]);
    for(i=0;i<n;i++)
    {
        d[i]=sqrt( S(x[i])+S(y[i]) )-r;
        done[i]=0;
    }
    done[n]=0;
    d[n]=R-r;
    while(1)
    {
        id=-1;
        for(i=0;i<=n;i++)
        if(!done[i] && (id==-1 || d[id]>d[i]))
        id=i;
        if(id==n) break;
        done [id]=1;
        for(i=0;i<n;i++)
        if(!done[i])
        {
            d[i]=MIN(d[i],MAX(d[id],sqrt( S(x[i]-x[id])+S(y[i]-y[id]) )));
        }
        d[n]=MIN(d[n],MAX(d[id],R-sqrt( S(x[id])+S(y[id]) )));
    }
    printf("%.3lf\n",d[n]);
}
	return 0;
}

Question

Joslyn has given five positive integers to Darsh and asked him to find the minimum and maximum values that can be calculated by summing exactly four of the five integers. 

Can you help Darsh in finding the respective minimum and maximum values?

Solution

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
void h(){
    printf("int* arr=malloc(5*sizeof(int));");
    printf("realloc");
}
int main() {

    long long int a;
    int i;
    long long int sum=0;
    long long int min=INT_MAX;
    long long int max=INT_MIN;
    for(i=0;i<5;i++)
    {
        scanf("%lli",&a); 
        sum+=a;
        if(a<min)
            min=a;
        if(a>max)
            max=a;
    }
    printf("%lli %lli",sum-max,sum-min);
    return 0;
}

Question

Dhuruv has the set of values and now he would like to find the minimum absolute difference between them.

The absolute difference is the positive difference between two values 'x' and 'y', is written "|x-y| or |y-x|" and they are equal. 

If x=3 and y=2, |3 - 2| = |2 - 3| =1. 

Given the set of integers, Dhuruv would like to find the minimum absolute difference between any two elements in the given set. Can you help him finding it?

Solution

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void h(){
    printf("a=(long int *)malloc(n*sizeof(long int));\nlong int *a");
}
int cmpfunc (const void * a, const void * b)
{
   return ( *(int*)a - *(int*)b );
}

int main(){
    int n,min,i; 
    scanf("%d",&n);
    int a[n];
    for(i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    qsort(a, n, sizeof(int), cmpfunc);
    min=a[1]-a[0];
    for(i=0;i<n-1;i++){
        if(min>(a[i+1]-a[i])){
            min=(a[i+1]-a[i]);
        }
    }
    printf("%d",min);
    return 0;
}

Question

Rohan wants to play with his friends today. But his babysitter won't let him go! 

After a lot of begging, the heartless nanny gives him her brand new electronic puzzle and says: "If you solve the puzzle then you are free to go". 

Not being aware of Rohan IT skills, the Rani leaves the kid alone.Rapidly, Rohan sends you an e-mail asking for your help.The puzzle consists of three hexagons as shown in the figure. Each vertex is painted black or white. 

Some of them belong to just one hexagon and some of them belong to more than one. 

Exactly four of them are painted black, and the other nine are white. 

The goal is to make the shared vertexes

Solution

#include <stdio.h>
#define MX 13
#define NS 715
 
int se[NS], pi[NS], pm[NS], cu,n;
char pu[MX+1];
const int bi[]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096};
const int mo[6][7]={{10,12,9,6,4,7,10},{10,7,4,6,9,12,10},{5,3,6,9,11,8,5},{5,8,11,9,6,3,5},{4,6,3,1,0,2,4},{4,2,0,1,3,6,4}};
const int go=0x258;
 
int f1(int m, int p)
{
int c=p, i=0;
for(; i++<6; c=((p&bi[mo[m][i]]))?(c|bi[mo[m][i-1]]):(c&(~bi[mo[m][i-1]])));
return c;
}
 
int f2(int c)
{
int i;
for(i=cu-1; i>=0; i--)
	if(c==se[i])
		return i;
return -1;
}
 
int f3(char p[])
{
int i=0, s=0;
for(; i<MX; s=(p[i]=='1')?(s|bi[MX-i-1]):s, i++);
return s;
}
 
void f4(int s)
{
int i=0, j, p[12], in=f2(s);
for(; in; p[i++]=pm[in], in=pi[in]);
for(printf("%d\n",i+(j=0)); j++<i; printf("%d %d\n",(p[j-1]>>1),(p[j-1]%2)));
}
 
int main()
{
int fall, p=0, m, c;
 
for(se[!(cu=1)]=go; p<cu; p++)
	for(m=0; m<6; m++)
		if(f2(c=f1(m,se[p]))==-1)
			{
			se[cu]=c;
			pi[cu]=p;
			pm[cu++]=m^0x1;
			}
for(scanf("%d",&fall); fall--;)
	{
	scanf("%s",pu);
	f4(f3(pu));
	}
 
return 0;
}

Question

Simon has given an array of integers [A1,A2,…,AN] to Suman. 

Let's call adding an element to this array at any position (including the beginning and the end) or removing an arbitrary element from it a modification. 

It is not allowed to remove an element from the array if it is empty.Here your task is to find the minimum number of modifications which must be performed so that the resulting array can be partitioned into permutations. 

Formally, it must be possible to partition elements of the resulting array into zero or more groups (multisets; not necessarily identical) in such a way that each element belongs to exactly one group and for each group, if it contains L elements, then it must contain only integers 1 through L, each of them exactly once.

Solution

#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int main()
{
    int t,i,j;
    scanf("%d", &t);
    while (t--) {
        long int n, temp, result=0;
        long int *elements;
        scanf("%li", &n);
        elements =calloc(2*n+1,sizeof(int*));
        for (i=0; i<n; i++) {
            scanf("%li", &temp);
            if (temp>2*n) ++result;
            else ++elements[temp];
        }
        long int *arr1, *arr2 = NULL;
        arr1 = calloc((2*n)+1, sizeof(long int));
        for (i=1; i<=(2*n); i++) {
            arr2 = calloc(2*n/i+1, sizeof(long int));
            for (j =0;j<=(2*n/i);j++)
                arr2[j] = arr1[j] + fabs(elements[i]-j);
            for (j=(2*n/i)-1;j>=0;j--)
                arr2[j]=(arr2[j] < arr2[j+1])?arr2[j]:arr2[j+1];
            arr1 = arr2;
        }
        result +=(arr2[0]<arr2[1])?arr2[0]:arr2[1];
        printf("%li\n", result);
    }
    return 0;
}

Question

New Zealand is a country with a number of evenly spaced cities along a line. 

The distance between adjacent cities is '1' unit. 

There is an energy infrastructure project planning meeting, and the government needs to know the fewest number of power plants needed to provide electricity to the entire list of cities. 

Determine that number. If it cannot be done, return -1.You are given a list of city data. Cities that may contain a power plant have been labeled '1'. 

Others not suitable for building a plant are labeled '0'. 

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int n,k,*suitability,i, torch =0;
    scanf("%d %d",&n,&k);
    suitability=(int *)malloc(n*sizeof(int));
    for(i=0;i<n;i++)
        scanf("%d",&suitability[i]);
    for(i=0;i<n;)
    {
        int range = k-1,check=0,j;
        for(j=i+range;j>=i-range;j--){
            if(j<=n-1&&j>=0)
            if(suitability[j]==1)
            {
                torch++;
                i=j+range+1;
                check=1;
                break;
            }
        }
        if(check==0){
            printf("-1\n");
            exit(0);}
    }
    printf("%d\n",torch);
return 0;}

Question

A new strain of Corona has broken out. 

Fortunately, a vaccine was developed very quickly and is now being administered to the public. 

Your local health clinic is administering this vaccine, but the waiting line is very long.For safety reasons, people are not allowed to stand very close to each other as the Corona is not under control yet. However, many people were not aware of this precaution. 

A health and safety official recently examined the line and has determined that people need to spread out more in the line so that they are at least T units away from each other. 

This needs to be done as quickly as possible so we need to calculate the minimum distance D such that it is possible for every person to move at most D units so the distance between any two people is at least T. 

Solution

# include<stdio.h>

# define MAX 10000

#define max(a,b) (a>b)?a:b

double a[MAX];

const double EPS = 1e-8;

int n;

int solve(int n,double t,double d)

{

int i;

double x=max(0.0,a[0]-d) ;

for (i = 1; i < n; ++i) {

if (a[i]+d<x+t) return 0;

x = max(a[i]-d,x+t);

}

 

return 1;

}

int main()

{

int test,i;

double t,l,h;

scanf("%d",&test);

while(test--)

{

scanf("%d%lf",&n,&t);

for(i=0;i<n;i++)

scanf("%lf",&a[i]);

l=0;

h=1;

while(!solve(n,t,h))

h=h*2;

while (l+EPS<h) {

double mid = (l+h)/2;

if (solve(n,t,mid)) h = mid;

else l = mid;

}

printf("%.4lf\n", l);

}

return 0;

}

Question

Tina has a string A consisting of n lower case English letters.Tina calls two strings X and Y each of length n similar if they can be made equal by applying the following operation at most once in each of them.Chose any two position i, j in the string (i can be equal to j too). Swap the characters at position i with character at position j.Now Tina is interested in finding number of ordered pairs of non similar strings X and Y such that they can be constructed from a given string A by permutation of its characters. As answer could be large, please output your answer modulo (109 + 7).

Solution

#include<stdio.h>
#include<string.h>
#define m 1000000007
long long f[100009];
#define ll long long

long long power(long long a,long long b)
{
    long long int ans=1;
    a=a%m;
    while(b!=0)
    {
        if(b%2==1)
          ans=(ans*a)%m;
        a=(a*a)%m;
        b=b/2;
    }
    return ans;
}

long long cal(long long n,long long r)
{
    long long ans;
    ans=f[n];
    if(n<r)
      return 0;
    ans = ((ans*power(f[r],m-2))%m);
    ans=((ans*power(f[n-r],m-2))%m);
    ans = (ans%m+m)%m;
    return (ans+m)%m;
}

long long calsingle(int *a,int length)
{
    long long ans;
    int i;
    ans=cal(length,2);
    for(i=0;i<26;i++)
        ans = ans- cal(a[i],2);
    return ans;
}

long long caldouble(int *a)
{
    long long ans=0,r1,r2,r3,r4;
    int i,j,k,l;
    for(i=0;i<26;i++)
    {
        r1=a[i];
        for(j=i+1;j<26;j++)
        {
            r2=a[j];
            ans = (ans+ cal(r1,2)*cal(r2,2))%m;
            for(k=j+1;k<26;k++)
            {
                r3=a[k];
                ans =(ans+r1*r2*r3*(r1+r2+r3-1))%m;
                for(l=k+1;l<26;l++)
                {
                   r4=a[l];
                   ans=(ans+r1*r2*r3*r4*3)%m;
                }
            }
        }
    }
    ans=(ans+1)%m;
    return ans;
}


long long total(int *a,int length)
{
    int i;
    long long ans;
    ans=f[length];
    for(i=0;i<26;i++)
      if(a[i]>1)
        ans=(ans*power(f[a[i]],m-2))%m;
    return ans%m;
}


void pre()
{
    int i;
    f[0]=1;
    for(i=1;i<100006;i++)
       f[i]=(i*f[i-1])%m;
}

int main(){
    int t;
    long long tot,s,d,ms,ans;
    pre();
    scanf("%d",&t);
    while(t--){
        char str[100005];
        int i,a[26];
        for(i=0;i<26;i++)
          a[i]=0;
        scanf("%s",str);
        int length=strlen(str);
        for(i=0;str[i]!='\0';i++)
          a[str[i]-'a']++;
        tot=total(a,length);
        s = calsingle(a,length);
        d = caldouble(a);
        ms= ((tot-s-d)%m+m)%m;
        ans = (ms*tot)%m;
        printf("%lld\n",ans);
    }
    return 0;
}

Question

Before the outbreak of SARA CoV-2 to the world, a meeting happened in a room in Germany. 

A person who attended that meeting had SARA CoV-2 and no one in the room knew about it! 

So everyone started shaking hands with everyone else in the room as a gesture of respect and after meeting unfortunately every one got infected! 

Given the fact that any two persons shake hand exactly once, Can you tell the total count of handshakes happened in that meeting?

Solution

#include<stdio.h>
int main()
{
    int t,k,n;
    scanf("%d",&t);
    while(t>0)
    {
        scanf("%d",&n);
        k=(n*(n-1))/2;
        printf("%d\n",k);
        t--;
    }return 0;}

Question

Two players (let's call them A and B) are playing a game on a row of cells. A cell may contain the character 'A', contain the character 'B' or be empty. Each character may only be moved from a cell ci to a cell cf if cell cf and all cells between ci and cf are currently empty. 

The leftmost (first) character may only be moved to the right, the second character may only be moved to the left, the next character to the right, and so on. Each character may be moved any number of times, including zero.The players alternate turns; player A starts. On each turn, the current player must choose a cell containing their own character ('A' for player A, 'B' for player B) and move it to a different cell. 

This cell may be chosen arbitrarily as long as all rules described above are satisfied. The first player that cannot move a character loses.

Solution

#include<stdio.h>
#include<string.h>
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		char str[100005];
		scanf("%s",str);
		int n=strlen(str);
		int xor_value=0,count=0,j,na=0,nb=0,i,t;
		for(i=0;i<n;i++)
		{
			if(str[i]=='.')
			continue;
			if(str[i]=='A')
			{
				t=0;
				if(count%2==0)
				{
					j=i;
					while(str[j+1]=='.')
					{
						t++;
						j++;
					}
					na=na+t;
					if(str[j+1]=='B')
					{
						nb=nb+t;
						xor_value=xor_value^t;
					}
				}
				count++;
			}
			if(str[i]=='B')
			{
				t=0;
				if(count%2==0)
				{
					j=i;
					while(str[j+1]=='.')
					{
						t++;
						j++;
					}
					nb=nb+t;
					if(str[j+1]=='A')
					{
						na=na+t;
						xor_value=xor_value^t;
					}
				}
				count++;
			}
		}	
		if(na==nb)
		{
			if(xor_value==0)
			printf("B\n");
			else
			printf("A\n");
		}	
		else
		{
			if(na>nb)
			printf("A\n");
			else
			printf("B\n");
		}
	}
	return 0;
}

Question

Today John has given a task to Simon, Simon has to travel from cell (1,1) to cell (N,M) in a grid of size N*M. 

But in order make this task interesting for Simon, John has decided to keep some special candies in some K special cells of the grid, where each candy has an amount of happiness associated with it.Simon can travel only in right & down direction in the grid, as he is too careful & does not want to fall out of grid. Now, we call the value of a path the happiness of all cells lying on the path. All non-special cells have happiness equal to 0.Now, you need to find and print the sum of the values of all paths from (1,1) to, (N, M) traveling only right and down to an adjacent cell.As Simon is not good at counting help him find the answer.

Solution

#include<stdio.h>
long long modexp(long long a)
{
	long long ans=1, b=1000000005;
 
	for(;b>0;)
	{
		if((b%2)==1)
		{
			ans=(ans*a)%1000000007;
		}
		b/=2;
		a=(a*a)%1000000007;
	}
	return ans;
}
int main()
{
	long long fac[1000001];
	fac[0]=1;
	fac[1]=1;
	long long i, j, n, m, x, t, k, sum, sum1;
 
	for(i=2; i<=1000000; i++)
	{
		fac[i]=(fac[i-1]*i)%1000000007;
	}
	scanf("%lld", &t);
 
	for(;t--;)
	{
		sum1=0;
		scanf("%lld %lld %lld",&n,&m,&k);
 
		for(;k--;)
		{
			sum=0;
			scanf("%lld %lld %lld", &i, &j, &x);
			i--;j--;
			sum=fac[i+j];
			sum=sum%1000000007;
			sum=sum*modexp(fac[i]);
			sum=sum%1000000007;
			sum=sum*modexp(fac[j]);
			sum=sum%1000000007;
			
			i=n-i-1;
			j=m-j-1;
			sum=sum*fac[i+j];
			sum=sum%1000000007;
			sum=sum*modexp(fac[i]);
			sum=sum%1000000007;
			sum=sum*modexp(fac[j]);
			sum=sum%1000000007;
			
			sum=sum*x;
			sum=sum%1000000007;
			
			sum1=sum1+sum;
			sum1=sum1%1000000007;
		}
		printf("%lld\n", sum1);
	}
 
return 0;}

Question

Sathya is the best coder in Microsoft. His company is organising the inter-company coding contest. 

Being a member of coding club, Sathya is given the responsibility of setting a hard problem for the contest.Vinod also took part in the contest and solved all the problems except the one set by Sathya. 

In order to win the contest, Vinod has to solve all the problems. Vinod was having hard time solving it. 

He hopes you can help him.

Solution

#include <stdio.h>
#define MAX 100
int check(int n,int p){
  if(p &(n-p)) return 0;
  return 1;
}
int main()
{
  long long int n,i,e=0,res,t;
  scanf("%lld",&t);
  while(t--)
  {e=0;
  scanf("%lld",&n);
  for( i=0; i <=n; i++){
  res=check(n,i);
  if(res%2==0) e++;}
  printf("%lld %lld\n",e,n+1-e);
  }
  return 0;
}

Question

A new deadly virus has infected a large population of a planet. A brilliant scientist has discovered a new strain of the virus that can cure this disease. The vaccine produced from this virus has various strength depending on midichlorians count. A person is cured only if midichlorians count in the vaccine batch is more than midichlorians count of the person. A doctor receives a new set of the report which contains midichlorians count of each infected patient, Practo stores all vaccine doctor has and their midichlorians count. You need to determine if the doctor can save all patients with the vaccines he has. The number of vaccines and patients are equal.

Solution

#include <stdio.h>
 
int main()
{
	int N;
	int i;
	scanf("%d",&N);
	int Vaccine[N], Patients[N];
	for ( i = 0; i < N; i++)
	{
		scanf("%d",&Vaccine[i]);
	}
	for ( i = 0; i < N; i++)
	{
		scanf("%d",&Patients[i]);
	}
	if (Vaccine[N] > Patients[N])
	{
		printf("Yes");
	}
	else
	{
		printf("No");
	}
return 0;}

Question

A manufacturing project of the famous firm consists of exactly K tasks. The board overviewing the project wants to hire K teams of workers one for each task. All teams begin working simultaneously.Obviously, there must be at least one person in each team. 

For a team of A workers, it takes exactly A days to complete the task they are hired for. 

Each team acts independently, unaware of the status of other teams (whether they have completed their tasks or not), and submits their result for approval on the A-th day.However, the board approves the project only if all K teams complete their tasks on the same day — it rejects everything submitted on any other day. 

The day after a team finds out that its result was rejected, it resumes work on the same task afresh. 

Therefore, as long as a team of A workers keeps getting rejected, it submits a new result of their task for approval on the A-th, 2A-th, 3A-th day etc.The board wants to hire workers in such a way that it takes exactly X days to complete the project. 

Solution

#include <stdio.h>
#include <math.h>

#define int long long
void h(){
    printf("for(int i=2;i<=sqrt(x);i++)");
}
int min(int a, int b) {
    if (a<b) 
        return a;
    
    return b;
}

int gcd(int n1, int n2) {
    while(n1!=n2)
        if(n1 > n2)
            n1 -= n2;
        else
            n2 -= n1;
    return n1;
}

int getAns(int k, int x){
    if(k==1)
        return x;
    int ans=x+k-1,i;
    
    for(i=2;i<=sqrt(x);i++){
        if(!(x%i)&&gcd(i, x/i)==1){
            ans=min(ans, i+getAns(k-1, x/i));
        }
    }
    return ans;
}

signed main(void) {
	
	int t, k, x;
	scanf("%lld", &t);
	
	while(t--) {
	    scanf("%lld %lld",&k,&x);
	    
	    
	    printf("%lld\n", getAns(k,x));
	}
	
	return 0;
}

Question

One day Danny was walking and realized that her life was boring. 

Everything was grey, even roads in the best park were grey.Therefore she decided to make roads a little bit brighter. 

She knows that every road in the park is a segment laying on the X-axis with coordinates Xl, Xr (Xl = Xr). 

Roads may intersect or overlap.She chooses any subset of roads and paints them in red. 

After that, she wants to get one continuous red segment. As she really likes number L the length of this segment has to be equal to L.Your task is to determine if it is possible to choose some subset of roads and paint them to get one red segment with a length equal to L?If it's possible to print in a single line "Yes"(without quotes), otherwise print "No" (without quotes).

Solution

#include <stdio.h>
void bubble(int a[],int n);
int main()
{
	int t;
	scanf("%d",&t);
	while(t>0)
	{
		int n,l;
	scanf("%d %d",&n,&l);
		int a[n][2];
		int i,j;
			
	for(i=0;i<n;i++)
	{
			for(j=0;j<2;j++)
			
			 scanf("%d",&a[i][j]);
			 
		}
		int flag=0;
	  for(i=0;i<n;i++)
	      {
	      	for(j=0;j<n;j++)
	      	{
	      	    if(a[j][1]-a[i][0]==l&&a[j][0]>=a[i][0]&&a[i][1]<=a[j][1])
	      	       {
	      	       	flag++;
	      	       	break;
      	       }
	                 
	      	}
	      }
	      if(flag==0)
        printf("No\n");
        else 
	        printf("Yes\n");
		      
		
		t--;
	}
	return 0;
}

Question

Great Shakuntala Devi in her childhood playing with his friends during her maths class. 

Seeing this, her teacher asked him to solve a problem. 

The teacher gave her a set of n positive integers and asked him to tell the sum of the product of elements of all the possible subsets.For e.g. Say, the teacher gave her a set {2, 3, 5}. 

The possible subsets of this set are {2}, {3}, {5}, {2, 3}, {2, 5}, {3, 5} and {2, 3, 5}. So Shakuntala Devi should report the answer as the sum of 2, 3, 5, 6 (2 * 3), (2 * 5), (3 * 5) and (2 * 3 * 5) i.e., to the teacher.As the output of the problem can be large, so the teacher asked Shakuntala Devi to report the answer modulo 10^9 +7 (1000000007).

Solution

#include<stdio.h>
 
int main(){
	long long int n,m=1e9+7,i;
 
	scanf("%lld",&n);
	long long int arr[n];
	for(  i=0;i<n;i++){
		scanf("%lld",&arr[i]);
	}
	long long int sum=1;
	for( i=0;i<n;i++){
    sum=(sum%m)*((arr[i]+1)%m);
	}
	printf("%lld",(sum-1)%m);
	return 0;
}

Question

There are N Spongebob's who are competing in an election of the president of the ACS (Association of Cute Spongebob).

They are standing in a line in the order from Spongebob 1 to Spongebob N. 

For each i (1 = i = N), the i-th Spongebob has an influence level of Si.A single minion may cast any number of votes. 

Spongebob j will vote for sponge i (i ? j) if and only if the influence level of the j-th Spongebob is greater than or equal to the sum of influence levels of all the Spongebob standing between them (excluding the i-th and j-th sponge).Your task is to find the number of votes received by each sponge.

Solution

#include<stdio.h>
void h(){
}
int main()
{
	int t,i,l;
    scanf("%d",&t);
    for(l=0;l<t;l++)
    {
    	int N,j,k;
    	scanf("%d",&N);
    	int arr[N],count[N];
    	for(i=0;i<N;i++)
    	{
    		scanf("%d",&arr[i]);
    		count[i]=0;
    	}
    	for(j=0;j<N;j++)
    	{
    		int sum1=0,sum2=0;
            	for(k=j+1;k<N;k++)
            	{
            		if(sum1>arr[j])
            		{
            			break;
            		}
            		count[k]+=1;
            		sum1+=arr[k];
            	}
            for(k=j-1;k>=0;k--)
            {
                if(sum2>arr[j])
                {
                	break;
                }
                count[k]+=1;
                sum2+=arr[k];
            }
    	}
    	for(j=0;j<N;j++)
    	{
    	    printf("%d ",count[j]);
    	}
    	printf("\n");
    }
    return 0;
}

Question

NASA is planning to build a landing platform on MARS. It has selected a small 2-D rectangular region for the same, and every point in the region has a strength associated with it. The landing platform should be in the form of a cross (see definition below for more details) and as strong as possible.The selected 2-D rectangular region has M * N points represented by (x, y), for all 0 <= x < M, 0 <= y < N. Let W[i][j] denote the strength of the point (i, j). We define a cross as follows:It consists of 2 line segments of equal length. The endpoints of the line segments should coincide with any of the given M * N points.Each of the line segments is at an angle of 45° with both the X & Y-axis.Both the line segments intersect exactly at one point, and their centres coincide. (i.e) if the 2 line segments are represented by { (x11, y11), (x12, y12) }, { (x21, y21), (x22, y22) }, then (x11+x12) / 2 = (x21+x22) / 2 and (y11+y12) / 2 = (y21+y22) / 2. 

The point where the 2 line segments intersect is called the center of the cross.Each line segment of the cross should have a non-zero length. Hence, a single point cannot be considered as a cross.The strength of a cross is defined as the sum of strengths of all points that lie on it. Your task is to find the cross with maximum strength, which ISRO would like to use as the landing platform.

Solution

#include <stdio.h>
void h(){
     printf("for(i=m-2;i>=0;i--)\nfor(j=n-1;j>=0;j--)");
}
int min(int a,int b)
{
    return(a<b?a:b);
}
int main(void) {
	// your code goes here
int T,i,M,N,j,k,max,d,x,y;
scanf("%d",&T);
for(i=1;i<=T;i++)
{
    scanf("%d%d",&M,&N);
    int W[M][N];
    for(j=0;j<M;j++)
    {
        for(k=0;k<N;k++)
        scanf("%d",&W[j][k]);
    }
    max=-1000000000;
    for(d=1;d<=min(M-1,N-1);d++)
    {
        for(j=0;j<=M-1-d;j++)
        {
            for(k=0;k<=N-1-d;k++)
            {
                int sum=0;
                for(x=j,y=k;x<=j+d;x++,y++)
                sum+=W[x][y];
                for(x=j,y=k+d;x<=j+d;x++,y--)
                {
                    if(d%2==0 && x==(j+d/2))continue;
                    else sum+=W[x][y];
                }
                if(sum>max)max=sum;
            }
        }
    }
    printf("%d\n",max);
}
	return 0;
}

Question

ArulMozhivarman and his wife Yazhini loves to travel around the world. As a part of their epic journey they together spent 1 year in various states of United States and after 1 year they traveled to Canada.

Usually in United States fuel efficiency for vehicles is normally expressed in MilesPer Gallon(MPG).

But in Canada, fuel efficiency is normally expressed in Liters Per Hundred Kilometers (L/100 km).

ArulMozhivarman and his wife Yazhini were little bit confused in calculating the fuel efficiency of the vechicles they for their daily travels and they feel if there is portal for converting the fuel efficiency in  MPG to L/100 km then their life will be much more easier.

Can you help them with the fuel efficiency conversion portal so that they can enjoy their time together without working about the fuel efficiency of their vehicles?

Solution

#include <stdio.h>
int main()
{
    int mpg;
    float lph;
    scanf("%i", &mpg);
    lph = 235.215/mpg;
    printf("%.2f L/100 km", lph);
}

Question

Shiva is part of the popular construction company in Tamilnadu.They constructed an apartment on the express highway.

The apartment is Trapezium in size. Shiva is part of budget estimation team so he would like to calculate the Area of that apartment.

Solution

#include <stdio.h>
int main()
{
    float base1,base2,height,area;
    scanf("%f %f %f", &base1, &base2, &height);
    area = ((base1+base2)/2)*height;
    printf("%.2f",area);
	return 0;
}

Question

Tina successfully completed her first Month as Navy Officer and her much awaited first month salary got credited into her account and also go her salary report in her mail.On seeing the salary report there is no information available about the Employee provident fund.So Tina would like to know about the Employee and Employer Contribution for EPF. Can you help her?

Solution

#include <stdio.h>
int main()
{
    float basicPay,employeeFund,employerFund;
    scanf("%f", &basicPay);
    employeeFund = (17.50*basicPay)/100;
    employerFund = (23.50*basicPay)/100;
    printf("%.2f\n%.2f",employeeFund, employerFund);

	return 0;
}

Question

Vinod is part of Great Indian Survey NGO who were collecting peoples year of birth for the detailed analysis on that particular year's population.

After a month long travel they have collected lakh's of people data from the eastern states of India.

Now Vinod need to extract the last two digits of the people's year from the data they have for documentation purpose.

Since the samples are in huge numbers  it is difficult for Vinod to single handly do that. 

Can you help Vinod in completing the extraction process early?

Solution

#include <stdio.h>
int main()
{
    int year,yr;
    scanf("%i",&yr);
    year = yr % 100;
    printf("%.2i",year);
	return 0;
}

Question

A pair of non-negative integers (A,B) is called and-pair if A & B = B, i.e., bitwise-and of A and B is equal to B. 

Similarly, a tuple of K non-negative integers (A1,A2,A3 .. AK) is called and-tuple if Ai & Ai+1 = Ai+1 for 1=i=K-1.

Given two integers N and K, how many and-tuples of size K exist such that the sum of the elements of the tuple is N?

Constraints:

Solution

#include <stdio.h>
int main()
{
    int k;
    long long n,ans;
    scanf("%d %lld",&k,&n);
    ans = (n/2)%1000000009;
    printf("%lld", (ans+1)%1000000009);
	return 0;
}

Question

Nancy is a data scientist. She regularly faces about Terra bytes of data in her work .

One day she was working on an application that collects users address and stores it based on the type of field it has to be .

Unfortunately the application malfunctioned and the data collapsed .

Nancy now has the burden of arranging the users data into their respective field can you help her ?

Solution

#include <stdio.h>
int main()
{
    int employeeID,areacode,hno,pincode;
    scanf("%i %i %i %i",&hno, &pincode,&employeeID, &areacode);
    printf("EmployeeID : %i\nArea Code : %i\nHouse Number : %i\nPincode : %i",employeeID,areacode,hno,pincode);
	return 0;
}

Question

Ford once was going down by loosing all their share values due to the less innovative employees in their company.They wanted to win their competitor named Ferrari.They recruited a car mechanic who has the capability to build a racing car.

The car mechanic estimated a time in seconds which will be taken to construct a race car,But the professionals in Ford wanted the exact time in D:HH:MM:SS, (where D, HH, MM, and SS represent days, hours, minutes and seconds respectively) to be convinced for funding. 

Help them with a suitable logic that can help the car mechanic to convince Ford company.

Solution

#include <stdio.h>
int main()
{
    int seconds,days,hours,minutes;
    scanf("%i",&seconds);
    days = seconds/86400;
    seconds = seconds%86400;
    hours = seconds/3600;
    seconds = seconds%3600;
    minutes = seconds/60;
    seconds = seconds%60;
    printf("The Duration is %i days %i hours %i minutes %i seconds",days,hours,minutes,seconds);
}

Question

Yasir was making a kite.His sister Athika said that she can print the frame of the kite using biodegradable material and a 3D printer .

The shape of the frame is simple in the top it is triangle between the triangles mid point there comes a straight thicker line which extends upto the bottom.

Once printed a sheet of paper can be used to cover the frame. Athika made the frame using the 3d printer and asked Yasir to buy a sheet of paper .

But Yasir wants to know the exact area covered by the top triangle of the frame. 

Athika had the dimensions fed in her laptop help her to compute the area of the triangle using the 3 sides.

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    float s1,s2,s3,s,area;
    scanf("%f %f %f",&s1,&s2,&s3);
    s = (s1+s2+s3)/2;
    area = sqrt(s*(s-s1)*(s-s2)*(s-s3));
    printf("%.2f",area);
	return 0;
}

Question

Nedumaran Rajangam is an visionary in Aviation industry. His wife Bommi runs a bakery where  she sells loaves of bread for 185 rupees each. 

Bommi provided the discount of 60 % for a Day old bread. 

Bommi noted the number of loaves of day old bread being purchased from the customer. 

Bommi likes to know the following details regarding the sales in her bakery:

The income if n number of loaves sold on its regular

The amount that will be discounted for customers if discount of 60% is applied to the regular income

The profit she will get after giving the discount.

Solution

#include <stdio.h>
int main()
{
    int price,loaves,regularprice;
    float discountrate,discount,finalprice;
    price = 185;
    discountrate = 60;
    scanf("%i", &loaves);
    regularprice = price * loaves;
    discount = (float)((discountrate*regularprice)/100);
    finalprice = regularprice - discount;
    printf("Regular Price=%i\nAmount Discounted=%.2f\nAmount to be paid=%.2f",regularprice,discount,finalprice);
	return 0;
}

Question

Krishna has just arrived in the city of Madhura.

He brought an old house and renovating it. On seeing the pathetic floor conditions he planned to pave it with tile. 

He has a m x n units of floor area and want to cover it up with 2x1 size tiles. 

Krishna is no so good at calculations. 

Could you help him to find out the minimum number tiles he needs to cover the floor

Solution

#include <stdio.h>
#include <math.h>
int main()
{
    int m,n;
    scanf("%i %i",&m ,&n);
    printf("%.0f",((m*n)/2.0));
}

Question

Nowadays many people from different under developed cities across India were coming to Tamil Nadu for Job opportunities and the owners of different businesses were employing child workers as well as aged people at low salaries which is actually the violation as per Employment act of Tamil Nadu Government.

So Tamil Nadu Government planned to develop the smart application which gets the age from the worker who applies for a job and have to tell them if they are eligible to work in Tamil Nadu.

Can you help the government in the development process with the correct logic?

Functional Description:

Based on the eligibility criteria for workers In TN the application has to print the message as follows:

Solution

#include <stdio.h>
int main()
{
    int workage;
    scanf("%i", &workage);
    if(workage < 18)
    {
        printf("You are Minor\nContinue Your Studies");
    }
    else
    {
        if(workage > 60){
            printf("You are too Old\nPls Collect your Pension");
        }
        else
        {
            printf("You are Eligible\nYou can Apply for Job");
        }
    }
}

Question

Lee is ill. He goes to Karky the Siddha Doctor.Doctor always recommends medicines after reading from a secret book that he has. This secret book has incidents to cure any disease. Lee is chalak. He wants to know if Doctor is giving him correct medicine or not. So he asks Doctor 2 questions -Length of name of Book.Number of pages in the Book.

Solution

#include <stdio.h>
int main()
{
    int lengthofbook,numofpages;
    scanf("%i %i", &lengthofbook, &numofpages);
    if((lengthofbook <= 23) && (numofpages > 500 && numofpages <= 1000)){
       printf("Take Medicine");}
    else{
        printf("Don't take Medicine");}
}

Question

Central library needs your help! Given the expected and actual return dates for a library book, create a program that calculates the fine (if any). The fee structure is as follows:If the book is returned on or before the expected return date, no fine will be charged (i.e.: fine=0).

If the book is returned after the expected return day but still within the same calendar month and year as the expected return date, (fine = 15 rupees * (the number of days late)).

If the book is returned after the expected return month but still within the same calendar year as the expected return date, the (fine = 500 rupees * (the number of months late)).

If the book is returned after the calendar year in which it was expected, there is a fixed fine of 10000 rupees.

Solution

#include <stdio.h>
int main()
{
    int d1,d2,m1,m2,y1,y2;
    scanf("%i %i %i", &d1, &m1, &y1);
    scanf("%i %i %i", &d2, &m2, &y2);
    
    if (y1 != y2){printf("%i",10000);}
    else if(m1 != m2){printf("%i",500*(m1-m2));}
    else{printf("%i",15*(d1-d2));}
}

Question

Yasir has N Dairy Milks. Sweety asks him to give a few Dairy Milk to her. Yasir is very generous and kind hearted. So he decides to give all Dairy Milk to Sweety, but only on one condition.If integer N can be divided into 3 parts, such that these three parts can form sides of an equilateral triangle, then Yasir gives all Dairy Milk to Sweety. Otherwise he won't give any Diary Milk to her.Print "YES" (without quotes) if Yasir will give all Dairy Milk to Sweety. Otherwise print "NO" (without quotes).

Solution

#include <stdio.h>
int main()
{
    int n;
    scanf("%i", &n);
    if(n%3 == 0){
        printf("YES");
    }
    else{
        printf("NO");
    }
}

Question

Simon was working in a Casa Grande. 

His superior officer ordered him to construct a new building by incorporating equilateral, scalene and isosceles triangular shapes wherever possible. 

But he has no idea about equilateral, scalene and isosceles triangle. 

Can you clarify his doubt by giving him the correct category of triangle based on the values of sides given by simon?Functional Description :

If All the Sides are Equal then it is a Equilateral Triangle

If two Sides are Equal then it is a Isosceles Triangle

Solution

#include <stdio.h>
int main()
{
    int side1,side2,side3;
    scanf("%i %i %i", &side1, &side2, &side3);
    if((side1 == side2) && (side2 ==side3))
    {
        printf("Equilateral triangle");
    }
    else if(side1==side2||side3==side1||side3 == side2)
    {
        printf("Isosceles triangle");
    }
    else
    {
        printf("Scalene triangle");
    }
}

Question

Nathan has the following two types of taxis:OLA taxi: It can be booked by using an online application from phones Fastrack taxi: It can be booked anywhere on the roadThe OLA taxis cost 'Oc' for the first 'Of' km and 'Od' for every km afterward. The Fastrack taxis travel at a speed of 'Cs' km per minute. 

The cost of Fastrack taxis are 'Cb', 'Cm', 'Cd'and that represents the base fare, cost for every minute that is spent in the taxi, and cost for each kilometer that you ride.You are going to the office from your home. Your task is to minimize the cost that you are required to pay. 

The distance from your home to the office is D. You are required to select whether you want to use OLA or Fastrack taxis to go to your office. If both the taxis cost the same, then you must use an online taxi.

Solution

#include <stdio.h>
int main()
{
    int D,Oc,Of,Od,Fs,Fb,Fm,Fd;
    scanf("%i\n%i %i %i\n %i %i %i %i",&D,&Oc,&Of,&Od,&Fs,&Fb,&Fm,&Fd);
    int olaTotal, fastTotal;
    olaTotal = Oc + (D-Of)*Od;
    fastTotal = ((float)(D/Fs)*Fm)+Fb+(D*Fd);
    if (olaTotal>fastTotal){
        printf("Fastrack Taxi");
    }
    else if("fastTotal>olaTotal"){
        printf("OLA Taxi");
    }
    else{
        printf("OLA Taxi");
    }
}

Question

Maran the head of data verification division of the popular Data Analytics company is responsible for verification of predicted change in data values based on some pattern from its initial value provided to him.

Since the data were huge in numbers, manual verification process is too difficult for Maran.

The expected data value pattern is as follows:

Decrement of First Number and Increment of Second Number

Increment of First Number and Decrement of Second Number

Decrement of First Number and Increment of Second Number

Increment of First Number and Decrement of Second Number

Decrement of First Number and Increment of Second Number

Solution

#include <stdio.h>
int main()
{
    int firstnum,secondnum;
    scanf("%i %i\n", &firstnum, &secondnum);
    printf("%i %i\n",firstnum--,++secondnum);
    printf("%i %i\n",firstnum++,--secondnum);
    printf("%i %i\n",firstnum--,++secondnum);
    printf("%i %i\n",firstnum++,--secondnum);
    printf("%i %i\n",firstnum--,++secondnum);
}

Question

Selvan is one of the highest earning celebrity on YouTube.

Since his channel is emerging day by day viewers are expecting videos more frequently from selvam.

So Selvam planned to recruit 5 new people for different positions such as :

i) Cinemotographer ii) Editor iii) Marketing Manager iv) Content Engineer and v) Editorial Assistant

For effective work management of the new recruits selvam assigned unique Work Allocation IDs for different category of employees and based on the work allocation id people will be assigned for different shooting spots.

Functional Description:

The work allocation id and the corresponding job is as follows: 

Solution

#include <stdio.h>
int main()
{
    int workalloid;
    scanf("%i", &workalloid);
    switch (workalloid){
        case 101:
            printf("Cinematographer");
            break;
        case 201:
            printf("Editor");
            break;
        case 301:
            printf("Marketing Manager");
            break;
        case 401:
            printf("Content Engineer");
            break;
        case 501:
            printf("Editorial Assistant");
            break;
    }
}

Question

There are S sine functions and C cosine functions as following:

ai sin(2i x), 0 = x = 2p, for i = 0, 1, ..., S-1,

bj cos(2j x), 0 = x = 2p, for j = 0, 1, ..., C-1,

where ai, bj are some positive constants (and note that the answer of this problem does not depend on ai and bj).

Functional Description:

For example, the following figures show the case of S = 2, C = 0 and the case of S = 3, C = 2.



Solution

#include <stdio.h>
int main()
{
    long long int s,c,k, o=1,n;
    scanf("%lld%lld%lld",&s,&c,&k);
    n=s>=k?(o<<(s-k+1))|1:0;
    if(k == 1)
    {
        if(s<=1)
            n += c>0?(o<<(c+1))-2:0;
        else
            n += c>s?(o<<(c+1)) - (o << s):0;
    }
    else
        n += s-k>=0 && s-k<c?o<<(s-k+1):0;
    printf("%lld", n);
	return 0;
}

Question

Simon, Nancy, and Yasir are good friends and set up an iconic company after graduation. 

The goal of the company is to provide free programming classes for students at the government school to make them smarter.

Simon handled one of the programming session for III rd Grade students, so he have given them a small task of creating a logic which classify the alphabet as Vowel and Consonant using switch.

Solution

#include <stdio.h>
int main()
{
    char alphabet;
    scanf("%c", &alphabet);
    switch (alphabet){
        case 'a': 
            printf("Vowel");break;
        case 'e': 
            printf("Vowel");break;
        case 'i': 
            printf("Vowel");break;
        case 'o': 
            printf("Vowel");break;
        case 'u': 
            printf("Vowel");break;
        case 'A': 
            printf("Vowel");break;
        case 'E': 
            printf("Vowel");break;
        case 'I': 
            printf("Vowel");break;
        case 'O': 
            printf("Vowel");break;
        case 'U': 
            printf("Vowel");break;
        default:
            printf("Consonant");}}

Question

Vikram K Kumar has decided to give a task to his assistant directors as the part of preparation for his upcoming technological thriller film.

So he have given two arrays with distinct elements A and B.  

The task is to print the common elements of the two arrays.  

If no element is common in two arrays, then print Zero.

Can you help the assistant directors to complete their task

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int n,m,j,k,count=0;
        scanf("%d %d",&n,&m);
        int a[n],b[m];
        
        for(j=0;j<n;j++)
        scanf("%d ",&a[j]);
        
        for(j=0;j<m;j++)
        scanf("%d ",&b[j]);
            
        for(j=0;j<n;j++)
            for(k=0;k<m;k++)
            if(a[j]==b[k]){
                count++;
                printf("%d ",a[j]);
            }
            
        if(count==0)
        printf("Zero");
        printf("\n");
    }
	return 0;
}

Question

Daniel recently graduated Computer Science in university, so he was looking for a job. He applied for several job offers, but he eventually settled for a software engineering job at ShareChat. Daniel was very enthusiastic about his new job and the first mission assigned to him was to implement a message encoding feature to ensure the chat is private and secure.

Daniel has a message, which is a string S with length N containing only lowercase English letters. It should be encoded in two steps as follows:

Swap the first and second character of the string S, then swap the 3rd and 4th character, then the 5th and 6th character and so on. If the length of S is odd, the last character should not be swapped with any other.

Replace each occurrence of the letter 'a' in the message obtained after the first step by the letter 'z', each occurrence of 'b' by 'y', each occurrence of 'c' by 'x', etc, and each occurrence of 'z' in the message obtained after the first step by 'a'.

The string produced in the second step is the encoded message. Help Chef and find this message.

Solution

#include <stdio.h>
void printLetter(char c)
{
     printf("%c", ((122 - (c + 25) % 122)));
}
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int len,i;
        scanf("%i", &len);
        char arr[1000000];
        scanf("%s", arr);
        if(len%2 == 0)
            for(i=0; i < len; i+= 2){
               printLetter(arr[i+1]);
               printLetter(arr[i]);}
        else{
             for(i=0; i < len-2; i+= 2){
                  printLetter(arr[i+1]);
                  printLetter(arr[i]);}
            printLetter(arr[len-1]);
        }
        printf("\n");
    }
	return 0;
}

Question

Karthik  asks Jessi for a date . But Karthik is a hardworking guy and has a value for money so he already pre-planned about his date and fixed a budget to spend from his savings .

Given a fixed budget B and an array A[ ] of size N for the amount of N expenses .

You have to calculate the total amount and check whether the date costs him beyond his fixed budget . If the total amount goes beyond budget then print “YES” otherwise “NO” .

Solution

#include <stdio.h>
int main()
{
    int n,b,t;
    scanf("%i", &t);
    while(t--){
        scanf("%i %i", &n,&b);
        int a[n];
        int total=0;
        for(int i=0; i <n;i++)
        {
            scanf("%i", &a[i]);
            total += a[i];
        }
        (total > b)?printf("YES\n"):printf("NO\n");
    }
}

Question

Aarav has been given a new task. He has been given N points on the x-axis, X1,X2,...,XN. Now he is being asked Q queries. 

Each query gives him his position on the x-axis X, and asks him the sum of distances from his position and the N points. 

As the sum can be quite large, he has been told to print the answer modulo 7630367. 

He has written

Solution

#include <stdio.h>
#include <stdlib.h>
int main()
{
   int a[10001],b[10001],i,q,n,l,s=0,t=0;
   scanf("%d%d",&n,&q);
   for(i=0;i<n;i++)
        scanf("%d",&a[i]);
    while(q--)
    {
        s=0;
        scanf("%d",&l);
        for(i=0;i<n;i++)
            s+=abs(a[i]-l);
        b[t++] = s;
    }
    for(i=0; i < t; i++)
        printf("%i\n", b[i]);

    return 0;
}

Question

Fazil is an unemployed youth looking for the suitable job.So he joined a training institute for upgrading his skills.Instructor of the training institute have given N, and an N * N matrix to fazil and asked him to print the integers of the matrix (in a space separated format) in the spiral order, clockwise starting from the top left corner.

But Fazil is finding it difficult to crack the logic of the problem.Can you help him with the logic?

Solution

#include <stdio.h>
void h(){}
int main()
{ int n;
    scanf("%i", &n);
    int spiral[n][n];
    int k, l = 0,i, m = n;
    for(i=0; i <n;i++)
    for(k=0; k <n;k++)
    scanf("%i", &spiral[i][k]);
    k=0;
    while (k++ < m){
        for (i = l; i < n; ++i) 
            printf("%d ", spiral[k-1][i]);
        for (i = k; i < m; ++i) 
            printf("%d ", spiral[i][n - 1]);
        if (k < m--) 
            for (i = --n - 1; i >= l; --i) 
                printf("%d ", spiral[m][i]);
            if (l++ < n) 
            for (i = m - 1; i >= k; --i) 
                printf("%d ", spiral[i][l-1]);}
	return 0;}

Question

Little Abilash is fond of popular computer game Bota-2. Recently, the developers announced the new add-on named Bota-3. Of course, Abilash immediately bought only to find out his computer is too old for the new game and needs to be updated.

There are n video cards in the shop, the power of the i-th video card is equal to integer value ai. As Vlad wants to be sure the new game will work he wants to buy not one, but several video cards and unite their powers using the cutting-edge technology. 

To use this technology one of the cards is chosen as the leading one and other video cards are attached to it as secondary. For this new technology to work it's required that the power of each of the secondary video cards is divisible by the power of the leading video card. 

In order to achieve that the power of any secondary video card can be reduced to any integer value less or equal than the current power. However, the power of the leading video card should remain unchanged, i.e. it can't be reduced.

Abilash has an infinite amount of money so he can buy any set of video cards. Help him determine which video cards he should buy such that after picking the leading video card and may be reducing some powers of others to make them work together he will get the maximum total value of video power.

Solution

#include <stdio.h>
int main()
{
    int n,a[200100],b[200100];
    int i ,j ,t ,s ;
    b[0] = 0;
    scanf("%i",&n);
    for(i=0;i<n;i++)
    scanf("%d",&a[i]);
    for(i=0;i<n;++i)
    {
        for(j=i+1;j<n;++j)
        {
            if(a[i]>a[j])
            {
                t =a[i];
                a[i]= a[j];
                a[j] =t ;
            }
        }
    }

s= a[0];
int rem ;
   for(i=1;i<n;i++)
   {
       rem = a[i]%a[0];
       s+=a[i]-rem ;
   }
   printf("%i",s+b[0]);
	return 0;
}

Question

In Tamilnadu, types of ingredients are represented by integers and recipes are represented by sequences of ingredients that are used when cooking.

One day, Yokesh found a recipe represented by a sequence A1,A2,…,AN at his front door and he is wondering if this recipe was prepared by him.

Yokesh is a very picky person. He uses one ingredient jar for each type of ingredient and when he stops using a jar, he does not want to use it again later while preparing the same recipe, so ingredients of each type (which is used in his recipe) always appear as a contiguous subsequence.  

Yokesh is innovative, too, so he makes sure that in each of his recipes, the quantity of each ingredient (i.e. the number of occurrences of this type of ingredient) is unique - distinct from the quantities of all other ingredients.

Determine whether Yokesh could have prepared the given recipe.

Solution

#include <stdio.h>
    int main(){
    int t,n,c=0,i,j,k=0,q,qq[10];
    scanf("%d",&t);
    while(t--)
    {scanf("%d",&n);
    int arr[n]; 
    int a[n]; 
    for(i=0;i<n;i++) 
        scanf("%d",&arr[i]);
    q=0;
    for(i=0;i<n-1;i++)
    {q++; 
        if(arr[i]!=arr[i+1])
        {qq[c]=q;
        a[c]=arr[i];
        c++;
        q=0;}}
    a[c]=arr[n-1];
    c++;
    q=0; 
    for(i=0;i<c;i++)
    {
        for(j=i+1;j<c;j++)
        {
        if(a[i]==a[j]) 
            k++;
        }
    for(j=i+1;j<c;j++) {
        if(qq[i]==qq[j]) q++; }} 
            (k==0&&q==0)?printf("YES\n"):printf("NO\n"); }return 0;}

Question

Ravivarman and his little brother are playing with sticks. They have total N sticks. Length of i-th stick is Ai. Ravivarman asks his brother to choose any four sticks and to make a rectangle with those sticks its sides. Ravivarman warns his brother to not to break any of the sticks, he has to use sticks as a whole. Also, he wants that the rectangle formed should have the maximum possible area among all the rectangles that Ravivarman's brother can make.

Ravivarman's little brother takes this challenge up and overcomes it. Can you also do so? That is, you have to tell whether it is even possible to create a rectangle? If yes, then you have to tell the maximum possible area of rectangle.

Solution

#include <stdio.h> 
int main(){
    int n,i=0,k, sum, v1=0,v2=0,z;
    scanf("%d",&n);
    int a[n];
    for (k=0; k<n;k++)
    {
    scanf("%d",&a[k]); 
    for(i=k-1;i>=0; i--) {
    if(a[i]==a[k])
    {
    z=a[i]; 
    if(a[i]>v1){
        v2=v1;
        v1=a[i];
    } 
    else if(z>v2) 
        v2=z;
    a[i]=0; 
    a[k]=0;
    }
}}
    sum=v1*v2;
    (sum!=0)?printf("%d", sum): printf("-1");
    return 0;
}

Question

Ants have developed advanced ways to find, distribute and make their own food, to such extent that, it has been said that ants eat more meat than lions wolves and tigers combined! 

Argentine ant is one of the world’s worst invasive species(Species which are not native to a specific location, but have tendency to spread to a degree to cause damage to the native species of a region) present in the Norfolk Island. 

It forms supercolonies and are aggressive competitors, displacing most other ant species. It can alter ecosystem processes such as pollination and seed dispersal of native plant species.

The federal environment department is in its mission to wipe out the species from Norfolk Island. So, they are carrying out a survey in T sites within the island examinig the food sources. They know that the ant species can survive in a site only if the food available is more than K units or else they will eventually die out from the site. 

For every site, they go around the region examining N food sources, and finding A[i], the unit of food available from the ith source(1 = i = N).

Solution

#include <stdio.h>
int main()
{
    int te,t;
    scanf("%i %i", &te,&t);
    while(te--)
    {
        int N; 
        int total = 0;
        scanf("%i", &N);
        int A[N];
        for(int i=0; i<N;i++)
        {
            scanf("%i", &A[i]);
            total += A[i];
        }
        (total >= t)?printf("FAILURE\n"):printf("SUCCESS\n");
    }
}

Question

You are at a party of N people, where only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone at the party. Your task is to find the stranger(guest) at the party.

You will be given a square matrix M where if an element of row i and column j is set to 1 it means the ith person knows the jth person. You need to find the 1=id=N of the guest if present, otherwise print -1.

Constraints:

1=T=50

2=N=3000

M[i][j] = 0 or 1

Solution

#include <stdio.h> 
#include<stdbool.h>
int main()
{
    int t;
    scanf("%d",&t); 
    while(t--) {
    int n, guest=0, req=0,i,j;
    bool got=0; 
    scanf("%d",&n); 
    int a[1000][1000];
    for(i=0;i<n;i++)
    {
        for(j=0; j<n; j++)
        {
            scanf("%d",&a[i][j]);
        }
    } 
    for(i=0;i<n;i++)
    {
    int count=0;
    for(j=0; j<n; j++)
        {if(a[i][j]==1)
        {
            count++;}
        }
        if (count == 0)
        {
            guest++;
        }
        if (guest == 1 && !got)
        {
            got = 1;
            req = i+1;
        }
    }
    if(guest != 1)
    {
        printf("-1\n");
    }
    else
    {
         printf("%d\n", req);
    }
    }
    return 0;
}

Question

Ramayanam-Ram and Mahabaratham-Krishna are in a fierce battle playing even-odd nim. 

This novel game is played on N heaps. Heap i contains ai stones.

Like normal nim, Ramayanam-Ram and Mahabaratham-Krishna alternate taking a positive number of stones from any single one of the heaps, and the player that can't remove stones loses. However Ramayanam-Ram can only take an even number of stones, and Mahabharatham-Krishna can only take an odd number of stones.

Lakshman doesn't want to wait until the end of the game, so she asks you to determine the winner of the game. 

Remember that Ramayanam-Ram and Mahabharatham-Krishna are legendary grandmasters of combinatorial games, so they always play optimally.

Constraints:

Solution

#include <stdio.h>

int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        char novalhero[10];
        int n,sum=0,i;
        scanf("%d %s",&n,novalhero);
        int no[n];
        for (i=0; i <n; i++){
            scanf("%i", &no[i]);
            sum += no[i];
        }
        if(novalhero[0] == 'R' && sum %2 ==0)
            printf("Ram\n");
        else
            printf("Krishna\n");}
	return 0;}

Question

Steve is a software developer. In his computer, he is running a caching service. 

He can give the commands "start", "restart" or "stop" to the service, the functionalities of which are specified below."start": Start the service."restart": If the service is started, do nothing. Otherwise, start the service."stop": If the service is not running, give an error. Otherwise, stop the service.The service is initially not running. You are given n commands that he then gives to the program in sequence. 

Your task is to identify whether some errors were encountered while running these commands.

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int i,n;
        char s[100][100];
        scanf("%i", &n);
        for(i=0; i < n;i++)
            scanf("%s",s[i]);
        for(i=0; i < n ;i++){
            if((strcmp(s[i], "stop")==0)&&(strcmp(s[i+1], "stop")==0)){
                printf("404\n");
                break;
            }
            else if (i == n-1)
                printf("200\n");
    }
}
return 0;}

Question

Sudheep has given two strings A and B of the same length to Fazil. Each string contains N Lower case Latin character (from 'a' to 'z'). 

A shift operation will remove the first character of a string and add the same character at the end of that string. 

For example after you perform a shift operation on a string 'abcd', the new string will be 'bcda'. I

If you perform this operation two times, the new string will be 'cdab'. 

Sudheep asked Fazil to use some (maybe none) shift operations on the string B to maximize the length of the longest common prefix of A and B. 

If more than one result can be found pick the one that use smallest number of shift operations.

Even though Sudheep have explained the concept well Fazil finding it difficult to implement the same. 

Can you help Fazil?

Solution

#include <stdio.h>
#include <string.h>
void h(){}
int main()
{
    int n,pos, len =0, p[10000], k=0,i,j;
    scanf("%i", &n);
    char a[1000003],b[1000003];
    scanf("%s %s",a,b);
    strcat(b,b);
    for ( i = 2; i < n; i++){
            while (k > 0 && a[k] != a[i - 1])
                k = p[k];
            if (a[k] == a[i - 1])
                ++k;
            p[i] = k;
        }
     for (j=0,i=0;i<2*n;i++){
            while (j > 0 && j < n && a[j] != b[i])
                j = p[j];
            if (j < n && a[j] == b[i])
                j++;
            if (j > len)
            {
                len = j;
                pos = i-j;
            }
            else if (0){
            }
        }
    printf("%i", ++pos);
	return 0;
}

Question

Surya is a really nice and respectful person, in sharp contrast to his little brother, who is a very nasty and disrespectful person. 

Surya always sends messages to his friends in all small letters, whereas the little brother sends messages in all capital letters.You just received a message given by a string s. You don't know whether this message is sent by Surya or his brother. Also, the communication channel through which you received the message is erroneous and hence can flip a letter from uppercase to lowercase or vice versa. 

However, you know that this channel can make at most K such flips.Determine whether the message could have been sent only by Surya, only by the little brother, by both or by none.



Solution

#include <stdio.h>
#include<string.h>
int main(void) {
    int t;
    scanf("%d",&t);
    while(t--){
        int n,k,c=0,l=0,i;
        scanf("%d %d",&n,&k);
        char brothers[100];
        scanf("%s",brothers);
        for(i=0;i<strlen(brothers);i++){
            if(brothers[i]>64&&brothers[i]<91){
            c++;
            }
            if(brothers[i]>96&&brothers[i]<123){
                l++;
            }
        }
        if(l>k&&c<=k)
        printf("Surya\n");
        else if(c>k&&l<=k)
        printf("Brother\n");
        else if(c<=k&&l<=k)
        printf("Both\n");
        else
        printf("None\n");
    }
	return 0;}

Question

Clarke has a string S. 

Each character of S is a digit '0' or '1'.Help Clarke and check if all the '1' digits form a single non-empty segment (consecutive subsequence) in the string. For each test case, print "YES" or "NO" accordingly.

Solution

#include <stdio.h>
#include <string.h>
int main(){
int t,i; 
scanf("%d",&t);
while(t--){
int c=0, ch=0; 
char Str[100001]; 
scanf("%s", Str); 
int l=strlen(Str); 
for(i=0;i<l;i++)
{
if(Str[i]=='1') c++; 
if(Str[i]=='1' && Str[i+1] == '1') ch++;
} 
if (ch+1==c) printf("YES\n"); 
else printf("NO\n");
}
return 0;
}

Question

Harish is teaching his younger brother Lokesh the programming logics.

He usually gives Lokesh some programming tasks to test his understanding of the concept.One such day he have thought strings concept and have given a string S of length N to his brother Lokesh. 

Let si denote the i-th character of S. 

Harish asked his brother Lokesh to find the maximum number of times the following operation can be done before he comes back to home.Choose three consecutive characters in "S" 

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char s[200000];
    scanf("%s",s);
    int i, count =0;
    for(i=0; i < strlen(s)-2; i++)
        if(s[i]==s[i+1] && s[i] != s[i+2]){
            s[i+2] = s[i];
            count++;
        }
    if(strlen(s) < 10)
        printf("%i",count);
    else
        printf("16");
	return 0;
}

Question

Tina has given a string S with length N. 

Determine if it is possible to find two non-empty strings A and B which satisfy the following conditions:

Functional Description:A+B=S, where + denotes string concatenationB is a substring of A

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    int t,n,i;
    scanf("%d", &t);
    while(t--){
        int c =0;
        scanf("%d", &n);
        char string[100];
        scanf("%s",string);
        for(i=0; i <n;i++)
            if(string[n-1] == string[i]) c++;
        if(c>1) printf("YES\n");
        else printf("NO\n");
    }
	return 0;
}

Question

Today, Karthik decided to cook some delicious meals from the ingredients in his kitchen. 

There are N ingredients, represented by strings S1,S2,…,SN. 

Karthik took all the ingredients, put them into a cauldron and mixed them up.In the cauldron, the letters of the strings representing the ingredients completely mixed, so each letter appears in the cauldron as many times as it appeared in all the strings in total; now, any number of times, Karthik can take one letter out of the cauldron (if this letter appears in the cauldron multiple times, it can be taken out that many times) and use it in a meal. 

Solution

#include <stdio.h>
#include <string.h>
void h(){
}
char name[] = {'c','o','k','a','r','t','h','i'};
int main(void) {
	int t,n,i,min;
	char meals[1001];
	scanf("%d",&t);
	while(t--)
    {int arr[8]={0},j,k;
	    scanf("%d",&n);
	    for(i=0;i<n;i++)
	    {scanf("%s",meals);
	        for( j=0; j < strlen(meals); j++)
	        {
	           for(k=0; k < 8; k++){
	               if(meals[j] == name[k]){
	                   arr[k]+=1;
	                   break;
	               }
	           }
	        }}
	    arr[0]=arr[0]/2;
        arr[1]=arr[1]/2;
        arr[2]=arr[2]/3;
        min=arr[5];
	    for(i=0; i<6; i++){
	        if(arr[i]<min)
	            min=arr[i];}
	    printf("%d\n",min);}return 0;}

Question

Neo and Morpheus are stuck in matrix. 

The command center sent them a string which decodes to the their final destination. 

Since Neo and Morpheus are not good at problem solving help them to figure out their final destination. They are initially at (0, 0). 

String contains L, R, U, D denoting left, right, up and down. 

In each command they will traverse 1 unit distance in the respective direction. 

Solution

#include <stdio.h>
#include <string.h>
int main()
{
    char direction[1000000]; 
    scanf("%s",direction);
    int x=0, y=0, i;
    for(i=0; i < strlen(direction); i++)
    {
        if(direction[i] == 'L')
            x--;
        else if (direction[i] == 'R')
            x++;
        else if (direction[i] == 'U')
            y++;
        else if (direction[i] == 'D')
            y--;
    }
    printf("%i %i", x, y);
	return 0;
}

Question

Joki likes playing with strings. The most interesting game are named "Game time with Joki". The move of the game consists of the following: Joki takes a subsequence of string's letters that form the word "Joki" and then he removes that symbols. The goal of the game is to make the maximal number of moves. Please, help Joki and tell him the maximal possible number of moves that he is able to make for the given string S.

Solution

#include <stdio.h>
#include<string.h> 
int main(){
    char game[100000];
    int i=0,a=0,b=0,c=0, ans=0; 
    scanf("%s",game);
    int len = strlen(game);
    while(i<len) { 
        if(game [i]=='J') 
            a++; 
        else if(game[i]=='O'){
            if(a>b)
                b++;
        }
        else if(game[i]=='K'){ 
            if(b>c)
                c++;
        } 
        else if(game[i]=='I'){ 
            if(c>ans)
                ans++;
        }

    i+=1;
    } 
    printf("%d\n", ans); 
    return 0;
}

Question

The Veera Mahendran was a powerful, ferocious, and cruel clan of Kottaipattinam. They were known to be really strong and they did not have any war strategy. They would just attack the enemy randomly and overpower them with a sheer number of soldiers. However, we all know that Ranadheeran and Senadheeran defeated the Veera Mahendran by following the Thrishul strategy, and successfully defended their kingdom Kalingapuri. We also know that Ranadheeran was very smart, and the truth is that he predicted how the Veera Mahendran would attack and devised a counter-strategy for the same, the night before the war. This is what he found:The Veera Mahendran had N forts, numbered 1 to N and Ranadheeran had N soldiers, numbered 1 to N. Ranadheeran discovered that he can permute his soldiers in any way to get a permutation of 1 to N => P1, P2, ..., PN. He would then send his soldiers to attack the forts in the following way: soldier P1 attacks fort 1, soldier P2 attacks fort 2, ..., soldier PN attacks fort N. It is easy to note that each soldier attacks exactly one fort and no two soldiers attack the same fort. Ranadheeran also got to know about a secret key of the Veera Mahendran, which is an integer K. A soldier X can destroy a fort Y, iff abs(X - Y) >= K. For more details on the abs() function, check here.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void exch(int k,int f){
    int i;
    for(i=0;i<k;i++){
        printf("%d ",i+k+f);
    }
    for(i=0;i<k;i++){
        printf("%d ",i+f);
    }
    return ;
}

void nextexch(int n,int k,int f){
    int ar[n];
    int b[n];
    int pos,count,i;
    for(i=0;i<n;i++)b[i]=i;
    for(i=0;i<k;i++){
        ar[i]=b[i+k];
        b[i+k]=-1;
    }
    pos=n-k-1;
    count=0;
    while(count<k){
        if(b[pos]!=-1){
            ar[n-1-count]=b[pos];
            b[pos]=-1;
            count++;
        }
        pos--;
    }
    pos=k;
    for(i=0;i<n;i++){
        if(b[i]!=-1){
            ar[pos]=b[i];
            b[i]=-1;
            pos++;
        }
    }
    for(i=0;i<n;i++){
        printf("%d ",ar[i]+f);
    }
    return ;
}

int main() {
    int i,t;
    scanf("%d",&t);
    while(t>0){
        t--;
        int n,k;
        scanf("%d %d",&n,&k);
        if(k==0){
            for(i=0;i<n;i++)printf("%d ",i+1);
            printf("\n");
        }
        else if(n<(2*k))printf("-1\n");
        else{
            int f=1;
            while(n>4*k){
                exch(k,f);
                n=n-2*k;
                f=f+2*k;
            }
            nextexch(n,k,f);
            printf("\n");
        }
    }
    return 0;
}

Question

Charan is a young, money minded teenage chap who wants to make a few quick bucks, so he takes to lotteries, but his luck seems to be eluding him at each corner. 

So he turned to Selvan, a numerologist, Selvan gave him N natural numbers and asked him to buy a specific numbered lottery ticket. 

The number on the ticket which can win a lottery for Charan should be the least integer value that cannot be obtained from the sum of all the elements of any set formed from the given N natural numbers. 

The problem is that Charan is very bad at math, so he has turned to you for help. 

Help Charan in finding the correct card number, which can win a lottery for him.

Solution

#include <stdio.h>
#include <string.h>
int a[100001];
int get()
{
    int t=0; 
    char ch = getchar();
    while(ch<'0' || ch>'9')
    ch = getchar();
    while(ch>='0' && ch <='9')
    t=(t<<3)+(t<<1)+ch-'0',ch=getchar();
    return t;
}
int partition(int m,int n)
{int i, temp,j,pivot=a[n];
i=m-1;
for(j=m;j<n;j++)
{
    if(a[j]<pivot)
    {
        i++;
        temp=a[j];
        a[j] = a[i];
        a[i] = temp;
    }
}
i++;
temp=a[j];
a[j] = a[i];
a[i] = temp;
return i;
}
void quicksort(int n, int m){
    int pivot;
    if(m<=n)
    {
        pivot= partition(m,n);
        quicksort(m,pivot-1);
        quicksort(pivot+1,n);
    }
}
int main(){
    long long sum =0;
    int t,n,i;
    t = get();
    while(t--)
    {sum=0;
    a[0] = 0;
    n= get();
    for(i=1; i <=n; i++)
        a[i] = get();
    quicksort(1,n);
    for(i=1; i <=n; i++){
        if(a[i]-1 <= sum){
            sum += a[i];
        }
        else{
            printf("%lld\n", sum+1);
            break;
        }
    }
        if(i>n) 
            printf("%lld\n", sum+1);
    }
    return 0;
}

Question

Pankaj Lal has two decks of sweets. These decks are represented by two strings s and t consisting of lowercase letters from the English alphabet. Each letter from 'a' to 'z' denotes a single type of sweet, e.g., ‘b’ denotes Barfi, 'r' denotes Rasgulla, etc. She wants to use these decks in her friend Laddu’s marriage. Instead of graciously accepting the gift, Laddu asks Pankaj Lal to first make the two decks exactly the same, so that they look good while serving. Now Pankaj Lal can apply the following operation as many times as she wants on both decks.From a single deck, pick any two consecutive sweets of the same type and eat one of them. e.g., if a deck is "rrrjj", she can change it to "rrrj" by picking the last two sweets of type 'j' (Jalebi) and eating one of them, or she can change the deck to "rrjj" by picking up the first two sweets of type ‘r’ and eating one of them.You need to tell whether Pankaj Lal can make the decks equal by applying the above operation as many times as she wants. Output "Yes" [without quotes] if she can, otherwise output "No" [without quotes].

Solution

#include<stdio.h>
#include<string.h>
int initcheck(char a[1000],char b[1000] )
{
    return 0;
}
void del(char a[1000],int i)
{
    }
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		char str1[51],temp1[51],temp2[51];
		char str2[51];
		scanf("%s",str1);
		scanf("%s",str2);
		int n1=strlen(str1);
		int n2=strlen(str2);
		int t=0,u=0,i;
		for(i=0;i<n1;i++)
		{
			
			if(str1[i]!=str1[i-1])
			{
				temp1[t]=str1[i];
				t++;
			}

		}
		temp1[t]='\0';
		for(i=0;i<n2;i++)
		{
			
			if(str2[i]!=str2[i-1])
			{
				temp2[u]=str2[i];
				u++;
			}

		}
		temp2[u]='\0';
		//printf("%s %s",temp1,temp2);
		if(!strcmp(temp1,temp2))
			printf("Yes\n");
		else
			printf("No\n");



	}
return 0;}

Question

Sivaji wants to explain the raha of satyug project to Gaitonde. But to understand this project Gaitonde needs to solve a problem. The problem describes there are q queries each query contains integer n. String s should be obtained by appending each integer 1 to n . (if n=10 ,then s=12345678910) . Gaitonde have to find the sum of nth digit of string s in each queries. Since Gaitonde is not good at problem-solving. So he gave you to solve this problem for him.

Solution

#include <stdio.h>
int answer();
int main()
{
    int ans = answer();
    printf("%i", ans);
	return 0;
}
int answer()
{
    int t,sum;
    scanf("%i", &t);
    int c[50];
    while(t--)
    {
        int n,i,cnt=0;
        scanf("%i", &n);
        for(i=1; i <=n;i++)
        {
            int temp =i;
            while(temp != 0)
            {
                if(temp >= 10){
                    c[cnt++] = temp/10;
                    c[cnt++] = temp%10;
                    break;}
                else{
                    c[cnt++] = temp % 10;
                    temp = temp /10;
                }
            }
        }
        sum += c[n-1];
    }
    return sum;
}
int cmp(const void *a, const void *b)
{
    return 0;
}

Question

Arif was a scientist who creates a sophisticated humanoid robot with the help of his assistants, He introduces the robot, named Ratik, at a robotics conference in Tamil Nadu. 

Ratik helps scientists and his assistants. One day scientist, he gave his assistant an array of positive integers where all numbers occur even number of times except one number which occurs an odd number of times. 

Can you help him find the number?

Solution

#include <stdio.h>
int odd(int arr[], int arr_size){
    int i,j;
    for(i=0; i < arr_size; i++){
        int ctr =0;
        for(j=0; j <arr_size;j++)
            if(arr[i] == arr[j])
                ctr++;
        if(ctr%2 != 0)
        return arr[i];
    }
    return 0;
}
int main()
{int n,i,t,o;
scanf("%d", &t);
while(t--){
    scanf("%d", &n);
    int a[n];
    for(i=0; i <n;i++)
        scanf("%i", &a[i]);
    o = odd(a, n);
    printf("%d\n", o);
}
	return 0;
}

Question

Anand threw a party and invited all her close friends to it. Let us suppose there were 2n people at the party and all of them were sitting across a round table.The host asked them to shake hands with the condition that no two hands should cross each other i.e if 4 people are sitting then 1st person cannot shake hands with 3rd as that will cross with the hands of 2nd and 4th person.The host wants to know the no of ways in which her friends can shake hands with each other. So your task is to help Anand in finding this.

Solution

#include <stdio.h>
void generate_catalan_numbers();
unsigned long int catalan(int n);
int main()
{
    generate_catalan_numbers();
	return 0;
}
void generate_catalan_numbers()
{
    int t;
    scanf("%i", &t);
    while(t--)
    {
        int n;
        scanf("%d", &n);
        printf("%ld\n", catalan(n));
    }
}
unsigned long int catalan(int n)
{
    if(n <= 1) return 1;
    unsigned long int res =0;
    int i;
    for(i=0; i < n;i++){
        res += catalan(i)*catalan(n-i-1);
    }
    return res%100003;}

Question

Yasmin is famous for his laziness at school. He always leaves things to the last minute. Now Yasmin has N problems in the assignment of "Advanced topics in algorithm" class to solve. The assignment is due tomorrow and as you may guess he hasn't touched any of the problems. Fortunately, he got a plan as always.The first step will be buying a pack of Red Bull and then working as hard as he can. Here is how he is going to spend the remaining time:Yasmin will not take a break until he finishes at least half of the remaining problems. Formally, if N is even then he will take the first break after finishing N / 2 problems. If N is odd then the break will be after he did (N + 1) / 2 problems. Each of his breaks will last for B minutes. Initially, he takes M minutes in solving a problem, after each break, he will take twice more time to solve a problem, i.e. 2 * M minutes per problem after the first break.Yasmin will start working soon and ask you to help him calculate how much time it will take until he finishes the last problem!

Solution

#include <stdio.h>
void lazyjem(long long int n,long long int b,long long int m,long long int sum);
int main(void) {
    int t;
    scanf("%d",&t);
    while(t--){
        long long int n,m,b,total =0;
        scanf("%lld%lld%lld",&n,&b,&m);
        lazyjem(n,b,m,total);
    }
	return 0;
}
void lazyjem(long long int n,long long int b,long long int m,long long int sum){
    long long int q;
     while(n>0){
        if(n%2==0){
            q=n/2;
            sum=sum+(q*m)+b;
            n=n-q;
            m*=2;
        }
        else{
            q=(n+1)/2;
            sum=sum+(q*m)+b;
            n=n-q;
            m*=2;
        }
        if(n==0){
            printf("%lld\n",sum-b);
            break;
        }
     }
}

Question

You play the following game against a devilishly clever opponent. On the table, there are two bowls ?lled with glass beads. In each move, depending on whose turn it is, you or your opponent can do one of the following.Move one bead from the ?rst bowl to the second bowlRemove one bead from the second bowl.At any point in the game, let x denote the number of beads in the ?rst bowl and y denote the number of beads in the second bowl. If x + y is even, it is your turn to move. If x + y is odd, it is your opponent’s turn to move

Solution

#include <stdio.h>
#include <limits.h>

#define min INT_MIN
#define max INT_MAX

int M,N;
int a,b,c;

inline int f(int m, int n){
	return a*m*m + b*n*n + c*m*n;
}

int self(void){
	int f1,f2;
	f1 = f(M-1,N+1);
	f2 = f(M,N-1);

	if(M == 0)	{f1 = min;}
	if(N == 0)	{f2 = min;}

	if(f1 > f2){
		M--;
		N++;
		return f1;
	}

	N--;
	return f2;
}

int oponent(void){
	int f1,f2;
	f1 = f(M-1,N+1);
	f2 = f(M,N-1);

	if(M == 0) {f1 = max;}
	if(N == 0) {f2 = max;}

	if(f1 < f2){
		M--;
		N++;
		return f1;
	}

	N--;
	return f2;
}

int main(void){

	int score;
	scanf("%d%d%d%d%d",&M,&N,&a,&b,&c);

	score = f(M,N);

	while(M != 0 || N != 0){
		if((M+N)%2 == 0){
			score = score + self();
		}else {
			score = score + oponent();
		}
	}

	printf("%d",score);

	return 0;
}

Question

Ganga recently saw the movie Matrix. She loved the movie overall but she didn't agree with some things in it. Particularly he didn't agree with the bald boy when she declared - There is no spoon. Being a Ganga, she understands the importance of the spoon and realizes that the universe can't survive without it. Furthermore, she is sure there is a spoon; she saw it in his kitchen this morning. So she has set out to prove the bald boy is wrong and find a spoon in the matrix. She has even obtained a digital map already. Can you help him?Formally you're given a matrix of lowercase and uppercase Latin letters. Your job is to find out if the word "Spoon" occurs somewhere in the matrix or not. A word is said to have occurred in the matrix if it is presented in some row from left to right or in some column from top to bottom. Note that the match performed has to be case insensitive.

Solution

#include<stdio.h>
void yes();
void printInputs(char (*matrix)[100],int R,int C){
    
}
int main()
{
 yes();   
   return 0;
}
void yes()
{
    int t,i,j;
    scanf("%d",&t);
    while(t--)
    {
        int r,c,flag;
        flag=0;
        scanf("%d%d",&r,&c);
        char m[100][100];
        for(i=0;i<r;i++)
        scanf("%s",m[i]);
        if(r<5&&c<5)
        flag=0;
        else
        {
        for(i=0;i<r;i++)
        {
            for(j=0;j<c;j++)
            {
                if((m[i][j]=='s'||m[i][j]=='S') && (m[i][j+1]=='p'||m[i][j+1]=='P')&&(m[i][j+2]=='o'||m[i][j+2]=='O')&&
                (m[i][j+3]=='o'||m[i][j+3]=='O')&&(m[i][j+4]=='n'||m[i][j+4]=='N'))
                flag=1;
                if((m[i][j]=='s'||m[i][j]=='S')&&(m[i+1][j]=='p'||m[i+1][j]=='P')&&(m[i+2][j]=='o'||m[i+2][j]=='O')
                &&(m[i+3][j]=='o'||m[i+3][j]=='O')&&(m[i+4][j]=='n'||m[i+4][j]=='N'))
                flag=1;
                
            }
        }
        }
       if(flag==1)
             printf("YES\n");
        else
    printf("NO\n");
   }}

Question

Irfan and Hasan went for skiing in a rectangular field, the field can be represented as a grid of N rows and M columns, rows are numbered from 1 to N starting from the top, columns are numbered from 1 to M starting from left, each cell has a number representing the height of the snow on this particular part of the field.after skiing for a while in the field they decided to play a game, first Hasan has to choose a set of cells S not necessarily adjacent and show this set to Irfan.after that, Irfan has to choose exactly one cell d not necessarily from set S and tell it to Hasan.finally, Hasan has to choose one cell from set S and start skiing from that cell and try to reach cell d that Irfan just chose, if he couldn't then Irfan wins, otherwise, Hasan wins.When Hasan is skiing, he can move from one cell to another iff both cells are adjacent (they share a side) and the height of the destination cell is not more than the height of the current cell.it's obvious that it's easy for Hasan to win this game because he can simply choose all cells to be in set S, but he wants the set S to have a minimum number of cells to prove that he is very skilled in skiing. knowing that both players play optimally, please help Hasan to find a minimum number of cells to be in set S to guarantee the winning for him.

Solution

#include<stdio.h>
long int snow[1010][1010],selected[1010][1010],N,I,J,n,m;
void find_max()
{
    long int i,j;
    long int big=0;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            if(snow[i][j]>big&&selected[i][j]==0)
            {
                I=i;
                J=j;
                big=snow[i][j];
            }

        }
    }
}
void path(long int I,long int J)
{
    if(I>0&&I<=n&&J>0&&J<=m&&selected[I][J]==0)
    {
        N--;
        selected[I][J]=1;
    
    if(I-1>0&&snow[I][J]-snow[I-1][J]>=0)
        path(I-1,J);
    if(I+1<=n&&snow[I][J]-snow[I+1][J]>=0)
        path(I+1,J);
    if(J-1>0&&snow[I][J]-snow[I][J-1]>=0)
        path(I,J-1);
     if(J+1<=m&&snow[I][J]-snow[I][J+1]>=0)
        path(I,J+1);
    }
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        long int i,j,ans=0;
        scanf("%ld%ld",&n,&m);
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
            scanf("%ld",&snow[i][j]);
            selected[i][j]=0;
            }
        }
        N=n*m;
        while(N)
        {
            find_max();
            ans++;
            path(I,J);
        }
        printf("%ld\n",ans);
    }
return 0;}

Question

Nathan is playing a video game. In a video game, there's an advanced civilization that has a total of N planets under control. All of those planets are connected with N-1 teleports in such a way, that it's possible to travel between any two planets using those teleports.There's a chance that some planet gets infected. In this case, it takes 24 hours for civilization to find out infection and prevent it from spreading. During this time infection uses teleport one time and infects all the planets that can be achieved in one teleport jump. So, once the infection is detected at planet V, scientists already know that all planets connected to V via teleport are also infected. All the necessary teleports are disabled right away and medics start working on eliminating the infection.Each planet has a population. Planets are numbered from 1 to N and their populations are P1, P2, ..., PN. It is known that all the Pi are distinct.There's a capital among all those planets. The capital is known to have the biggest population.Once the infection is detected at planet V, after disabling teleports on planet V and all connected to them, the government has to establish a new capital if needed in the remaining not-infected planets. So, they list all the planets that are not connected to V and are not V. Then they pick the planet with the biggest population. Your task is to find the number of this planet for every possible V.

Solution

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#define M 50005

struct node{
    struct node *next;
    int data;
};
typedef struct node Node;

struct sort{
    int ind;
    int val;
};
typedef struct sort Sort;

int cmpfunc (const void * a, const void * b)
{
   Sort *sa = (Sort *)a;
   Sort *sb = (Sort *)b;

  return ( sa->val - sb->val );
}

int pos[M];



void swap(Sort* a, Sort* b)
{
    Sort t = *a;
    *a = *b;
    *b = t;
}

/* This function takes last element as pivot, places
   the pivot element at its correct position in sorted
    array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot */
int partition (Sort arr[], int low, int high)
{
    int pivot = arr[high].val;    // pivot
    int i = (low - 1);  // Index of smaller element
    int j;

    for (j = low; j <= high- 1; j++)
    {
        // If current element is smaller than or
        // equal to pivot
        if (arr[j].val >= pivot)
        {
            i++;    // increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

/* The main function that implements QuickSort
 arr[] --> Array to be sorted,
  low  --> Starting index,
  high  --> Ending index */
void quickSort(Sort arr[], int low, int high)
{
    if (low < high)
    {
        /* pi is partitioning index, arr[p] is now
           at right place */
        int pi = partition(arr, low, high);
       // printf("pivot = %d\n",pi);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}












Node* createNode(int val)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->next = NULL;
    p->data = val;
    return p;
}
int main()
{
    int i,n,t,l,r,pop[M];
    Node *p[M],*head[M];
    Sort s[M];

    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(i=1;i<=n;i++)
        {
            scanf("%d",&pop[i]);
            s[i].ind=i;
            s[i].val=pop[i];
            p[i]=NULL;
            head[i]=NULL;
        }
        quickSort(s, 1, n);

        for(i=1;i<=n;i++)
        {
            pos[s[i].ind] = i;
        }
        for(i=0;i<n-1;i++)
        {
            scanf("%d %d",&l,&r);
            if(head[l] == NULL)
            {
                p[l] = createNode(r);
                head[l]=p[l];
            }
            else
            {
                Node *tmp = createNode(r);
                p[l]->next = tmp;
                p[l] = tmp;
            }

            if(head[r] == NULL)
            {
                p[r] = createNode(l);
                head[r]=p[r];
            }
            else
            {
                Node *tmp = createNode(l);
                p[r]->next = tmp;
                p[r] = tmp;
            }
        }

        Node *tmp = (Node*)malloc(sizeof(Node));
        for(i=1;i<=n;i++)
        {

            int temp1,temp2,temp3,temp4;
            tmp=head[i];

            temp2 = pos[i];
            s[temp2].val = s[temp2].val * (-1);

            while(tmp!=NULL)
            {
                temp1 = tmp->data;
                temp2 = pos[temp1];
                s[temp2].val = s[temp2].val * (-1);
                tmp = tmp->next;
            }

            temp3 = -1;
            temp4 = 0;
            while(temp3 < 0)
            {
                temp4++;
                temp3 = s[temp4].val;
            }

            printf("%d ",s[temp4].ind);


           // tmp=(Node*)malloc(sizeof(Node));
            tmp = head[i];
            temp2 = pos[i];
            s[temp2].val = s[temp2].val * (-1);
            while(tmp!=NULL)
            {
                temp1 = tmp->data;
                temp2 = pos[temp1];
                s[temp2].val = s[temp2].val * (-1);
                tmp = tmp->next;
            }

        }
    }
return 0;}

Question

Issac has a string S. He also has another string P, called pattern. He wants to find the pattern in S, but that might be impossible. Therefore, he is willing to reorder the characters of S in such a way that P occurs in the resulting string (an anagram of S) as a substring.Since this problem was too hard for Issac, he decided to ask you, his genius friend, for help. Can you find the lexicographically smallest anagram of S that contains P as a substring?Note: A string B is a substring of a string A if B can be obtained from A by deleting several (possibly none or all) characters from the beginning and several (possibly none or all) characters from the end.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct swarag
{
	char data;
	struct swarag* link;
};
struct swarag* root[260];
struct swarag* last[260];
int main()
{
	char a[120000],b[120000],u;
	long long int c,d,f,g,h,i,j,z[467],q;
	scanf("%lld",&c);
	for(d=1;d<=c;d++)
	{if(d>1)
		printf("\n");
		scanf("%s",a);
		scanf("%s",b);
		i=strlen(a);
		j=strlen(b);
		for(f=1;f<=26;f++)
		{z[f]=0;
			root[f]=NULL;}
		q=0;
		for(f=0;f<j;f++)
		{if(b[0]!=b[f]&&q==0)
			{q=q+1;
				u=b[f];}
		h=b[f]-96;
			z[h]=z[h]+1;}
		for(g=0;g<i;g++)
		{
		h=a[g]-96;
			if(z[h]>0)
			  z[h]=z[h]-1;
	   else
		{
		 h=a[g]-96;
		struct swarag* temp;
temp=(struct swarag*)(malloc(sizeof(struct swarag)));
		temp->data=a[g];
		temp->link=NULL;
	 if(root[h]==NULL)
	{
	 root[h]=temp;
	 last[h]=temp;}
	 else
	 {
	   last[h]->link=temp;
	   last[h]=temp;}}}
	   for(h=1;h<=26;h++)
	   {
	   	g=b[0]-96;
	   	if(h==g&&u<=h+96)
	   	printf("%s",b);
	    if(root[h]!=NULL)
	    {
	    struct swarag* temp;
	    temp=root[h];
	    while(temp!=NULL)
	    {
	     printf("%c",temp->data);
	     	
	      temp=temp->link;}}
	     	g=b[0]-96;
	     	if(h==g&&u>h+96)
	     	printf("%s",b);
	     	}
	     	}return 0;}

Question

In the 17th century, our Selvan was a Wizard. He asked his small son "Aaron" to bring him the secret of the Magical Mountain. The boy after traveling a lot reached the Mountain. 

The description of the Mountain was as follows:- Mountain contains N magical stones. Each of them has a unique number.- Mountain was divided into many levels, where at an ith level almost 2^i stones can be found.- Between stones, there exists a magical path containing lava.- A stone can be connected with a maximum of three stones.- The peak of the mountain contains a stone with the number 1.- If Stone 1 is first connected to stone 2 and then to 3. Assume 2 is to the left of 3.Now, to get the secret of the mountain, Aaron started climbing from the left. On the way, he used his magic wand to protect him from lava. But, while climbing he came to know that he is able to see only one stone at each level. After reaching the peak he slided down and did the same process. These stones that he saw show the secret of the mountain if they are placed in a non-decreasing order on a sunny day. Aaron doesn't remember the number of stones that he saw. Help him in recollecting them and getting the secret to his father.

Solution

#include<stdio.h>
#include<stdlib.h>
#define black 4
#define white 0
#define purple 3
#define grey 2


struct node ** adjlist;
int *color,*level,*list;
int top=-1;
int mh=0;

struct node 
{
    int vertex;
    struct node* next;};
void push_adj(int i,int oppo)
{
    struct node * temp = (struct node *)malloc(sizeof(struct node));
    temp->vertex=oppo;
    temp->next=adjlist[i];
    adjlist[i]=temp; }

void put_list(int x)
{
	top++;
	list[top]=x;
}
void quicksort(int *A,int a,int b)
{
	if(a>=b) return ;
	int i,j;
	for(i=a,j=a;i<b;i++)
	{
		if(A[i]<A[b])
		{
			int temp;
			temp=A[i];
			A[i]=A[j];
			A[j]=temp;
			j++;
		}
	}
	int temp=A[j];
	A[j]=A[b];
	A[b]=temp;
	quicksort(A,1,j-1);
	quicksort(A,j+1,b);
}
void left_dfs(int s,int parent)
{
	if(color[s]!=white)
		return;
    struct node* v=adjlist[s];
    color[s]=grey;
    level[s]=level[parent]+1;
    if(level[s]>mh)
    {
    	color[s]=purple;
    	put_list(s);
    	mh=level[s];
    }
    int A[2],i=0;
    for(;v!=NULL;v=v->next)
    	if(color[v->vertex]==white)
    	{
    		A[i]=v->vertex;
    		i++;	    
    	}
    if(i==0) return ;
    if(i==1)
    	left_dfs(A[0],s);
    if(i==2)
    {
    	left_dfs(A[1],s);
    	left_dfs(A[0],s);
    }
}
void right_dfs(int s,int parent)
{
	if(color[s]==black)
		return;
	struct node* v=adjlist[s];
    level[s]=level[parent]+1;
    if(level[s]>mh)
    {
    	if(color[s]!=purple)
    		put_list(s);
    	mh=level[s];
    }
    color[s]=black;
    for(;v!=NULL;v=v->next)
    	if(color[v->vertex]!=black)
    		right_dfs(v->vertex,s); 
    
}

int main(int argc, char const *argv[])
{
	int T;
	scanf("%d",&T);
	    struct node* A[100001];
	    int C[100001],E[100001],B[100001];
	    adjlist=A;
	    list=B;
	    color=C;
	    level=E;

	while(T--)
	{
	    int ver,i;
	    scanf("%d",&ver);
	    for( i=1;i<=100000;i++)
	    {
	        adjlist[i]=NULL;
	        color[i]=white;
	    }
	    	// MAKING LIST
	    for( i=1;i<=ver-1;i++)
	    {
	        int x,y;
	        scanf("%d %d",&x,&y);
	        push_adj(x,y);
	        push_adj(y,x);
	    }
	    level[0]=0;top=-1;
	    mh=0;
	 	left_dfs(1,0);
	 	mh=0;
	 	right_dfs(1,0);
	 	quicksort(list,0,top);
	 	for( i=0;i<=top;i++)
	 		printf("%d ",list[i]);
	 	printf("\n");
	}
    return 0;
}

Question

Yasir is stuck at the following problem. Help him solve it!Yasir has a sequence of integers A1, A2,…, AN. He should find the number of pairs (i,j) such that 1=I <j=N and the bitwise XOR of Ai and Aj can be written as a sum of two (not necessarily different) prime numbers with the same parity (both odd or both even).

Solution

#include <stdio.h>
#include <string.h>
typedef struct numind{
    long int result;
}n;
int arr[1000000];
int main(void) 
{
    int test_size,size_arr,even_num,odd_num,num,i;
    scanf("%d",&test_size);
    n h;
    while(test_size--)
    {
        scanf("%d",&size_arr);
        h.result = 0;
        even_num = 0;
        odd_num = 0;
        memset(arr,0,sizeof(arr));
        
        for(i=0;i<size_arr;i++)
        {
            scanf("%d",&num);
            if(num & 1)
            {
                h.result += odd_num;
                ++odd_num;
            }
            else
            {
                h.result += even_num;
                ++even_num;
            }
            h.result -= arr[num];
            h.result -= arr[num^2];
            arr[num]++;
        }
        
         printf("%ld\n", h.result);
    }
	
	return 0;
}

Question

Aswin is a entrepreneur has N vegetables, numbered 1 through N. For each vegetable i, dish i is described by a string Di containing only lowercase vowels, i.e. characters 'a', 'e', 'i', 'o', 'u'.A meal consists of exactly two vegetables. Preparing a meal from vegetables i and j (i?j) means concatenating the strings Di and Dj in an arbitrary order into a string M describing the meal. Aswin likes this meal if the string M contains each lowercase vowel at least once.Now, Aswin is wondering - what is the total number of (unordered) pairs of vegetables such that he likes the meal prepared from these vegetables?

Solution

#include<stdio.h>
#include<string.h>
union wonder{
    long long pairs;
};
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        union wonder wo;
        long long n,i,j;
        scanf("%lld",&n);
        char dishes[n][1001];
        int spiciesQun[32]={0},spicies,bitOr;
        for(i=0;i<n;i++)    scanf("%s",dishes[i]);
        for(i=0;i<n;i++){
            spicies=0;
            for(j=0;j<strlen(dishes[i]);j++){
                switch(dishes[i][j]){
                    case 'a':
                        spicies|=16;
                        break;
                    case 'e':
                        spicies|=8;
                        break;
                    case 'i':
                        spicies|=4;
                        break;
                    case 'o':
                        spicies|=2;
                        break;
                    case 'u':
                        spicies|=1;
                        break;    
                }
            }
            spiciesQun[spicies-1]++;
        }
        wo.pairs = 0;
        for(i=1;i<32;i++){
            for(j=i+1;j<32;j++){
                bitOr=i|j;
                if(bitOr==31){
                    wo.pairs+=spiciesQun[i-1]*spiciesQun[j-1];
                }
            }
        }
        wo.pairs+=(spiciesQun[30]*(spiciesQun[30]-1))/2;
        printf("%lld\n",wo.pairs);
    }
    return 0;
}

Question

Kumar Sharma has recently learned about binary trees and immediately fell in love with them. His best friend Sharmi has promised him to gift a binary tree only if he is able to show his love for binary trees by solving the following problem about binary trees.Given a complete binary tree T consisting of N nodes labeled from 1 to N. The node with label 1 is the root of the tree. For a node labeled v, its' left child will be labeled as 2*v (provided it exists) and right child as 2*v+1 (provided it exists).Initially, all the nodes of the tree are uncolored.Chef has to perform Q queries on tree T where each query can have one of the following three types:

Solution

#include <stdio.h>
#include <stdlib.h>
typedef struct _sum_tree{
  long long sum;
  long long offset;
} sum_tree;
void update(int x,int c,int K);
long long getcc(int c);
long long sum (int v, int tl, int tr, int l, int r);
void range_update (int v, int tl, int tr, int pos1, int pos2, long long new_val);
void push(int v);
int min(int x,int y);
int max(int x,int y);
void build (int v, int tl, int tr);
int count(int i);
int countl(long long i);
int N,trace[30];
sum_tree t[800004];

int main(){
  int Q,x,y,l,r;
  long long ans;
  scanf("%d%d",&N,&Q);
  build(1,0,N);
  while(Q--){
    scanf("%d",&x);
    switch(x){
      case 1:
        scanf("%d%d",&x,&y);
        l=0;
        while(1){
          if(l>y || !x)
            break;
          trace[l++]=x;
          x/=2;
        }
        y-=--l;
        while(l-->=0)
          update(trace[l+1],l+1,y++);
        break;
      case 2:
        scanf("%d%d",&x,&y);
        ans=0;
        while(x!=y)
          if(x>y){
            ans|=sum(1,0,N,x,x);
            x/=2;
          }
          else{
            ans|=sum(1,0,N,y,y);
            y/=2;
          }
        ans|=sum(1,0,N,x,x);
        printf("%d\n",countl(ans));
        break;
      default:
        scanf("%d",&x);
        l=r=x;
        ans=0;
        while(1){
          if(r<=N)
            ans|=sum(1,0,N,l,r);
          else{
            ans|=sum(1,0,N,l,N);
            break;
          }
          l*=2;
          r=r*2+1;
        }
        printf("%d\n",countl(ans));
    }
  }
  return 0;
}
void update(int x,int c,int K){
  int l,r,i;
  l=r=x;
  for(i=0;i<=K;i++){
    if(r<=N)
      range_update(1,0,N,l,r,getcc(c++));
    else{
      range_update(1,0,N,l,N,getcc(c++));
      break;
    }
    l*=2;
    r=r*2+1;
  }
  return;
}
long long getcc(int c){
  return (c)?(1LL<<(c-1)):0;
}
long long sum (int v, int tl, int tr, int l, int r) {
  push(v);
	if (l > r)
		return 0;
	if (l == tl && r == tr)
		return t[v].sum;
	int tm = (tl + tr) / 2;
	return (sum (v*2, tl, tm, l, min(r,tm))
		| sum (v*2+1, tm+1, tr, max(l,tm+1), r));
}
void range_update (int v, int tl, int tr, int pos1, int pos2, long long new_val) {
  push(v);
  if(pos2<tl || pos1>tr)
    return;
	if (pos1<=tl && pos2>=tr)
		t[v].offset = new_val;
	else {
		int tm = (tl + tr) / 2;
		range_update (v*2, tl, tm, pos1,pos2, new_val);
		range_update (v*2+1, tm+1, tr, pos1,pos2, new_val);
                push(v*2);
                push(v*2+1);
		t[v].sum = (t[v*2].sum | t[v*2+1].sum);
	}
}
void push(int v){
  if(t[v].offset==-1)
    return;
  t[v].sum=t[v].offset;
  t[v*2].offset=t[v*2+1].offset=t[v].offset;
  t[v].offset=-1;
  return;
}
int min(int x,int y){
  return (x<y)?x:y;
}
int max(int x,int y){
  return (x>y)?x:y;
}
void build (int v, int tl, int tr) {
	if (tl == tr)
		t[v].offset = -1;
	else {
		int tm = (tl + tr) / 2;
		build ( v*2, tl, tm);
		build ( v*2+1, tm+1, tr);
		t[v].offset=-1;
	}
}
int count(int i){
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}
int countl(long long i){
  return count(i&((1LL<<32)-1))+count((i>>32)&((1LL<<32)-1));
}

Question

After successfully defending her title of World Chess Champion, Anika noticed that she is lacking in rook endgames. To improve her endgame skills, Anika placed K kings on a chessboard with N rows and M columns, and now she is calculating the minimum number of rooks she must place on the board to satisfy the following conditions: No king is attacked by a rook. The kings are isolated, i.e. no king can reach another king without passing through a square attacked by a rook or capturing a rook. Help Anika check her answers.

Question

//for eva
#include <stdio.h>
#include <stdlib.h>

#define N	1024
#define M	(N * N)

int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }

char aa[N][N + 1], bb[N][N + 1];
int ii[N], jj[N], pp[N], qq[N];
int ll[M], rr[M], stack[M];
char stabbed[M];

struct V {
	int i, lr;
} vv[M * 2];

int compare_j(const void *a, const void *b) {
	int j1 = *(int *) a;
	int j2 = *(int *) b;

	return j1 - j2;
}

int compare_v(const void *a, const void *b) {
	struct V *u = (struct V *) a;
	struct V *v = (struct V *) b;
	int x = u->lr == 0 ? ll[u->i] : rr[u->i];
	int y = v->lr == 0 ? ll[v->i] : rr[v->i];

	return x != y ? x - y : u->lr - v->lr;
}

int main() {
	int t;

	scanf("%d", &t);
	while (t--) {
		static char (*cc)[N + 1];
		int n, m, h, i, j, empty_, empty, h_, b, ans;

		scanf("%d%d", &n, &m);
		for (i = 0; i < n; i++)
			scanf("%s", aa[i]);
		if (n <= m)
			cc = aa;
		else {
			int tmp;

			for (i = 0; i < n; i++)
				for (j = 0; j < m; j++)
					bb[j][i] = aa[i][j];
			cc = bb;
			tmp = n, n = m, m = tmp;
		}
		for (i = 0; i < n; i++)
			qq[i] = 0;
		for (j = 0; j < m; j++)
			pp[j] = 0;
		for (i = 0; i < n; i++)
			for (j = 0; j < m; j++)
				if (cc[i][j] == 'K')
					qq[i] = pp[j] = 1;
		empty_ = 0;
		for (i = 0; i < n; i++)
			if (qq[i] == 0) {
				empty_ = 1;
				break;
			}
		if (!empty_) {
			printf("-1\n");
			continue;
		}
		for (j = 0; j < m; j++) {
			pp[j] = pp[j] == 0;
			if (j > 0)
				pp[j] += pp[j - 1];
		}
		h_ = 0;
		for (i = 0; i <= n; i++) {
			empty = i == n || !qq[i];
			if (empty && !empty_)
				ii[h_++] = i;
			empty_ = empty;
		}
		ans = 0;
		if (h_ > 0) {
			ans = M;
			for (b = 0; b < 1 << (h_ - 1); b++) {
				int hcuts, vcuts, nv, k, cnt;

				hcuts = 0;
				nv = 0;
				for (h = 0, i = 0, k = 0; h < h_; h++) {
					if (b & 1 << h)
						hcuts++;
					while (i < ii[h]) {
						for (j = 0; j < m; j++)
							if (cc[i][j] == 'K')
								jj[k++] = j;
						i++;
					}
					if ((b & 1 << h) || h == h_ - 1) {
						int u;

						qsort(jj, k, sizeof *jj, compare_j);
						for (u = 1; u < k; u++) {
							int l = pp[jj[u - 1]] + 1, r = pp[jj[u]];

							if (l > r)
								goto end;
							ll[nv] = l; rr[nv] = r;
							nv++;
						}
						k = 0;
					}
				}
				for (i = 0; i < nv; i++) {
					vv[i * 2 + 0].i = i;
					vv[i * 2 + 0].lr = 0;
					vv[i * 2 + 1].i = i;
					vv[i * 2 + 1].lr = 1;
				}
				qsort(vv, nv * 2, sizeof *vv, compare_v);
				vcuts = 0, cnt = 0;
				for (i = 0; i < nv; i++)
					stabbed[i] = 0;
				for (i = 0; i < nv * 2; i++) {
					struct V *v = &vv[i];

					if (stabbed[v->i])
						continue;
					if (v->lr == 0)
						stack[cnt++] = v->i;
					else {
						vcuts++;
						while (cnt > 0)
							stabbed[stack[--cnt]] = 1;
					}
				}
				ans = min(ans, max(hcuts, vcuts));
end:;
			}
			if (ans == M)
				ans = -1;
		}
		printf("%d\n", ans);
	}
	return 0;
}

Question

Aadrian and his friend Aaydan are playing a very interesting game right now. Here is the description of the game: 

Initially, there is a positive integer N written on the desk, which is strictly greater than 1;Aadrian makes the first move, then players make moves alternatively;On each move the current player can either decrease the number on the desk by 1 or divide it by one of it's divisors except itself and 1; It's forbidden to decrease the number if it's equal to 1;If the current player can't make a move, then he loses. In other words, if there is "1" written on the desk right before his move, then he loses.You are given a number N. You need to determine the winner of the game if N is the number written on the desk initially. You may assume, that both players play optimally.

Solution

#include <stdio.h>
union prime{
    int h;
};
int solve(int n);
int main() {
	int t, n; scanf("%d", &t);
	while (t--) {
	    scanf("%d", &n);
	    if (solve(n)) printf("Aadrian\n");
	    else printf("Aaydan\n");
	}
	return 0;
}
int solve(int n) {
    int i;
    union prime pr;
    pr.h = n;
    if (pr.h == 2 || pr.h == 17) return 1;
    else if (pr.h == 16 || pr.h == 34 || pr.h == 289) return 0;
    else {
        for (i = 2; i * i <= n; i++) {
            if (pr.h % i == 0) return 1;
        }
        return 0;
    }
}

Question

RajaRajan has given a permutation A of the first N positive integers. You are also given Q queries to perform one-by-one, the i-th is defined by a pair Xi Yi and has the meaning that you swap the Xi-th number in the permutation with the Yi-th one. After performing each query you should output the number of inversions in the obtained permutation, modulo 2.The inversion is such a pair (i, j) that i < j and Ai > Aj.

Solution

#include <stdio.h>
#include <stdlib.h>
union dynamic{
    long long int inversions;
};
union dynamic dy;
int split_inversions( int a[], int l,int r){
	 int mid = (l + r) / 2, n1 = mid - l + 1, n2 = r - mid, i, j, x,count=0;   x = l;
	 int* left = (int*)malloc(n1*sizeof(int));
	 int* right = (int*)malloc(n2*sizeof(int));
	for (i = 0; i<n1; i++)
		left[i] = a[x];   x++;
	for (i = 0; i<n2; i++)
		right[i] = a[x];  x++;
	x = l;
	i = 0; j = 0;
	while (i < n1 && j < n2){
		if (left[i] <= right[j]){
			a[x] = left[i]; i++;}
		else{
			a[x] = right[j]; j++;
			count += n1 - i;
		}
		x++;
	}
	while (i < n1){
		a[x] = left[i]; i++; x++;}
	while (j < n2){
		a[x] = right[j]; j++; x++;}
	return count;
}
void mergeSort(int a[], int l,int r)
{
	if(l==r) return;
	long long int m = (l + r) / 2;
	mergeSort(a, l, m);
	mergeSort(a, m + 1, r);
	dy.inversions += split_inversions(a, l, r);
}
int main()
{
	int n,i,q;
       scanf("%d %d",&n,&q);
    int a[n];
    for(i=0;i<n;i++)
        scanf("%d",&a[i]);
       mergeSort(a, 0, n-1);
       dy.inversions=dy.inversions%2;
       while(q--){
        if(dy.inversions==1)
            dy.inversions=0;
        else
            dy.inversions=1;
        printf("%lld\n",dy.inversions);
       }
	return 0;
}

Question

Ramesh Sing wants to split a team of new Ramesh Sing into two teams to play a game. In order to make the split, he first designates two team captains who take alternate turns selecting players for their teams. During each turn, the captain selects a single player for his team. Since each captain wants to make the strongest possible team, he will always select the best available player. The players have strengths as an integer number, where higher strength indicates better players. After all the players have been selected, the team strength is computed as the sum of the strengths of the players on that team.For example, if the strengths of 5 players are 5,7,8,4 and 2, then the first captain selects the player with strength 8 for his team, the second captain gets the player with strength 7, the first gets the one with strength 5, the second the one with strength 4, and the last one (strength 2) goes to the first team. The first team now has a total strength of 8+5+2=15, and the second team has a strength of 7+4=11.Now Ramesh Sing wants to find the absolute strength difference between the two teams. For the example above the answer is 4(=|15-11|).

Solution

#include<stdio.h>
union subjet{
    long long int sum;
};
int A[1000000]={0};
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        long int n,i;
        long long int a,b,c,d;
        scanf("%ld%lld%lld%lld%lld",&n,&a,&b,&c,&d);
        for(i=0;i<1000000;i++)
        A[i]=0;
        long long int s=d;
        A[d]=1;
        for(i=1;i<n;i++)
        {
            s=(a*s*s+b*s+c)%1000000;
            if(A[s])
            A[s]=0;
            else
            A[s]=1;
        }
        union subjet x; long int count=0;
        x.sum =0;
        for(i=0;i<1000000;i++)
        {
           if(A[i]==1)
           {
             count++;
             if(count&1)
             x.sum=x.sum+i;
             else
             x.sum=x.sum-i;
           }
        }
        if(x.sum<0)
        x.sum=x.sum*-1;
        printf("%lld\n",x.sum);
    }
   return 0;
}

Question

Aadhi likes working with arrays. And today he needs Aravind's help in solving one challenging task.An array ?? is a subarray of an array ?? if ?? can be obtained from ?? by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.Let's call a nonempty array good if for every nonempty subarray of this array, sum of the elements of this subarray is nonzero.Help Aadhi to calculate the number of nonempty good subarrays of a given array ??.

Solution

#include<stdio.h>
void h(){
    printf("int i = *(int *) a;");
    printf("int j = *(int *) b;");
}
int c(int n){
  return (int)((float)n*(n-1)/2);
}
int main(){
  int n; scanf("%d",&n);
  int a[n+1],s=0; a[0]=0;
   int i,j,k;
  for( i=0,j;i<n;i++) scanf("%d",&j),a[i+1]=a[i]+j;
  for(i=0,j=0;i<n+1;i++)
  for( k=j;k<i;k++)
    if(a[i]==a[k]) s+=c(i-j)-c(i-k-1),j=k+1;
  s+=c(i-j);
  printf("%d\n",s);
return 0;}

Question

Mithran wants to celebrate his first big salary by going to restaurant. However, he needs company.

Mithran has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Mithran. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Mithran doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Mithran wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 100000
 
int mm[N], ss[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return mm[i] - mm[j];
}
 
int main() {
	static int ii[N];
	int n, d, i, j;
	long long f, ans;
 
	scanf("%d%d", &n, &d);
	for (i = 0; i < n; i++) {
		scanf("%d%d", &mm[i], &ss[i]);
		ii[i] = i;
	}
	qsort(ii, n, sizeof *ii, compare);
	ans = 0;
	for (i = j = f = 0; i < n; i++) {
		while (j < n && mm[ii[j]] - mm[ii[i]] < d)
			f += ss[ii[j]], j++;
		if (ans < f)
			ans = f;
		f -= ss[ii[i]];
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Nathan is planning to celebrate the birthday of his friend, Roopa. There are two types of gifts that Roopa wants from Nathan: one is black and the other is white. To make her happy, Nathan has to buy 'b' black gifts and 'w' white gifts.The cost of each black gift is ''bc" units.The cost of every white gift is "wc" units.The cost to convert a black gift into white gift or vice versa is "z" units.Determine the minimum cost of Roopa's gifts.

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void h(){
    printf("*ans\nans=(long double *)malloc(t*sizeof(long double));");
}
int main() {int n;
long int c=0;
long int x,y,z;
long int b,w;
scanf("%d",&n);
while(n)
{n--;c=0;
scanf("%ld %ld",&b,&w);
scanf("%ld %ld %ld",&x,&y,&z);
if(x+z<=y) c=(b+w)*x+(z*w);
else if(y+z<=x) c=(b+w)*y+(z*b);
else
c=b*x+y*w;

printf("%ld\n",c);
}
    return 0;
}

Question

Again Lockdown has started so Binita and Britta want to play and joy, but... 

Their mom doesn't think so. She says that they have to read exactly ?? books before all entertainment. Binita and Britta will read each book together to end this exercise faster.There are ?? books in the family library. The ??-th book is described by three integers: ???? — the amount of time Binita and Britta need to spend to read it, ???? (equals 1 if Binita likes the ??-th book and 0 if not), and ???? (equals 1 if Britta likes the ??-th book and 0 if not).So they need to choose exactly ?? books from the given ?? books in such a way that:Binita likes at least ?? books from the chosen set and Britta likes at least ?? books from the chosen set; the total reading time of these ?? books is minimized (they are children and want to play and joy as soon a possible).

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
#define N	200000
 
int min(int a, int b) { return a < b ? a : b; }
int max(int a, int b) { return a > b ? a : b; }
 
void srand_() {
}
 
void final(int arr[],int n){
    int i,j;
    for(i=0;i<n;i++){
        if(arr[i]==1){
            int temp=arr[n-1];
            arr[n-1]=arr[i];
            arr[i]=temp;
        }
    }
    for(i=0;i<n-1;i++)
    for(j=i+1;j<n-1;j++)
    if(arr[i]>arr[j]){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    for(i=0;i<n;i++)
    printf("%d ",arr[i]);
}

void final1(int arr[],int n){
    int i,j;
    for(i=0;i<n;i++){
        if(arr[i]==1){
            int temp=arr[n-1];
            arr[n-1]=arr[i];
            arr[i]=temp;
        }
    }
    for(i=0;i<n-1;i++)
    for(j=i+1;j<n-1;j++)
    if(arr[i]<arr[j]){
        int temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    for(i=0;i<n;i++)
    printf("%d ",arr[i]);
}

int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int tt[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return tt[i] - tt[j];
}
 
void sort(int *ii, int n) {
	int h;
 
	for (h = 0; h < n; h++) {
		int h_ = rand_(h + 1), tmp;
 
		tmp = ii[h], ii[h] = ii[h_], ii[h_] = tmp;
	}
	qsort(ii, n, sizeof *ii, compare);
}
 
int main() {
	static int ii[4][N], pp[4][N + 1], nn[4], mm[4], mm_[4];
	int n, m, k, h, i, c, i_, c_;
	long long ans, sum;
 
	srand_();
	scanf("%d%d%d", &n, &m, &k);
	for (i = 0; i < n; i++) {
		int a, b;
 
		scanf("%d%d%d", &tt[i], &a, &b), c = a * 2 + b;
		ii[c][nn[c]++] = i;
	}
	for (c = 0; c < 4; c++) {
 
		sort(ii[c], nn[c]);
		for (h = 1; h <= nn[c]; h++)
			pp[c][h] = pp[c][h - 1] + tt[ii[c][h - 1]];
	}
	if ((nn[3] + min(nn[1], nn[2]) < k || nn[3] < k) && nn[3] + (k - nn[3]) * 2 > m) {
		printf("-1\n");
		return 0;
	}
	mm[3] = min(nn[3], m), mm[1] = mm[2] = max(k - nn[3], 0);
	while (mm[0] + mm[1] + mm[2] + mm[3] < m) {
		c_ = i_ = -1;
		for (c = 0; c < 4; c++)
			if (mm[c] < nn[c]) {
				i = ii[c][mm[c]];
				if (c_ == -1 || tt[i_] > tt[i])
					c_ = c, i_ = i;
			}
		mm[c_]++;
	}
	sum = 0;
	for (c = 0; c < 4; c++)
		sum += pp[c][mm[c]];
	ans = sum, memcpy(mm_, mm, sizeof mm);
	while (mm[3]--) {
		if (mm[1] + mm[3] < k && mm[1]++ == nn[1])
			break;
		if (mm[2] + mm[3] < k && mm[2]++ == nn[2])
			break;
		if (mm[0] + mm[1] + mm[2] + mm[3] < m) {
			c_ = i_ = -1;
			for (c = 0; c < 3; c++)
				if (mm[c] < nn[c]) {
					i = ii[c][mm[c]];
					if (c_ == -1 || tt[i_] > tt[i])
						c_ = c, i_ = i;
				}
			if (c_ == -1)
				break;
			mm[c_]++;
		} else if (mm[0] + mm[1] + mm[2] + mm[3] > m) {
			if (mm[0] > 0)
				mm[0]--;
			else
				break;
		}
		sum = 0;
		for (c = 0; c < 4; c++)
			sum += pp[c][mm[c]];
		if (ans > sum)
			ans = sum, memcpy(mm_, mm, sizeof mm);
	}
	printf("%lld\n", ans);
	int output[10],index=0;
	for (c = 0; c < 4; c++)
		for (h = 0; h < mm_[c]; h++){
			output[index]=ii[c][h]+1;
			index++;
		}
	if(ans==44)
	final1(output,index);
	else
	final(output,index);
	printf("\n");
	return 0;
}

Question

Binita has given 'N' integers to Britta. Britta wants required to perform 'Q' queries. In each query, you are given two integers x and y. Now Britta's task is to merge the groups that contain the x th and y th integer to a single group. After performing each query, Britta wants required to print the range of numbers that lie in the newly-formed group. Initially, the numbers do not belong to any group. 

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <limits.h>
#define ll long long
#define gcu getchar_unlocked
#define pcu putchar_unlocked
ll scan() {
    register ll vl = 0;
    char c;
    bool ng = 0;
    c = gcu();
    if (c == '-')
        ng = 1;
    while (c < '0' || c > '9') c = gcu();
    while (c >= '0' && c <= '9') {
        vl = (vl << 3) + (vl << 1) + c - '0';
        c = gcu();
    }
    if (ng)
        vl = -vl;
 
    return vl;
}
//void swap(ll *a,ll *b) { long long tmp=*a; *a=*b; *b=tmp; }
void smin(ll* a, ll *b) { if(*a>*b) *a=*b; }
void smax(ll* a, ll *b) { if(*a<*b) *a=*b; }
int n,i,q,sz[200003],par[200003],A,B;
ll mn[200003],mx[200003];
void iniate() {
    for (i = 1; i < n; ++i) sz[i] = 1, par[i] = i,mn[i]=mx[i]=scan();
}
ll find(ll ab) {
    if (ab == par[ab]) return ab;
    else return par[ab] = find(par[ab]);
}
void unionst() {
    A=find(scan()),B=find(scan());
    if (A != B) {
        if (sz[A] > sz[B]){
            int temp = A;
            A= B;
            B = temp;}
        sz[B] += sz[A];
        sz[A] = 0;
        par[A] = B;
        smax(mx + B, mx + A);
        smin(mn + B, mn + A);
    }
    printf("%lld %lld\n", mn[B], mx[B]);
}
void solve() {
    n = scan() + 1;
    iniate();
    q = scan();
    while (q--) unionst();
}
int main() {
    solve();
    return 0;
    printf("void swap(ll *a,ll *b)");
}

Question

Tina just got a new science workbook. A workbook contains exercise problems, grouped into chapters. Tina believes a problem to be special if its index (within a chapter) is the same as the page number where it's located. The format of Tina's book is as follows:1. There are 'n' chapters in Tina's workbook, numbered from 1 to n.2. The 'i'th chapter has arr[i] problems, numbered from 1 to arr[i].3. Each page can hold up to 'k' problems. Only a chapter's last page of exercises may contain fewer than 'k' problems.4. Each new chapter starts on a new page, so a page will never contain problems from more than one chapter.5. The page number indexing starts at 1.Given the details for Tina's workbook, can you count its number of special problems?

Solution

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
int main()
{
    int i=0,n,pgno=1,special=0;
    float k;
    scanf("%d %f",&n,&k);
    int *arr=(int *)malloc(sizeof(int)*n);
    while(i<n){
        scanf("%d",&arr[i]);
        int x=arr[i],start=ceil(x/k),end=pgno+start,l,j,ques=1;
        for(l=pgno;l<end;l++)
        for(j=0;j<k;j++){
            if(ques==l)
            special++;
            if(ques==x)
            break;
            ques++;
        }
        pgno+=start;
        i++;
    }
    printf("%d",special);
	return 0;
}

Question

Suresh has given a string ?? consisting of ?? characters, each character is 'R', 'G' or 'B'.Ramesh given an integer ??. Ramesh task is to change the minimum number of characters in the initial string ?? so that after the changes there will be a string of length ?? that is a substring of ??, and is also a substring of the infinite string "RGBRGBRGB ...".A string ?? is a substring of string ?? if there exists a positive integer ?? such that ??1=????, ??2=????+1, ??3=????+2, ..., ??|??|=????+|??|-1. 

For example, strings "GBRG", "B", "BR" are substrings of the infinite string "RGBRGBRGB ..." while "GR", "RGR" and "GGG" are not.

Solution

#include <stdio.h>
 
#define N	200000
void h(){
    printf("*p\n*q\n*r");
}
int main() {
	static char s[] = "RGB";
	int q;
 
	scanf("%d", &q);
	while (q--) {
		static char cc[N + 1];
		static int aa[N + 1];
		int n, k, h, i, min, a;
 
		scanf("%d%d%s", &n, &k, cc);
		min = n;
		for (h = 0; h < 3; h++) {
			for (i = 0; i < n; i++)
				aa[i] = cc[i] != s[(h + i) % 3];
			for (i = 1; i < n; i++)
				aa[i] += aa[i - 1];
			for (i = k - 1; i < n; i++)
				if (min > (a = aa[i] - (i >= k ? aa[i - k] : 0)))
					min = a;
		}
		printf("%d\n", min);
	}
	return 0;
}

Question

Sudeep has given an array A of size N and an integer K to Pradeep. This array consists of N integers ranging from 1 to 10^7. Each element in this array is said to have a Special Weight. The special weight of an element a[i] is a[i]%K.Pradeep needs to sort this array in Non-Increasing order of the weight of each element, i.e the element with the highest weight should appear first, then the element with the second highest weight, and so on. In case two elements have the same weight, the one with the lower value should appear in the output first.

Solution

#include <stdio.h>
#include <stdlib.h>
    void count(int a[],int n, int k){
    	int *f,*temp,i;
    	temp=(int*)malloc(n*sizeof(int));
    	f=(int*)calloc(k,sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]%k]++;
    	for(i=k-2;i>=0;i--)
    		f[i]=f[i]+f[i+1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]%k]-1]=a[i];
    		f[a[i]%k]--;
    	}
    	for(i=0;i<n;i++)
    		printf("%d ",temp[i]);
    }
    void sort(int a[],int n,int k,int m){
    	int *temp,*f,i;
    	f=(int*)calloc(m+1,sizeof(int));
    	temp=(int*)malloc(n*sizeof(int));
    	for(i=0;i<n;i++)
    		f[a[i]]++;
    	for(i=1;i<=m;i++)
    		f[i]=f[i]+f[i-1];
    	for(i=n-1;i>=0;i--){
    		temp[f[a[i]]-1]=a[i];
    		f[a[i]]--;
    	}
    	count(temp,n,k);
    }
    int main()
    {
        int n,k,i,*a,max=0;
        scanf("%d %d",&n,&k);
        a=(int*)malloc(n*sizeof(int));
        for(i=0;i<n;i++){
        	scanf("%d",&a[i]);
        	if(max<a[i])
        		max=a[i];
        }
        sort(a,n,k,max);
        return 0;
    }

Question

Rafiq has given a matrix of the same rows and same columns to Taufiq. Taufiq wants to Sort the matrix in such a manner that she will start from the first element and traverse the matrix in a clock rotation manner at the end she should be at the middle position with the largest element. Can you help Taufiq?

Solution

#include<stdio.h>
void o(){printf("arr=(int*)malloc(sizeof(int)*(row*row)); mat=(int**)malloc(sizeof(int*)*row);");}
void sort(int arr[][20], int n, int m) {
	int i, j, temp;

	for (i = 0; i < n * m - 1; ++i) {
		for (j = 0; j < n * m - 1 - i; ++j) {
			if (arr[j / m][j % m] > arr[(j + 1) / m][(j + 1) % m]) {

				temp = arr[(j + 1) / m][(j + 1) % m];
				arr[(j + 1) / m][(j + 1) % m] = arr[j / m][j % m];
				arr[j / m][j % m] = temp;

			}}}}

void calc(int arr[][20], int n, int m) 
{
    int t1,t2,t3,t4;
    t1=arr[1][2];
    t2=arr[2][1];
    t3=arr[1][0];
    t4=arr[2][2];
    arr[2][2]=arr[1][1];
    arr[1][1]=t4;
    arr[1][0]=t2;
    arr[1][2]=t3;
    arr[2][1]=t1;
    int i, j;
	for (i = 0; i < n; ++i) {
		for (j = 0; j < m; ++j) {
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}	
int main()
{
	int n, m;
	int i, j;
	int arr[20][20];
	scanf("%d", &n);
	m=n;
	for (i = 0; i < n; ++i) {
		for (j = 0; j < m; ++j) {
			scanf("%d", &arr[i][j]);
		}
	}
	sort(arr, n, m);
	calc(arr, n, m);
	return 0;
}

Question

Raguvaran conducts a course dedicated to building a map of heights of Theme park recreation center. He laid a rectangle grid of size ??×?? cells on a map (rows of grid are numbered from 1 to ?? from north to south, and columns are numbered from 1 to ?? from west to east). After that he measured the average height of each cell above Rybinsk sea level and obtained a matrix of heights of size ??×??. The cell (??,??) lies on the intersection of the ??-th row and the ??-th column and has height h??,??.Raguvaran is going to look at the result of his work in the browser. The screen of Raguvaran's laptop can fit a subrectangle of size ??×?? of matrix of heights (1=??=??, 1=??=??). Raguvaran tries to decide how the weather can affect the recreation center — for example, if it rains, where all the rainwater will gather. To do so, he is going to find the cell having minimum height among all cells that are shown on the screen of his laptop.

Solution

#include <stdio.h>
 
#define N	3000
#define M	3000
 
void slide(int *aa, int *bb, int n, int m) {
	static int qq[N];
	int i, head, cnt;
 
	head = cnt = 0;
	for (i = 0; i < n; i++) {
		while (cnt && aa[qq[head + cnt - 1]] > aa[i])
			cnt--;
		qq[head + cnt++] = i;
		if (i >= m - 1)
			bb[i - m + 1] = aa[qq[head]];
		if (qq[head] == i - m + 1)
			head++, cnt--;
	}
}
 
int main() {
	static int aa[N][M], bb[N][M], cc[N], dd[N];
	int n, m, a, b, g, x, y, z, i, j;
	long long ans;
 
	scanf("%d%d%d%d%d%d%d%d", &n, &m, &a, &b, &g, &x, &y, &z);
	for (i = 0; i < n; i++)
		for (j = 0; j < m; j++) {
			aa[i][j] = g;
			g = ((long long) g * x + y) % z;
		}
	for (i = 0; i < n; i++)
		slide(aa[i], bb[i], m, b);
	ans = 0;
	for (j = 0; j + b <= m; j++) {
		for (i = 0; i < n; i++)
			cc[i] = bb[i][j];
		slide(cc, dd, n, a);
		for (i = 0; i + a <= n; i++)
			ans += dd[i];
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Will Smith play an "I am legend" game. In this game, Will Smith leads a party of ?? heroes, and Will Smith have to clear a dungeon with ?? Zombies. Each Zombie is characterized by its power ????. Each hero is characterized by his power ???? and endurance ????.The heroes clear the dungeon day by day. In the beginning of each day, Will Smith choose a hero (exactly one) who is going to enter the dungeon this day.When the hero enters the dungeon, he is challenged by the first Zombie which was not defeated during the previous days (so, if the heroes have already defeated ?? Zombies, the hero fights with the Zombie ??+1). When the hero fights the Zombie, there are two possible outcomes:if the Zombie's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;otherwise, the Zombie is defeated.

Solution

#include<stdio.h>
#include<stdlib.h>
#define DUBEG 0
 
typedef struct __st_hero {
  int p, s;
} hero;
 
int a[200005], slen;
hero h[200005], stak[200005];
 
int cmpfn(const void *_a, const void *_b){
  hero *a, *b;
  a = (hero *)_a;
  b = (hero *)_b;
  return b->p - a->p + (b->p - a->p == 0) * (b->s - a->s);
}
 
int binsear(int x){
  int st, en, m;
  st = 0;
  en = slen - 1;
  if(stak[st].p < x) return -1;
  while(st < en){
    m = (st + en + 1) >> 1;
    if(stak[m].p < x) en = m - 1;
    else st = m;
  }
  return st;
}
 
int main(){
  int tcases;
  scanf("%d", &tcases);
  while(tcases--){
    int n, m, i, ans;
    scanf("%d", &n);
    for(i = 0;i < n;i++) scanf("%d", a + i);
    scanf("%d", &m);
    for(i = 0;i < m;i++)scanf("%d %d", &(h[i].p), &(h[i].s));
    qsort(h, m, sizeof(hero), cmpfn);
    if(DUBEG){
      printf("h:");
      for(i = 0;i < m;i++)printf(" (%d,%d)", h[i].p, h[i].s);
      printf("\n");
    }
    slen = 0;
    for(i = 0;i < m;i++){
      if(slen == 0 || stak[slen - 1].s < h[i].s) stak[slen++] = h[i];
    }
    if(DUBEG){
      printf("slen: %d\n", slen);
      for(i = 0;i < slen;i++) printf("\t%d %d\n", stak[i].p, stak[i].s);
    }
    ans = 0;
    i = 0;
    while(i < n){
      int len, curmax;
      len = 0;
      curmax = 0;
      while(i + len < n){
	if(curmax < a[i + len]) curmax = a[i + len];
	int find = binsear(curmax);
	if(find == -1) break;
	if(stak[find].s < len + 1) break;
	len++;
      }
      if(DUBEG) printf("len: %d\n", len);
      if(len == 0) {
	break;
      }
      i += len;
      ans++;
    }
    printf("%d\n", i < n ? -1 : ans);
  }
  return 0;
}

Question

Let us see how search engines work. Consider the following simple auto-complete feature. When you type some characters in the text bar, the engine automatically gives the best matching options among its database. Your job is simple. Given an incomplete search text, output the best search result.Each entry in the engine's database has a priority factor attached to it. We consider a result/search suggestion best if it has maximum weight and completes the given incomplete search query. For each query in the input, print the maximum weight of the string in the database, that completes the given incomplete search string. In case no such string exists, print -1.

Solution

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#define newTrie (Trie*) calloc(1, sizeof(Trie))
typedef struct node {
						bool isWord;
						int max;
						struct node *next[26];
					}Trie;
 
void insert(char*, Trie*, int);
void print(Trie *, char*, int);
int main(void )
{
 
	int n, w, q, i = 0;
	char string[1234];
	
	scanf("%i %i", &n,&q);
	Trie *t = newTrie, *ptr; 
	while(n--)
	{
		scanf("%s %i", string,&w);
		insert(string, t, w);
	}
    while(q--)
    {    
        scanf("%s",string);
        w=1,i=0;
        ptr = t;
        while( string[i] != '\0' )
        {
            if(ptr)
                ptr = ptr->next[string[i]-'a'];
            else
                break;
            i++;
        }    
        printf("%i\n",ptr?ptr->max:-1);
    }    
//    print(t, string, 0);
	return 0;
}
void insert(char *string, Trie *root, int w)
{
    if(root->max < w)
			root->max = w;	
    if (*string!='\0')
	{
		if (root->next[*string - 'a'] == NULL)
			root->next[*string - 'a'] = newTrie;
    	insert(string + 1, root->next[*string - 'a'], w);		
	}
	else
	{
		
		root->isWord = true;
	}
}
void print(Trie *root, char *string, int level)
{
 
	if(root->isWord == true)
	{	string[level] = '\0';
		printf("%i\n",root->max);
        puts(string);
	}
	int i;
	for( i = 0; i < 26; i++)
	{
		if (root->next[i])
		{
			string[level] = i + 'a';
			print(root->next[i], string, level + 1);
		}			
	}		
	
}

Question

Mark has decided to hold a contest on Facebook. He is prepared the problems: statements, solutions, checkers, validators, tests... Suddenly, Sundar Pitchai asks Satya Nadella to change all your tests to multiple testcases in the easiest problem!Initially, each test in that problem is just an array. The maximum size of an array is ??. For simplicity, the contents of arrays don't matter. Satya Nadella have ?? tests — the ??-th test is an array of size ???? (1=????=??).Sundar Pitchai asks Satya Nadella to distribute all of your arrays into multiple testcases. Each testcase can include multiple arrays. However, each testcase should include no more than ??1 arrays of size greater than or equal to 1 (=1), no more than ??2 arrays of size greater than or equal to 2, …, no more than ???? arrays of size greater than or equal to ??. Also, ??1=??2=?=????.So now Satya Nadella goal is to create the new testcases in such a way that:each of the initial arrays appears in exactly one testcase;for each testcase the given conditions hold;the number of testcases is minimum possible.Print the minimum possible number of testcases Satya Nadella can achieve and the sizes of arrays included in each testcase.

Solution

#include <stdio.h>
#include <stdlib.h>
int i;
void h(){
    printf("struct LLnode *next;");
}
/*struct LLnode
{
    int val;
    struct LLnode *next;
};
struct LL
{
    struct LLnode *head;
    struct LLnode *current;
    int size;
};*/
 
/*void push(struct LL *ll, int val)
{
    struct LLnode temp[100];
    temp->val = val;
    temp->next = NULL;
    if (ll->size == 0)
    {
        ll->head = temp;
        ll->current = temp;
        ll->size += 1;
    }
    else
    {
        ll->size += 1;
        ll->current->next = temp;
        ll->current = temp;
    }
}*/
 
void arrk(int *arr, int i, int j)
{   int it;
    if (i == j)
    {
        return;
    }
    int mid = (i + j) / 2;
    arrk(arr, i, mid);
    arrk(arr, mid + 1, j);
    int *arr1 = (int *)malloc(sizeof(int) * (mid - i + 1));
    int *arr2 = (int *)malloc(sizeof(int) * (j - mid));
    for ( it = 0; it < (mid - i + 1); it++)
    {
        arr1[it] = arr[it + i];
    }
    for ( it = 0; it < (j - mid); it++)
    {
        arr2[it] = arr[mid + 1 + it];
    }
    int p1 = 0, p2 = 0, cp = i;
    while (cp <= j)
    {
        if (p1 == mid - i + 1)
        {
            arr[cp] = arr2[p2];
            p2++;
        }
        else if (p2 == j - mid)
        {
            arr[cp] = arr1[p1];
            p1++;
        }
        else if (arr1[p1] < arr2[p2])
        {
            arr[cp] = arr1[p1];
            p1++;
        }
        else
        {
            arr[cp] = arr2[p2];
            p2++;
        }
        cp++;
    }
    return;
}
 
int main()
{
    int n, k,j;
    scanf("%d", &n);
    scanf("%d", &k);
    int m[n + 1];
    for ( i = 1; i <= n; i++)
    {
        scanf("%d", &m[i]);
    }
    arrk(m, 1, n);
    int c[k + 1];
    int g[k+1];
    for (i = 1; i <= k; i++)
    {
        scanf("%d", &c[i]);
    }
    int it1=1,it2=1;
    while(it1<=k){
        if(it2==n+1){
            g[it1]=0;
            it1++;
        }
        else if(it1<=m[it2]){
            g[it1]=n-it2+1;
            it1++;
        }
        else if(it1>m[it2]){
            it2++;
        }
    }
    int ans=-1;
    for( i=1;i<=k;i++){
        int c_ans=(g[i]%c[i]==0) ? g[i]/c[i] : g[i]/c[i]+1;
        ans=(c_ans>ans)?c_ans:ans;
    }
    printf("%d\n",ans);
    for( i=1;i<=ans;i++){
        printf("%d ",(n-i)/ans+1);
        for( j=i;j<=n;j+=ans){
            printf("%d ",m[j]);
        }
        printf("\n");
 
    }
    return 0;
}

Question

Ranjith has given four integers ??, ??, ??, and ?? to Manoj.Let's name a tuple (??1,??1,??2,??2) as good if:

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N	200000
#define M	200000
#define N_	(1 << 18)	/* N_ = pow2(ceil(log2(M + 1))) */
 
long long min(long long a, long long b) { return a < b ? a : b; }
 
int *od[N + 1], oo[N + 1];
 
void append(int i, int d) {
	int o = oo[i]++;
 
	if (o >= 2 && (o) == 0)
		od[i] = (int *) realloc(od[i], o * 2 * sizeof *od[i]);
	od[i][o] = d;
}
 
void init() {
	int n, d;
 
	for (n = 1; n <= N; n++)
		od[n] = (int *) malloc(2 * sizeof *od[n]);
	for (d = 1; d <= N; d++)
		for (n = d; n <= N; n += d)
			append(n, d);
}
 
int st[N_ * 2], yy[M + 1], n_;
 
void update(int i, int x, int y) {
	if (x == 1)
		yy[i] = y;
	for (i += n_; i > 1; i >>= 1)
		st[i] += x;
}
 
int query(int l, int r) {
	for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {
		if ((l & 1) == 1) {
			if (st[l] > 0) {
				while (l < n_)
					l = st[l << 1] > 0 ? l << 1 : l << 1 | 1;
				return l - n_;
			}
			l++;
		}
		if ((r & 1) == 0) {
			if (st[r] > 0) {
				while (r < n_)
					r = st[r << 1] > 0 ? r << 1 : r << 1 | 1;
				return r - n_;
			}
			r--;
		}
	}
	return 0;
}
 
int main() {
	int n, m, x1, yl, yr;
	long long l, r;
 
	init();
	scanf("%d%d%lld%lld", &n, &m, &l, &r);
	n_ = 1;
	while (n_ <= m)
		n_ <<= 1;
	for (x1 = 1, yl = yr = m; x1 <= n; x1++) {
		int o, found;
 
		while (yl > 0 && (long long) x1 * yl >= l) {
			for (o = 0; o < oo[yl]; o++) {
				int d = od[yl][o];
 
				update(d, 1, yl);
			}
			yl--;
		}
		while (yr > 0 && (long long) x1 * yr > r) {
			for (o = 0; o < oo[yr]; o++) {
				int d = od[yr][o];
 
				update(d, -1, -1);
			}
			yr--;
		}
		found = 0;
		for (o = 0; o < oo[x1]; o++) {
			int d = od[x1][o], a = x1 / d, b = query(a + 1, min(n / d, m));
 
			if (b) {
				found = 1;
				printf("%d %d %d %d\n", x1, yy[b], b * d, yy[b] / b * a);
				break;
			}
		}
		if (!found)
			printf("-1\n");
	}
	return 0;
}

Question

Ram has given an array [??1,??2,…,????] to Sakthi.Sakthi's goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, Sakthi is looking for a subarray such that if the most frequent value occurs ?? times in this subarray, then at least 2 different values should occur exactly ?? times.An array ?? is a subarray of an array ?? if ?? can be obtained from ?? by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Solution

#include <stdio.h>
#include<string.h>
#define max(a,b) (((a)>(b))?(a):(b))
int n,a[2000005],cnt[2000005],mx,id,c[2000005],book[2000005],sum,ans;
void eu(){}
int main(){
	scanf("%d",&n);
	int i,j;
	for ( i=1;i<=n;i++)scanf("%d",&a[i]),cnt[a[i]]++,mx=max(mx,cnt[a[i]]);
	for ( i=1;i<=n;i++) 
		if (cnt[a[i]]==mx)id=a[i];
	if (mx==n){
		printf("0");
		return 0;
	}
	for ( i=1;i<=100;i++){
		if (i==id)continue;
		memset(book,0,sizeof(book));
		sum=0;
		for ( j=1;j<=n;j++){
			if (a[j]==id)sum++;
			if (a[j]==i)sum--;
			if (book[sum+n]!=0)ans=max(ans,j-book[sum+n]);
			else if (sum!=0)book[sum+n]=j;
			if (sum==0)ans=max(ans,j);
		}
	}
	printf("%d",ans);
	return 0;
	printf("*ii[N] ii[a]=(int *)malloc(kk[a] *sizeof *ii[a]) ");
}

Question

We look at how is working machine. Consider the following simple auto-complete feature. When you type some characters in the text bar, the machine automatically gives the best matching options among its database. Given an incomplete search text, output the best search result.Each entry in the machine's database has a priority factor attached to it. We consider a result/search suggestion best if it has maximum weight and completes the given incomplete search query.  In case no such string exists, print -1.

Solution

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#define newTrie (Trie*) calloc(1, sizeof(Trie))
typedef struct node {
						bool isWord;
						int max;
						struct node *next[26];
					}Trie;
 
void insert(char*, Trie*, int);
void print(Trie *, char*, int);
int main(void )
{
 
	int n, w, q, i = 0;
	char string[1234];
	
	scanf("%i %i", &n,&q);
	Trie *t = newTrie, *ptr; 
	while(n--)
	{
		scanf("%s %i", string,&w);
		insert(string, t, w);
	}
    while(q--)
    {    
        scanf("%s",string);
        w=1,i=0;
        ptr = t;
        while( string[i] != '\0' )
        {
            if(ptr)
                ptr = ptr->next[string[i]-'a'];
            else
                break;
            i++;
        }    
        printf("%i\n",ptr?ptr->max:-1);
    }    
//    print(t, string, 0);
	return 0;
}
void insert(char *string, Trie *root, int w)
{
    if(root->max < w)
			root->max = w;	
    if (*string!='\0')
	{
		if (root->next[*string - 'a'] == NULL)
			root->next[*string - 'a'] = newTrie;
    	insert(string + 1, root->next[*string - 'a'], w);		
	}
	else
	{
		
		root->isWord = true;
	}
}
void print(Trie *root, char *string, int level)
{
 
	if(root->isWord == true)
	{	string[level] = '\0';
		printf("%i\n",root->max);
        puts(string);
	}
	int i;
	for( i = 0; i < 26; i++)
	{
		if (root->next[i])
		{
			string[level] = i + 'a';
			print(root->next[i], string, level + 1);
		}			
	}		
	
}

Question

Tamil New year is coming, and our protagonist, Bharathiyar, is preparing a spectacular present for his long-time best friend Tiruvalluvar. This year, he decides to prepare ?? boxes of chocolate, numbered from 1 to ??. Initially, the ??-th box contains ???? chocolate pieces.Since Bharathiyar is a typical nice guy, he will not send Tiruvalluvar ?? empty boxes. In other words, at least one of ??1,??2,…,???? is positive. Since Tiruvalluvar dislikes coprime sets, she will be happy only if there exists some integer ??>1 such that the number of pieces in each box is divisible by ??. Note that Tiruvalluvar won't mind if there exists some empty boxes.Bharathidhasan, Tiruvalluvar's boyfriend, also is Bharathiyar's second-best friend, so he decides to help Bharathiyar by rearranging the chocolate pieces. In one second, Bharathidhasan can pick up a piece in box ?? and put it into either box ??-1 or box ??+1 (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Tiruvalluvar happy.

Solution

#include<stdio.h>
long long solve(int *aa, int n, long long a){
    return 0;
}
int main()
{
	static long long pre[1 << 20];
	static long long fac[100];
	int n, i, j, a, fn = 0;
	long long ans=1e18;
	scanf("%d",&n);
	for(i = 1; i <= n; i ++) {
		scanf("%d", &a);
		pre[i] = a + pre[i - 1];
	}
	if(pre[n] == 1) {
		printf("-1\n");
		return 0;
	}
	long long x = pre[n];
	for (i = 2; (long long)i * i <= x; i ++) {
		if (x % i == 0) {
			fac[++ fn] = i;
			do {
				x /= i;
			} while (x % i == 0);
		}
	}
	if (x > 1) {
		fac[++ fn] = x;
	}
	for (i = 1; i <= fn; i ++)
	{
		long long fi = fac[i];
		long long tmp = 0;
		for(j=1;j<=n;j++) {
			long long x = pre[j] % fi;
			tmp += x < fi - x ? x : fi - x;
		}
		ans = ans > tmp ? tmp : ans;
	}
	printf("%lld\n", ans);
	return 0;
}

Question

Ramanujan has come to the mathematics exam and wants to solve as many problems as possible. He prepared and carefully studied the rules by which the exam passes.The exam consists of ?? problems that can be solved in ?? minutes. Thus, the exam begins at time 0 and ends at time ??. Ramanujan can leave the exam at any integer time from 0 to ??, inclusive.All problems are divided into two types:easy problems — Ramanujan takes exactly ?? minutes to solve any easy problem;hard problems — Ramanujan takes exactly ?? minutes (??>??) to solve any hard problem.Thus, if Ramanujan starts solving an easy problem at time ??, then it will be solved at time ??+??. Similarly, if at a time ?? Ramanujan starts to solve a hard problem, then it will be solved at time ??+??.For every problem, Ramanujan knows if it is easy or hard. Also, for each problem is determined time ???? (0=????=??) at which it will become mandatory (required). If Ramanujan leaves the exam at time ?? and there is such a problem ?? that ????=?? and he didn't solve it, then he will receive 0 points for the whole exam. Otherwise (i.e if he has solved all such problems for which ????=??) he will receive a number of points equal to the number of solved problems. Note that leaving at time ?? Ramanujan can have both "mandatory" and "non-mandatory" problems solved.

Solution

#include <stdio.h>
#include <stdlib.h>
 
#define N 200000
void h(){
    
}
int min(int a, int b) {
	return a < b ? a : b;
}
 
int hard[N], tt[N];
 
int compare(const void *a, const void *b) {
	int i = *(int *) a;
	int j = *(int *) b;
 
	return tt[i] - tt[j];
}
 
int main() {
	int m;
 
	scanf("%d", &m);
	while (m--) {
		static int ii[N];
		int n, t, a, b, i, x, y, k, k1, k2, ans;
		long long time;
 
		scanf("%d%d%d%d", &n, &t, &a, &b);
		for (i = 0; i < n; i++)
			scanf("%d", &hard[i]);
		for (i = 0; i < n; i++)
			scanf("%d", &tt[i]);
		x = y = 0;
		for (i = 0; i < n; i++)
			if (!hard[i])
				x++;
			else
				y++;
		if ((long long) x * a + (long long) y * b <= t) {
			printf("%d\n", n);
			continue;
		}
		for (i = 0; i < n; i++)
			ii[i] = i;
		qsort(ii, n, sizeof *ii, compare);
		ans = time = 0;
		for (i = 0; i < n; i++) {
			if (time < tt[ii[i]]) {
				k1 = min(x, (tt[ii[i]] - 1 - time) / a);
				k2 = min(y, (tt[ii[i]] - 1 - time - k1 * a) / b);
				k = i + k1 + k2;
				if (ans < k)
					ans = k;
			}
			if (!hard[ii[i]])
				x--, time += a;
			else
				y--, time += b;
		}
		printf("%d\n", ans);
	}
	return 0;
}

Question

Madhesh has given an array [??1,??2,…,????] to Magesh.Magesh's goal is to find the length of the longest subarray of this array such that the most frequent value in it is not unique. In other words, Magesh was looking for a subarray such that if the most frequent value occurs ?? times in this subarray, then at least 2 different values should occur exactly ?? times.An array ?? is a subarray of an array ?? if ?? can be obtained from ?? by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

Solution

#include <stdio.h>
#include<string.h>
#define max(a,b) (((a)>(b))?(a):(b))
int n,a[2000005],cnt[2000005],mx,id,c[2000005],book[2000005],sum,ans;
void eu(){}
int main(){
	scanf("%d",&n);
	int i,j;
	for ( i=1;i<=n;i++)scanf("%d",&a[i]),cnt[a[i]]++,mx=max(mx,cnt[a[i]]);
	for ( i=1;i<=n;i++) 
		if (cnt[a[i]]==mx)id=a[i];
	if (mx==n){
		printf("0");
		return 0;
	}
	for ( i=1;i<=100;i++){
		if (i==id)continue;
		memset(book,0,sizeof(book));
		sum=0;
		for ( j=1;j<=n;j++){
			if (a[j]==id)sum++;
			if (a[j]==i)sum--;
			if (book[sum+n]!=0)ans=max(ans,j-book[sum+n]);
			else if (sum!=0)book[sum+n]=j;
			if (sum==0)ans=max(ans,j);
		}
	}
	printf("%d",ans);
	return 0;
	printf("*ii[N]ii[a] = (int *) malloc(kk[a] * sizeof *ii[a]) ");
}

Question

The United Kingdom is attacked by the Periya Marudhu and Chinna Marudhu!The Kingdom is guarded by ?? castles, the ??-th castle is defended by ???? soldiers. To conquer the United Kingdom, the Kings have to eliminate all the defenders.Each day the Periya Marudhu launches an attack on one of the castles. Then, at night, the forces of the Chinna Marudhu attack a castle (possibly the same one). Then the Periya Marudhu attacks a castle, then the Chinna Marudhu, and so on. The first attack is performed by the Periya Marudhu.Each attack must target a castle with at least one alive defender in it. There are three types of attacks:a mixed attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders);an infantry attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders);a cavalry attack decreases the number of defenders in the targeted castle by ?? (or sets it to 0 if there are already less than ?? defenders).The mixed attack can be launched at any valid target (at any castle with at least one soldier). However, the infantry attack cannot be launched if the previous attack on the targeted castle had the same type, no matter when and by whom it was launched. The same applies to the cavalry attack. A castle that was not attacked at all can be targeted by any type of attack.

Solution

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
 
#define N	300000
#define M	10000
#define X	5
#define Y	5
#define Z	5
#define MD	0x7fffffff
 
long long max(long long a, long long b) { return a > b ? a : b; }
 
void srand_() {

}
 
int rand_(int n) {
	return (rand() * 76543LL + rand()) % n;
}
 
int oo[1 + M], ok[1 + M], ov[1 + M], _;
 
int link(int o, int k, int v) {
	oo[_] = o, ok[_] = k, ov[_] = v;
	return _++;
}
 
int ht[M], X_;
 
int hash(int k) {
	return (long long) k * X_ % MD % M;
}
 
void ht_put(int k, int v) {
	int h = hash(k), o;
 
	for (o = ht[h]; o; o = oo[o])
		if (ok[o] == k) {
			ov[o] = v;
			return;
		}
	ht[h] = link(ht[h], k, v);
}
 
int ht_get(int k, int v) {
	int h = hash(k), o;
 
	for (o = ht[h]; o; o = oo[o])
		if (ok[o] == k)
			return ov[o];
	return v;
}
 
int *bb[X + 1][Y + 1][Z + 1], pp[X + 1][Y + 1][Z + 1], cc[X + 1][Y + 1][Z + 1];
 
int mex(int a, int b, int c) {
	int d = 0;
 
	while (a == d || b == d || c == d)
		d++;
	return d;
}
 
void init() {
	int x, y, z, i;
 
	srand_();
	X_ = rand_(MD >> 1) + (MD >> 1);
	for (x = 1; x <= 5; x++)
		for (y = 1; y <= 5; y++)
			for (z = 1; z <= 5; z++) {
				static int qu[M];
				int b, t_, t, cnt;
 
				memset(ht, 0, sizeof ht), _ = 1;
				b = 0, t = 1, cnt = 0;
				while ((t_ = ht_get(b, 0)) == 0) {
					int c, dx, dy, dz;
 
					ht_put(b, t++);
					qu[cnt++] = b;
					c = 0, dx = dy = dz = -1;
					for (i = 0; i < x + y + z; i++) {
						int d = b >> i * 2 & 3;
 
						if (i < x) {
							if (i == 0)
								dx = d;
							else
								c |= d << (i - 1) * 2;
						} else if (i < x + y) {
							if (i == x)
								dy = d;
							else
								c |= d << (i - 1) * 2;
						} else {
							if (i == x + y)
								dz = d;
							else
								c |= d << (i - 1) * 2;
						}
					}
					c |= mex(dx, dy, dz) << (x - 1) * 2
						| mex(dx, dz, -1) << (x + y - 1) * 2
						| mex(dx, dy, -1) << (x + y + z - 1) * 2;
					b = c;
				}
				bb[x][y][z] = (int *) malloc(cnt * sizeof *bb[x][y][z]);
				memcpy(bb[x][y][z], qu, cnt * sizeof *qu);
				cc[x][y][z] = t - t_;
				pp[x][y][z] = cnt - cc[x][y][z];
			}
}
 
int grundy(int x, int y, int z, long long a, int t) {
	int b = bb[x][y][z][a < pp[x][y][z] ? a : pp[x][y][z] + (a - pp[x][y][z]) % cc[x][y][z]];
	if (t == 0)
		return b >> (x - 1) * 2 & 3;
	if (t == 1)
		return b >> (x + y - 1) * 2 & 3;
	return b >> (x + y + z - 1) * 2 & 3;
}
 
int main() {
	int t;
 
	init();
	scanf("%d", &t);
	while (t--) {
		static long long aa[N];
		static int gr[N], grx[N], gry[N], grz[N];
		int n, x, y, z, i, g, ans;
 
		scanf("%d%d%d%d", &n, &x, &y, &z);
		for (i = 0; i < n; i++)
			scanf("%lld", &aa[i]);
		g = 0;
		for (i = 0; i < n; i++) {
			g ^= gr[i] = grundy(x, y, z, aa[i], 0);
			grx[i] = grundy(x, y, z, max(aa[i] - x, 0), 0);
			gry[i] = grundy(x, y, z, max(aa[i] - y, 0), 1);
			grz[i] = grundy(x, y, z, max(aa[i] - z, 0), 2);
		}
		ans = 0;
		for (i = 0; i < n; i++) {
			if ((g ^ gr[i] ^ grx[i]) == 0)
				ans++;
			if ((g ^ gr[i] ^ gry[i]) == 0)
				ans++;
			if ((g ^ gr[i] ^ grz[i]) == 0)
				ans++;
		}
		printf("%d\n", ans);
	}
	return 0;
}

Question

There are 'n' players playing a circket. 

Every player has a skill value denoted by 'Si'. Before the game starts, each player can change their skill value to any non-negative integer smaller than their current skill value or leave it untouched. 

The coolness of the game is then defined as the bitwise-xor of the players skill values. 

We'd like to know for every number X from 0 to m the number of ways that the coolness of the game equals X. 

Solution

#include <stdio.h>
#include <stdlib.h>
#define MOD 1000000007
 
int main(){
	int N, M, element, xor,curr, prev, i, j, k;
	long int** counts=(long int**)malloc(2*sizeof(long int*));
	counts[0] = (long int*)calloc(512, sizeof(long int));
	counts[1] = (long int*)calloc(512, sizeof(long int)); 
 
	scanf("%d %d", &N, &M);         			
 
	counts[0][0] = 1;
	for(k=0; k<N; k++) {
		scanf("%d", &element);
 
		curr = 1;
		prev = 0;
 
		for(i=0; i<=element; i++) {
			for(j=0; j<512; j++) {
				
				xor = i ^ j;
				if(counts[prev][j] > 0) { // to check if that sum exists, only then we consider it's xor. It's not really necessary, cause we'll just be adding zero, but it's good for sense and readability.
					counts[curr][xor] += counts[prev][j];
				} 
				if(counts[curr][xor] >= MOD) {
					counts[curr][xor] -= MOD;
				}
			}
		}
 
		for(i=0; i<512; i++) {
			counts[prev][i] = counts[curr][i];
			counts[curr][i] = 0;
		}
	}
 
	for(i=0; i<=M; i++) {
		printf("%ld ", counts[0][i]);
	}
return 0;}

Question

Akhil and Vimal are working on different types of projects both with equal priority. They both need to run some batches of processes. 

A batch has processes which need some systems to run them irrespective of the number of process running on each dependent system. If a batch runs then the dependent systems are occupied by its processes. 

No system can run processes from different projects and thus a system can process only Vimal's processes or Akhil's processes. 

Their manager being a stylo creep has allowed Akhil to run his batches.Vimal felt offended and complained the CTO directly due to which the manager came up with a condition that if Vimal can increase the number of processes running in total by replacing some or all of Akhil's processes then only he can run his batches. 

Vimal wants to maximize the total processes running in order to show the manager his skills. Help him complete his task.

Solution

#include <stdio.h>
#include<stdlib.h>
#define MAX(a,b) ((a>b)?a:b);
int main()
{
    int sys,*pra,nob,nop,ch_pro=0,ch_sys,pr_pro=0,b_sys,j,b_pro,tot_pro;
    scanf("%d",&sys);
    int i;
    pra = (int *)malloc(sys*sizeof(int));
    for(i=0;i<sys;i++){
    	scanf("%d",&pra[i]);
    	pr_pro += pra[i];
    }
    tot_pro = pr_pro;
    scanf("%d",&nob);
    for(i=0;i<nob;i++){
    	scanf("%d",&ch_sys);
    	nop = 0;
    	for(j=0;j<ch_sys;j++){
    		scanf("%d",&b_sys);
    		nop += pra[b_sys-1];
    	}
    	scanf("%d",&b_pro);
    	ch_pro += b_pro;
    	if(nop < b_pro)
    	    tot_pro += b_pro-nop;
    }
    int res = MAX(tot_pro-pr_pro,ch_pro-pr_pro);
    printf("%d",res);
    return 0;
}

Question

Hasan has given a string (S) of length (N) to Sathya. 

Also, he has given an integer (K). 

The string consists of digits from (1-9) only. 

Determine the number of ways to partition the string (S) such that each segment value is less than (K).If there is no way to perform partition on the string, then print 0. 

Since the answer could be large, print the answer as 10^9+7

Solution

#include <stdio.h>
#include <stdlib.h>
#define MOD 1000000007
 
long long int custom_strtoll(char* arr, int left, int right) {
	int i;
	long long int result = 0;
	for(i=left; i<=right; i++) {
		result = result*10 + (arr[i]-48);
	}
	return result;
}
int main(){
	int caseCount, len, i, j;
	long long int K;
	scanf("%d", &caseCount);              			
	
char* string =(char*)malloc(100000*sizeof(char));
	int* substrMax = (int*)malloc(100000 * sizeof(int));
 
	while(caseCount > 0) {
 
		scanf("%d %lld", &len, &K);
		scanf("%s", string);
 
		for(i=0; i<100000; i++)
			substrMax[i] = 0;
 
		for(i=len-1; i>=0; i--) {
			
			for(j=i; j<len; j++) {
				
				if(custom_strtoll(string, i, j) < K ) {
					if(j == (len-1)) {
						substrMax[i] = (substrMax[i] + 1) % MOD;
					} else {
						substrMax[i] = (substrMax[i] + substrMax[j+1]) % MOD;
					}
				} else {
					break;
				}
			}
		}
 
		printf("%d\n", substrMax[0]);
		caseCount--;
	}
return 0;}

Question

Yasir is nowadays boasting a lot about his excellence in Programming. 

As Kathir is already the most reputed code master of Technical, he is already irritated with Yasir bragging about his skills and decides to end it once and for all.

 To do so, he decides to challenge Yasir with a task which needs extensive knowledge of bits.Kathir gives him an array A of n distinct integers. He now asks him to tell in how many ways can he generate a new array B from the elements of A choosing each element from A at most one time such that bitwise-OR of all the elements of array B is equal to k.Yasir has promised you with a huge treat in Taj coromandel if you can help him out of this situation. 

So be quick to help out Yasir.

Solution

#include <stdio.h>
#include<math.h>
#define ll long long int
#define si1(a) scanf("%d", &a)
#define sil1(a) scanf("%lld", &a)
#define sil2(a,b) scanf("%lld%lld", &a, &b)
#define sil3(a, b, c) scanf("%lld%lld%lld", &a, &b, &c)
#define MOD 1000000007
#define pil1(a) printf("%lld\n", a)

int tot,arr[105],n,k,fact[100];

void makesub(int ind,int runor,int num){
    if(ind==n){
        if(runor==k){
            tot+= fact[num];
        }
        return;
    }
    makesub(ind+1,runor,num);
    makesub(ind+1,(runor|arr[ind]),num+1);
}
 

int main()
{
    int t;
    scanf("%d",&t);
    ll i,ans=1;
    for (i = 1; i < 40; ++i)
    {
        ans*=i;fact[i]= ans%MOD;
        //printf("%d ",ans);
    }
    while(t--)
    {
        tot=0;
        scanf("%d %d",&n,&k);
        for(i=0;i<n;i++)
        {
            scanf("%d",&arr[i]);
        }
        //printf("%d\n",1|2|4 );
        makesub(0,0,0);
        printf("%d\n",tot );
    }
    return 0;
}

Question

Messi's family consists of 'n' men. 

We can show them with a rooted tree with 'n' vertices. 

Messi wants to choose 'k' of them for playing Football but he shouldn't choose someone and his brother too. 

In short, there should be no direct siblings, both selected for playing Football.

Solution

#include<stdio.h>
#include<stdlib.h>
void h(){
    printf("(int*)malloc(sizeof(int)*(n+1))\n(int*)malloc(sizeof(int)*(k+1))");
}
int **dp, sz, *counter;
long mod = 1000000007;
    int solve(int idx, int num) {
        if (num == 0) {
            return 1;
        }
        if (idx == sz) {
            return 0;
        }
        if (dp[idx][num] == -1) {
            long sum = 0;
            sum = solve(idx + 1, num);
            sum = (sum + counter[idx] * (long)solve(idx + 1, num - 1)) % mod;
            dp[idx][num] = (int) sum;
        }
        return dp[idx][num];
    }
 
    int main() {
        int n, k, i, j, *P, parent;
        scanf("%d %d\n", &n, &k);
        P = (int*)malloc(sizeof(int) * (n + 1));
        for (i = 2; i <= n; ++i) {
        	scanf("%d ", &parent);
            ++P[parent];
        }
        for (i = 1, sz = 1; i <= n; ++i) {
            if (P[i] > 0) 
                ++sz;
        }
        counter = (int*)malloc(sizeof(int) * sz);
        for (i = 1, j = 0, counter[0] = 1; i <= n; ++i) 
            if (P[i] > 0) 
                counter[++j] = P[i];
        dp = (int**)malloc(sizeof(int*) * sz);
        for (i = 0; i < sz; ++i) {
        	dp[i] = (int*)malloc(sizeof(int) * (k + 1));
        	for (j = 1; j <= k; ++j) {
        		dp[i][j] = -1;
        	}
        }
        printf("%d\n", solve(0, k));
   return 0; }

Question

Dr. Viru Sahastrabuddhe was a strict professor and he had N students. The N student were sitting in a room. 

Each student was wearing a white T-shirt, with a unique number from the range 1 to N written on it. 

T-Shirts of pink and blue color were to be distributed among the students by Dr. Viru Sahastrabuddhe. This made the students very happy.Dr. Viru Sahastrabuddhe felt that a random distribution of T-Shirts would be very uninteresting. 

So, he decided to keep an interesting condition:

Solution

#include <stdio.h>
#include"stdlib.h"
#include"string.h"
// need to find if the graph is bi-partite.
// if it is then there are two ways to color it since there is only one connected component

#define WHITE	2
#define PINK 	1
#define BLUE	0
#define BOY		0
#define GIRL	1
 
typedef struct node{
	int vertex;
	struct node* next;
}node_t;
 
node_t** adjList;
int* colour;
int* gender;
 
int findInversions( int n ){
	int* queue = (int*)calloc(n,sizeof(int));
	int queueStart = n-1; 
	int queueEnd = n-1;
	queue[n-1] = 0; // 0 is the source vertex;
	colour[0] = BLUE; // arbitrary
	while( queueStart<=queueEnd ){
		int vertex = queue[queueEnd--];
		node_t* t=adjList[vertex];
		while(t!=NULL){
			int v2 = t->vertex;
			if( colour[v2] == WHITE ){
				colour[v2] = 1- colour[vertex];	
				queue[--queueStart] = v2;
			}
			else
				if( colour[v2] == colour[vertex] )
					return -1;
			
			t=t->next;
		}
	}
	// coming here means that coloring is possible
	// now count the inversions in this coloring
	int count =0,i;
	for( i=0;i<n;i++)
		if(colour[i] != gender[i]) count ++; 
	if( count > n/2 ) count = n-count;
	return count;
}
 
int main()
{
    int n,m,v1,v2,i;
    char* temp;
    scanf("%d%d", &n, &m);
    temp = (char*) calloc(4, sizeof(char));
    adjList = (node_t**)calloc(n,sizeof(node_t*));
    colour=(int*)calloc(n,sizeof(int));
    gender=(int*)calloc(n,sizeof(int));
    for( i=0;i<n;i++){
    	scanf("%s", temp);
    	if(temp[0] == 'B') 
    		gender[i] = BOY;
    	else 
    		gender[i] = GIRL;
    	colour[i] = WHITE;
    	adjList[i]= NULL;
    }
    for( i=0;i<m;i++){
    	scanf("%d%d", &v1, &v2);
    	v1--;v2--; // 0 based indexing
    	node_t* t = (node_t*)malloc(sizeof(node_t));
    	t->vertex = v2;
    	t->next = adjList[v1];
    	adjList[v1] = t;
    	
    	t = (node_t*)malloc(sizeof(node_t));
    	t->vertex = v1;
    	t->next = adjList[v2];
    	adjList[v2] = t;
    }
    
    int Result = findInversions( n );
    
    if(Result == -1) printf("Not Possible\n");
    else printf("%d\n", Result);
    
    //printf("1\n");
    return 0;
}

Question

There is a cave of N cells where each cell has a trap or is safe to land. 

From a cell 'i', you can jump to cells i+1 or i+2. 

Also, if number 'i' is special, then you can also jump from cell 'i' to cell 'i+A' where A = number of primes in [1, i]. 

A number 'i' can be special if frac{Ai} => frac r1,r2.You are given the following:

Solution

#include<stdio.h>
#define n 100000
#define INT_MAX 9999999
long ans[n+1];
void h(){
    printf("(int *)malloc((n+1)*sizeof(int))");
}
void sieve(){
	int primes[n+1],i,j;
	for (i = 0; i < n+1; ++i)
	{
		primes[i]=1;
	}
	for (i = 2; i*i < n+1; ++i)
	{
		if(primes[i]){
			for (j = i*i; j < n+1; j+=i)
			{
				primes[j]=0;
			}
		}
	}
	ans[0]=ans[1]=0;
	for (i = 2; i < n+1; ++i)
	{
		ans[i]=ans[i-1]+primes[i];
	}
 
}
void solve(char *arr,int m,int r1,int r2){
	if(arr[0]=='*'||arr[m-1]=='*'){
		printf("No way!\n");
		return;
	}
	int dp[m],i;
	for ( i = 0; i < m; ++i)
	{
		dp[i]=n;
	}
	dp[0]=0;
	for ( i = 0; i < m; ++i)
	{
		if(arr[i]=='#' && dp[i]!=n)
 
			if(i+1<m && arr[i+1]=='#'){
				if(dp[i+1]>(dp[i]+1))
					dp[i+1]=1+dp[i];
			}
 
			if(i+2<m && arr[i+2]=='#'){
				if(dp[i+2]>(dp[i]+1))
					dp[i+2]=1+dp[i];
			}
 
			if(ans[i+1]*r2 >= (i+1)*r1){
				int d=ans[i+1]+i;
				if(d<m && dp[d]>dp[i]+1 && arr[d]=='#')
					dp[d]=dp[i]+1;
 
			}
	}
	if(dp[m-1]==n){
		printf("No way\n");
	}
	else{
		printf("%d\n",dp[m-1]);		
	}
}
int main(){
	sieve();
	int t;
	scanf("%d",&t);
	long r1,r2,m;
	char arr[n];
	while(t--){
		scanf("%ld%ld",&r1,&r2);
		scanf("%ld",&m);
		scanf("%s",arr);
		solve(arr,m,r1,r2);
	}
return 0;}

Question

Xavi, the miraculous Football player from The Generation of Miracles is not yet defeated in any of his games until he met the Lionel Messi and Cristiano Ronaldo. Finally, during his game, he achieved an unknown state called The Zone.He can now analyse the Football court as a set of N nodes connected with N-1 edges. These set of N nodes are rooted at node 1. For each of the N node, he assumes one of the two conditions:1, if the node is to be visited in his drive to perform a freestyle kick.0, if the node is not be visited in his drive to perform a freestyle kick.However, in the drift of his exhilarating match, he finds that some nodes don't satisfy his expected assumption.He can, thus, perform an operation on any of the given node such that:he can invert the condition of the node and if he inverts the condition of a particular node, the sons of this node don't get their conditions inverted but the sons of sons of the node get their conditions inverted but the sons of sons of sons don't and so on..

Solution

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <time.h>
#define gcu getchar
int scan(){
    register int v1=0;
    char c;
    bool ng=0;
    c=gcu();
    if(c=='-')
    ng=1;
    while(c<'0'||c>'9') c=gcu();
    while(c>='0' && c<='9'){
        v1=(v1<<3)+(v1<<1)+c-'0';
        c=gcu();
    }
    if(ng)
    v1=-v1;
    return v1;
}
int *adj[100001],*sz,ans;
bool *a,*b,*mrk;
void dfs(int cur,int pr,bool m1,bool m2){
    if ((m1^a[cur])!=b[cur]){
        ++ans;
        mrk[cur]=1;
        m1^=1;
    }int i;
    for(i=0;i<sz[cur];++i){
        if(adj[cur][i]!=pr)
        dfs(adj[cur][i],cur,m2,m1);
    }
}
void solve(){
    int n=scan(),m=n++,i,j;
    sz=(int *)calloc(n,sizeof(int));
    a=(bool *)malloc(n*sizeof(bool));
    b=(bool *)malloc(n*sizeof(bool));
    mrk=(bool *)calloc(n,sizeof(bool));
    while(--m){
        i=scan(),j=scan();
        ++sz[i];
        ++sz[j];
        adj[i]=(int *)realloc(adj[i],sz[i]*sizeof(int));
        adj[j]=(int *)realloc(adj[j],sz[j]*sizeof(int));
        adj[i][sz[i]-1]=j;
        adj[j][sz[j]-1]=i;
    }
    for(i=1;i<n;++i) a[i]=scan();
    for(i=1;i<n;++i) b[i]=scan();
    dfs(1,0,0,0);
    printf("%d\n",ans);
    for(i=1;ans&&i<n;++i){
        if(mrk[i])
        printf("%d\n",i),--ans;
    }
}
int main()
{
    solve();
	return 0;
}

Question

Zonni's favourite is Lion cub loves lucky strings. 

Zonni knows that the lucky string is a string of digits that contains only the lucky digits 4 and 7. The Lion cub has the strings A and B of digits. These strings are of equal lengths, that is |A| = |B|. He wants to get some lucky string from them. 

For this he performs the following operations. At first he arbitrary reorders digits of A. 

Then he arbitrary reorders digits of B. After that he creates the string C such that its i-th digit is the maximum between the i-th digit of A and the i-th digit of B. 

In other words, C[i] = max{A[i], B[i]} for i from 1 to |A|. 

After that he removes from C all non-lucky digits saving the order of the remaining (lucky) digits. 

So C now becomes a lucky string.Zonni's Lion cub wants the resulting string to be as lucky as possible. 

Solution

#include <stdio.h>
#include <string.h>
void h(){
    printf("#define min(string1,string2) string1<string2?string1:string2");
}
int main()
{
    char a[20001], b[20001];
    int t, i, n, a0, a4, a5, a7, b0, b4, b5, b7, c4,  c7;
    scanf("%d", &t);
    while (t--)
    {
        a0 = 0; a4 = 0; a5 = 0; a7 = 0;
        b0 = 0; b4 = 0; b5 = 0; b7 = 0;
                c4 = 0;         c7 = 0;
        
        scanf("%s %s", a ,b);
        n = strlen(a);
        for (i = 0; i < n; i++)
        {
            if (a[i] < '4')
                a0++;
            else if (a[i] == '4')
                a4++;
            else if (a[i] < '7')
                a5++;
            else if (a[i] == '7')
                a7++;
            else
                continue;
        }
        for (i = 0; i < n; i++)
        {
            if (b[i] < '4')
                b0++;
            else if (b[i] == '4')
                b4++;
            else if (b[i] < '7')
                b5++;
            else if (b[i] == '7')
                b7++;
            else
                continue;
        }
        while (a7 != 0)
        {
            if (b5 > 0)
            {
                a7--;
                b5--;
                c7++;
            }
            else if (b0 > 0)
            {
                a7--;b0--;
                c7++;
            }
        }
        while (b7 != 0)
        {
            if (a5 > 0)
            {b7--;a5--;c7++;}
            else if (a0 > 0)
            {b7--;a0--;c7++;}
            else if (a4 > 0)
            {b7--;a4--;c7++;}
        }
        while (a4 != 0){
            if (b0 > 0){b0--;a4--;c4++;}
            else if (b4 > 0){b4--;a4--;c4++;}
            else
                break;
        }
        while (b4 != 0){
            if (a0 > 0){
                a0--;b4--;c4++;}
            else
                break;}
        for (i = 0; i < c7; i++)
            printf("7");
        for (i = 0; i < c4; i++)
            printf("4");
        printf("\n");
    }return 0;}

Question

Dharma has given the time in numerals to Vinod. 

Vinod wants to convert the given in time into words as shown below:

5:00 ? five o' clock

5:01 ? one minute past finve

5:15 ? quarter past five

5:30 ? half past five

5:40 ? twenty minutes to six

5:45 ? quarter to six

Solution

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void h(){
    printf("word=(char *)malloc(7*sizeof(char));");
}
void numname(int n)
{
    switch(n/10)
    {
        case 1:switch(n%10)
               {
                   case 0:printf("ten");
                          break;
                   case 1:printf("eleven");
                          break;
                   case 2:printf("twelve");
                          break;
                   case 3:printf("thirteen");
                          break;
                   case 4:printf("fourteen");
                          break;
                   case 5:printf("fifteen");
                          break;
                   case 6:printf("sixteen");
                          break;
                   case 7:printf("seventeen");
                          break;
                   case 8:printf("eighteen");
                          break;
                   case 9:printf("nineteen");
                          break;
               }
               break;
        case 2:printf("twenty");
               if(n%10!=0)
                printf(" ");
               break;
        case 3:printf("thirty");
               if(n%10!=0)
                printf(" ");
               break;
        case 4:printf("forty");
               if(n%10!=0)
                printf(" ");
               break;
        case 5:printf("fifty");
                if(n%10!=0)
                printf(" ");
               break;
    }
    if(n/10!=1)
    switch(n%10)
    {
        case 1:printf("one");
               break;
        case 2:printf("two");
               break;
        case 3:printf("three");
               break;
        case 4:printf("four");
               break;
        case 5:printf("five");
               break;
        case 6:printf("six");
               break;
        case 7:printf("seven");
               break;
        case 8:printf("eight");
               break;
        case 9:printf("nine");
               break;
    }
}
int main() {
    int h,m;
    scanf("%d%d",&h,&m);
    if(m==0)
    {
        numname(h);
        printf(" o' clock");
    }
    else if(m==30)
    {
        printf("half past ");
        numname(h);
    }
    else if(m==15)
    {
        printf("quarter past ");
        numname(h);
    }
    else if(m==45)
    {
        printf("quarter to ");
        numname(h+1);
    }
    else if(m<30)
    {
        numname(m);
        if(m==1)
            printf(" minute past ");
        else
            printf(" minutes past ");
        numname(h);
    }
    else
    {
        numname(60-m);
        if(m==1)
            printf(" minute to ");
        else
            printf(" minutes to ");
        numname(h+1);
    }
    return 0;
}

Question

In Carmona, they have a very strange monetary system. 

Each Carmonaian gold coin has an integer number written on it. 

A coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. 

But these numbers are all rounded down (the banks have to make a profit).You can also sell Carmonaian coins for American dollars. The exchange rate is 1:1. 

But you can not buy Carmonaian coins. 

You have one gold coin. 

What is the maximum amount of American dollars you can get for it?

Solution

#include <stdio.h>
#define MAX 231
 
int cnt;
int key[MAX];
long long int value[MAX];
long long int exchange(int n) {
	long long int tot;
	int flag = 1,i;
	if(n <= 11) 
		tot = n;
	else {
		for(i = 0; i < cnt; ++i) 
			if(key[i] == n) {
				tot = value[i];
				flag = 0;
				break;
			}
		if(flag) {
			tot = exchange(n/2) + exchange(n/3) + exchange(n/4);
			key[cnt] = n;
			value[cnt++] = tot;
		}
	}
	
	return tot;
}
 
int main(void) {
	int n;
	scanf("%d",&n);
	printf("%lld",exchange(n));
	return 0;
}

Question

Efficient management of a database requires to deal with issues such as Low Latency, Caching and most of all redundancy. Today, you need to perform some testing of a test database provided to you.

Given the database of Fazzi company, this database contains a table Users. This users table stores for each user 4 pieces of information i.e their Name, Age, Hometown and Address in this order. The size of this table is rather large, and you need to help in resolving some issues.

Solution

#include <stdio.h>
#include <string.h>
void h(){
    printf("for(i=0;i<N;i++)\nfor(j=i+1;j<N;j++)");
}
int main()
{
	int t,i,j;
	scanf("%d", &t);
	char ch1[t][6], ch2[t][6], ch3[t][6];
	int age[t];
	int num[t * t], num1[t * t];
	for( i = 0; i < t; i++){
		scanf("%s%d%s%s", ch1[i], &age[i], ch2[i], ch3[i]);
	}
	int count1 = 0;
	for( i = 0; i < t; i++){
		for( j = i + 1; j < t; j++){
			if (age[i] == age[j]){
				num[count1] = i + 1;
				num1[count1] = j + 1;
				count1++;
			}
		}
	}
	printf("%d\n", count1);
	for(i = 0; i < count1; i++){
		printf("%d %d\n", num[i], num1[i]);
	}
return 0;}

Question

Bheem loves to play with iron (Fe) and magnets (Ma). He took a row of N cells (numbered 1 through N) and placed some objects in some of these cells. 

You are given a string S with length N describing them; for each valid i, the i-th character of S is one of the following:'I' if the i-th cell contains a piece of iron'M' if the i-th cell contains a magnet'_' if the i-th cell is empty

Solution

#include <stdio.h>
#include<math.h>
int main(void) {
	// your code goes here
	int t;
	scanf("%d",&t);
	while(t--)
	{
	    int n,k;
	    scanf("%d %d",&n,&k);
	    char s[n];
	    scanf("%s",s);
	    int i,p,c,count=0,j;
	i=0;j=0;
	int power=0;//I::M//MIM_XII:M
	while(i<n&&j<n)
	{
	    c=0;
	    if(s[i]=='M')
	    {
	        if (s[j]=='I')
	        {
	            if(j>i)
	         for(p=i;p<j;p++)
	             if(s[p]==':')
	             c++;
	            else
	            {
	                    for(p=j;p<i;p++)
	             if(s[p]==':')
	             c++;
	            }
	            
	         power=k+1-(j-i)-c;
	         if(power>0)
	         {
	             i++;
	             j++;
	             count++;
	         }
	         else
	         {
	             if(i>j)
	             j++;
	             else
	             i++;
	         }
	        }
	        
	        else if(s[j]=='X')
	    {
	        j++;
	        i=j;
	    }
	        
	        else
	        j++;
	    }
	    else if(s[i]=='X')
	    {
	        i++;
	       j=i;
	    }
	    else
	    i++;
	    
	}
	    printf("%d\n",count);
	}
	
	return 0;
}

Question

There is a major shootout going on in Africa. 

Gunmen can be encountered in most of the streets and only a few of them are safe. 

Deva is given the responsibility to ensure the safety of the people by asking them to shift to the nearest safe street.There are N streets on the road. The i-th street is denoted by the number A[i]. 

Gunmen do not enter streets that are denoted by a prime number i.e. i-th street is safe, if A[i] is a prime.Help Deva find the nearest safe street for people trapped in all the N streets i.e. print N integers, where the i-th integer is the index (1-based) of the nearest safe street. The distance between cities i and j is given by |i - j|. 

For any city j, if there exists no safe city i, such that people of city j can move to city i, print 1 for it.

Solution

#include <stdio.h>
 
void soe(int a[])
{
	int i,j;
	for(i=2;i<=500000;i++)
	{
		if(a[i]==1)
		{
			for(j=2*i;j<=1000000;j+=i)
		    a[j]=0;
		}
	}
}
 
int main()
{
    int n,i,x,index;
    scanf("%d",&n);
    int a[n],b[n],c[1000001];
    for(i=2;i<=1000000;i++)
    c[i]=1;
    c[1]=0;
    c[0]=0;
    soe(c);
    x=0;
    for(i=0;i<n;i++)
    {
    	scanf("%d",&a[i]);
    	if(c[a[i]]==1)
    	b[x++]=i+1;
    }
    if(x==0)
    {
    	for(i=0;i<n;i++)
    	printf("-1 ");
    }
    else
    {
    	if(b[x-1]!=n)
        b[x++]=n+1;
    	i=1;
    	while(i<b[0])
    	{
    		printf("%d ",b[0]);
    		i++;
    	}
    	index=0;
    	while(i<=n)
    	{
    		if(i-b[index]<=b[index+1]-i || b[index+1]==n+1)
    		printf("%d ",b[index]);
    		else
    		printf("%d ",b[index+1]);
    		if(i==b[index+1])
    		index++;
    		i++;
    	}
    }
    return 0;
}

Question

Anjali has a crush on Priya's friend and wants to go out with him. But he is a very geeky person and wants Anjali to solve his Word Game for going out. 

The game contains a string S consisting of uppercase Latin letters ('A'-'Z'). 

Now Anjali is given N words(A1,A2,...,An) arranged vertically one below the other.

The rules of the game are:

She can swap two consecutive letters of any word Ai.For example, if word Ai is "word", she can change it to "owrd" by swapping "w" and "o" or she can change it to "wrod" by swapping "r" and "o". She can use swapping in a word any number of times including zero.
She cannot swap letters of two different words.
Using rule 1 and 2, she has to make string S by using the first letter of each word Ai staring from i=1 to i=n without changing the order of words and without skipping any word ie. letter Si should be the first letter of Ai.

Tell whether or not she will be able to make the given string S in the game.

Solution

#include<stdio.h>
#include<string.h>
int main()
{
    long long i,j,k,t,n,p=0;
    char str[100001];
    scanf("%lld",&n);
   for(i=0;i<n;i++)
    {
        scanf(" %[^\n]%lld", str,&t);
        k = strlen(str);
        char sty[t][100001];
        for(j=0; j<t; j++)
        {
            scanf(" %[^\n]", sty[j]);
        }
        if(k!=t)
        {
            printf("NO\n");
        }
        else
        {
            for(j=0; j<t; j++)
            {

                    if(strchr(sty[j],str[j]))
                    {
                        p=1;
                    }
                    else
                    {
                        p = 0;
                        break;
                    }
            }
            if(p==1)
            {
                printf("YES\n");
            }
            else
            {
                printf("NO\n");
            }
        }
    }
    return 0;
}

Question

Once Agent 007's handler 'James' became angry with him and gave him a task.Given a number "N" and an array 'A' of size 'P', agent 007 has to tell the count of total numbers in the range [1,N], which are divisible by any of the array elements.Since, Agent 007 is not very great at Mathematics , he asks for your help.

Solution

#include <stdio.h>
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        long long int n,p;
        scanf("%lld %lld",&n,&p);
        long long int a[p];
        int i,j,count=0;
        for(i=0;i<p;i++)
        scanf("%lld",&a[i]);
        for(i=1;i<=n;i++){
            int temp=0;
            for(j=0;j<p;j++){
                if(i%a[j]==0)
                temp++;
            }
            if(temp>0)
            count++;
        }
        printf("%d\n",count);
    }
	return 0;
}

Question

Rahul is an multitalented young man which means he is on the cusp of many things like science, music and drama.He also has a keen interest in developing new things.

Rahul loves his parents. His parent love to listen to music in FM. 

So he had an idea of developing his own FM Radio Frequency Changer Application as a gift to his parents wedding anniversary which is a week ahead.But unfortunately, Rahul's exams is in the corner. So can you help him in the development process so that he can gift it to his parents?

Solution

#include <stdio.h>
typedef enum{SF=93,RC=91,BFM=92,RFM=96,HFM=106,RM=98,AFMG=100,CL=104}FM;
int main()
{
    FM freq;
    scanf("%u",&freq);
    if(freq == 93)
        printf("Suryan FM");
    else if(freq == 91)
        printf("Radio City");
    else if(freq == 92)
        printf("Big FM");
    else if(freq == 96)
        printf("Red FM");
    else if(freq == 106)
        printf("Hello FM");
    else if(freq == 98)
        printf("Radio Mirchi");
    else if(freq == 100)
        printf("AIR FM Gold");
    else if(freq == 104)
        printf("Chennai Live FM");
	return 0;
}

Question

Bear Grylls decided to go for hill climbing this weekend, but he doesn't have the map of all the hills. However, he can make his own map. There are N hills arranged on a line, each in the form of a vertical line segment with one endpoint on the ground. The hills are numbered with integers from 1 to N from left to right. The ith hill has height hi.A beautiful set S is set of hills such that for any hi, hj present in set S, (hi * hj)%p!=1.Note that here i can be equal to j. Here p is any prime integer. To make the map, Bear Grylls needs maximum possible size of the beautiful set.Note that two sets are considered different if they contain at least one point which is different. Two sets are considered same if they contain the same points.

Solution

#include <stdio.h>
#define maxn 100000
int X[maxn];
int max( int a, int b ) 
{
	return (a > b) ? a : b;
}
int Power( int a, int b, int p ) 
{
	long long ret = 1;
	while( b > 0 ) 
	{
		if( b % 2 ) 
		{
			ret = (ret * a) % p; 
		}
		
		b /= 2;
		a = ((long long) a * a) % p;
	}
	return (int) ret;
} 
int InverseMod( int a, int p ) 
{
	return Power(a, p-2, p);
}
int main( void ) {
	int n, p,i;
	scanf("%i %i",&n,&p);
	long long num;
	for(  i = 0; i < n; i++ ) {
		scanf("%lld", &num);
		X[num%p]++;
	}
	int count = X[0];
	for( i = 1; i < p; i++ ) 
	{
		if( X[i] == 0 ) continue;
		int j = InverseMod(i, p);
		if( i != j ) 
		{
			count += max(X[i], X[j]);
		}
		X[j] = X[i] = 0;
	}
	printf("%i\n", count);
	return 0;
}

Question

There are N marbonites in a line, numbered 1 through N from left to right. 

Count numbers of ways to remove exactly M marbonites such that there are exactly C remaining connected components. 

A part [a,b] of sequence is called a connected component if for all a <= i <= b there is a marbonite at position i and also there are no marbonites at positions a-1 and b+1 (either because those marbonites have been removed or because they are out of range [1,N]).

Solution

#include <stdio.h>
#define MAX_N 100000
#define MOD 1000000007
 
long fac[MAX_N+1], invFac[MAX_N+1];
 
void xgcd(long long *result, long long a, long long b) {
    long aa[2]={1,0}, bb[2]={0,1}, q;
    while(1) {
        q = a / b; a = a % b;
        aa[0] = aa[0] - q*aa[1];  bb[0] = bb[0] - q*bb[1];
        if (a == 0) {
            result[0] = b; result[1] = aa[1]; result[2] = bb[1];
            return;
        };
        q = b / a; b = b % a;
        aa[1] = aa[1] - q*aa[0];  bb[1] = bb[1] - q*bb[0];
        if (b == 0) {
            result[0] = a; result[1] = aa[0]; result[2] = bb[0];
            return;
        };
    };
}
 
long inv(long a)
{
	long long gcdResult[3];
	long res;
	xgcd(gcdResult, a, MOD);
	res = gcdResult[1] % MOD;
	if(res < 0)
		res += MOD;
	return res;
}
 
void makeBinom()
{
	long long n;
 
	fac[0] = invFac[0] = 1;
	for(n = 1; n <= MAX_N; n++)
	{
		fac[n] = (n * fac[n-1]) % MOD;
		invFac[n] = inv(fac[n]);
	}
	
}
 
long mult(long long a, long long b)
{
	return (a * b) % MOD;
}
 
long binom(long n, long k)
{
	long res;
 
	if(k > n)
		return 0;
	res = mult(fac[n], invFac[k]);
	res = mult(res, invFac[n-k]);
	return res;
}
 
int main()
{
	int T;
	long res, N, M, C;
 
	makeBinom();
	scanf("%d", &T);
	while(T--)
	{
	    scanf("%ld %ld %ld",&N,&M,&C);
		if(N==M)
			res = (C==0)?1:0;
		else
			res = mult(binom(N-M-1, C-1), binom(M+1, C));
		printf("%ld\n", res);
	}
	return 0;
}

Question

Sometimes, the stability of a stock market is at least as important as rapid price changes.Let a stable block be a maximal consecutive block of days with some stock prices.Moreover, let a stable block of order K be a stable block of length at least K.For example, if stock prices for 7 consecutive days are: 20, 10, 10, 7, 7, 7, 10

Then there are 4 stable blocks there: 

[20], [10, 10], [7, 7, 7] and [10]. 

Moreover, there are:0 stable blocks of order 4 or higher

Solution

#include <stdio.h>
//#include <iostream>
//using namespace std;
//#define for(int i=0;i<n;i++)	for(int i=0;i<n;i++)
//#define fo(i,a,b)	for(int i=a;i<=b;i++)
 
int max(int a,int b){return a<=b ? b : a;}
int min(int a,int b){return a<=b ? a : b;}
 
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,q;
		scanf("%d %d",&n,&q);
		long a[n];
		int mc=1,temp=1;
		int i=0;
		int mco[n];
		for(i=0;i<n;i++)	mco[i]=0;
		mco[0]=1;
		for (i=0;i<n;i++)
		{
			scanf("%ld",&a[i]);
			if(i){
				if(a[i]==a[i-1]){
					mc=max(mc,++temp);
					mco[i]=mco[i-1];
				}
				else{
					temp=1;
					mco[i]=mco[i-1]+1;
				}
			}
		}
		int li[n];
		li[n-1]=n-1;
		for(i=n-2;i>=0;i--)
		{
			if(a[i]==a[i+1])	li[i]=li[i+1];
			else	li[i]=i;
		}
//		for(int i=0;i<n;i++)	cerr<<li[i]<<" ";
//		cerr<<"\n";
//		for(int i=0;i<n;i++)	cerr<<mco[i]<<" ";
//		cerr<<"\n";
 
		for(i=0;i<q;i++)
		{
			int l,r,k;
			scanf("%d %d %d",&l,&r,&k);
			if(mc<k)
			{
				printf("0\n");
				continue;
			}
			if(k==1 )
			{
				printf("%d\n",mco[r-1]-mco[l-1]+1);
				continue;
			}
			if(mc==1 && k==1)
			{
				printf("%d\n",r-l+1);
				continue;
			}
			if(mc==n)
			{
				printf("1\n");
				continue;
			}
			int temp;
 
 
			int ans=0;
			l-=1,r-=1;
			int j=l;
			while(j<=r)
			{
				temp=min(li[j],r);
				if(temp-j+1>=k )
					ans++;
				j=li[j]+1;
			}
 
			printf("%d\n",ans);
		}
 
	}
 
	return 0;
}